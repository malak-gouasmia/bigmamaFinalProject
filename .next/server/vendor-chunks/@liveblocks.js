"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   StopRetrying: () => (/* binding */ StopRetrying2),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.9.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function _forceClear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    _forceClear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options.size ?? DEFAULT_SIZE;\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch) {\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let notifyImmediately = true;\n  let dirty = false;\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const oldState = state;\n    const newState = callback(oldState);\n    if (newState !== oldState) {\n      state = newState;\n      dirty = true;\n    }\n    if (notifyImmediately) {\n      notify();\n    }\n  }\n  function notify() {\n    if (!dirty) {\n      return;\n    }\n    dirty = false;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function batch(cb) {\n    if (notifyImmediately === false) {\n      return cb();\n    }\n    notifyImmediately = false;\n    try {\n      cb();\n    } finally {\n      notifyImmediately = true;\n      notify();\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    batch,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/http-client.ts\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  );\n}\n\n// src/notifications.ts\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"Expected a /v2/c/* endpoint\");\n    }\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url2 = urljoin(baseUrl, endpoint, params);\n    const response = await fetcher(url2.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await fetchJson(url`/v2/c/inbox-notifications`, void 0, {\n      cursor: options?.cursor,\n      limit: PAGE_SIZE\n    });\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(since) {\n    const json = await fetchJson(url`/v2/c/inbox-notifications/delta`, void 0, {\n      since: since.toISOString()\n    });\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(url`/v2/c/inbox-notifications/count`);\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(url`/v2/c/inbox-notifications/read`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(url`/v2/c/inbox-notifications/read`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await fetchJson(url`/v2/c/inbox-notifications`, {\n      method: \"DELETE\"\n    });\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await fetchJson(url`/v2/c/inbox-notifications/${inboxNotificationId}`, {\n      method: \"DELETE\"\n    });\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await fetchJson(url`/v2/c/threads`, void 0, {\n      cursor: options.cursor,\n      query,\n      limit: PAGE_SIZE\n    });\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await fetchJson(url`/v2/c/threads`, void 0, {\n      since: options.since.toISOString()\n    });\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  return {\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/autoRetry.ts\nasync function autoRetry(promiseFn, maxTries, backoff, throwError) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    const promise = promiseFn();\n    try {\n      return await promise;\n    } catch (err) {\n      if (throwError?.(err) || err instanceof StopRetrying2) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\nvar StopRetrying2 = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar GET_ATTACHMENT_URLS_BATCH_DELAY = 50;\nvar ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\nvar ATTACHMENT_PART_BATCH_SIZE = 5;\nvar RETRY_ATTEMPTS = 10;\nvar RETRY_DELAYS = [\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3\n];\nfunction splitFileIntoParts(file) {\n  const parts = [];\n  let start = 0;\n  while (start < file.size) {\n    const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n    parts.push({\n      partNumber: parts.length + 1,\n      part: file.slice(start, end)\n    });\n    start = end;\n  }\n  return parts;\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Y.js\n    provider: void 0,\n    onProviderUpdate: makeEventSource(),\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(endpoint, authValue, options2, params) {\n    if (!endpoint.startsWith(\"/v2/c/rooms/\")) {\n      raise(\"Expected a /v2/c/rooms/* endpoint\");\n    }\n    const url2 = urljoin(config.baseUrl, endpoint, params);\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url2, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(url`/v2/c/rooms/${roomId}/storage`, authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      endpoint === \"/send-message\" ? url`/v2/c/rooms/${config.roomId}/send-message` : url`/v2/c/rooms/${config.roomId}/text-metadata`,\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n      }\n    );\n  }\n  async function createTextMention(userId, mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/text-mentions`,\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          userId,\n          mentionId\n        })\n      }\n    );\n  }\n  async function deleteTextMention(mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`,\n      managedSocket.authValue,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/text-metadata`,\n      authValue,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ type, rootKey })\n      }\n    );\n  }\n  async function listTextVersions() {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/versions`,\n      authValue,\n      {\n        method: \"GET\"\n      }\n    );\n  }\n  async function getTextVersion(versionId) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`,\n      authValue,\n      { method: \"GET\" }\n    );\n  }\n  async function createTextVersion() {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/version`,\n      authValue,\n      { method: \"POST\" }\n    );\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  async function fetchCommentsApi(endpoint, params, options2) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(endpoint, authValue, options2, params);\n  }\n  async function fetchCommentsJson(endpoint, options2, params) {\n    const response = await fetchCommentsApi(endpoint, params, options2);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreadsSince(options2) {\n    const response = await fetchCommentsApi(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      { since: options2?.since?.toISOString() },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: {\n          updated: json.data.map(convertToThreadData),\n          deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n        },\n        inboxNotifications: {\n          updated: json.inboxNotifications.map(convertToInboxNotificationData),\n          deleted: json.deletedInboxNotifications.map(\n            convertToInboxNotificationDeleteInfo\n          )\n        },\n        requestedAt: new Date(json.meta.requestedAt)\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: {\n          updated: [],\n          deleted: []\n        },\n        inboxNotifications: {\n          updated: [],\n          deleted: []\n        },\n        requestedAt: /* @__PURE__ */ new Date()\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThreads(options2) {\n    let query;\n    if (options2?.query) {\n      query = objectToQuery(options2.query);\n    }\n    const PAGE_SIZE = 50;\n    const response = await fetchCommentsApi(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      {\n        cursor: options2?.cursor,\n        query,\n        limit: PAGE_SIZE\n      },\n      { headers: { \"Content-Type\": \"application/json\" } }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map(convertToThreadData),\n        inboxNotifications: json.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: json.meta.nextCursor,\n        requestedAt: new Date(json.meta.requestedAt)\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        nextCursor: null,\n        requestedAt: /* @__PURE__ */ new Date()\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread(threadId) {\n    const response = await fetchCommentsApi(\n      url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId = createCommentId(),\n    threadId = createThreadId(),\n    attachmentIds\n  }) {\n    const thread = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body,\n            attachmentIds\n          },\n          metadata\n        })\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(threadId) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}`,\n      { method: \"DELETE\" }\n    );\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function markThreadAsResolved(threadId) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`,\n      { method: \"POST\" }\n    );\n  }\n  async function markThreadAsUnresolved(threadId) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`,\n      { method: \"POST\" }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId = createCommentId(),\n    body,\n    attachmentIds\n  }) {\n    const comment = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body,\n          attachmentIds\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body,\n    attachmentIds\n  }) {\n    const comment = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body,\n          attachmentIds\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\n      { method: \"DELETE\" }\n    );\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`,\n      { method: \"DELETE\" }\n    );\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    const abortSignal = options2.signal;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof CommentsApiError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        () => fetchCommentsJson(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          {\n            method: \"PUT\",\n            body: attachment.file,\n            signal: abortSignal\n          },\n          {\n            fileSize: attachment.size\n          }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        () => fetchCommentsJson(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          {\n            method: \"POST\",\n            signal: abortSignal\n          },\n          {\n            fileSize: attachment.size\n          }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, ATTACHMENT_PART_BATCH_SIZE);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                () => fetchCommentsJson(\n                  url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  {\n                    method: \"PUT\",\n                    body: part,\n                    signal: abortSignal\n                  }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return fetchCommentsJson(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({ parts: sortedUploadedParts }),\n            signal: abortSignal\n          }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await fetchCommentsApi(\n              url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              void 0,\n              {\n                method: \"DELETE\"\n              }\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  async function getAttachmentUrls(attachmentIds) {\n    const { urls } = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ attachmentIds })\n      }\n    );\n    return urls;\n  }\n  const batchedGetAttachmentUrls = new Batch(\n    async (batchedAttachmentIds) => {\n      const attachmentIds = batchedAttachmentIds.flat();\n      const attachmentUrls = await getAttachmentUrls(attachmentIds);\n      return attachmentUrls.map(\n        (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n      );\n    },\n    { delay: GET_ATTACHMENT_URLS_BATCH_DELAY }\n  );\n  const attachmentUrlsStore = createBatchStore(batchedGetAttachmentUrls);\n  function getAttachmentUrl(attachmentId) {\n    return batchedGetAttachmentUrls.get(attachmentId);\n  }\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(endpoint, authValue, options2);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getNotificationSettings() {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`\n    );\n  }\n  function updateNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ inboxNotificationIds })\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        getProvider() {\n          return context.provider;\n        },\n        setProvider(provider) {\n          context.provider = provider;\n          context.onProviderUpdate.notify();\n        },\n        onProviderUpdate: context.onProviderUpdate.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current,\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const fetcher = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  fetch;\n  const httpClientLike = createNotificationsApi({\n    baseUrl,\n    fetcher,\n    authManager,\n    currentUserIdStore\n  });\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  return Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      ...httpClientLike,\n      // Internal\n      [kInternal]: {\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        // \"All\" threads (= \"user\" threads)\n        getUserThreads_experimental: httpClientLike.getUserThreads_experimental,\n        getUserThreadsSince_experimental: httpClientLike.getUserThreadsSince_experimental\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback, interval) {\n  let context = { state: \"stopped\" };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule();\n    }\n    void callback();\n  }\n  function schedule() {\n    context = {\n      state: \"running\",\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval)\n    };\n  }\n  function start() {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule();\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = { state: \"stopped\" };\n  }\n  function enable(condition) {\n    if (condition) {\n      start();\n    } else {\n      stop();\n    }\n  }\n  return {\n    enable\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUIsR0FBRyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0EscUdBQXFHLGtCQUFrQjtBQUN2SDtBQUNBO0FBQ0EsV0FBVyxTQUFTLEVBQUUsVUFBVTtBQUNoQyxXQUFXLFNBQVMsRUFBRSxjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix3QkFBd0I7QUFDM0c7QUFDQTtBQUNBLGFBQWEsVUFBVSxRQUFRLFlBQVk7QUFDM0MsYUFBYSxTQUFTLFFBQVEsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLHFCQUFxQixXQUFXLGdCQUFnQix1QkFBdUIsZ0JBQWdCO0FBQ3ZIO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBb0I7QUFDOUQ7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLLFFBQVEsU0FBUyxVQUFVLGNBQWM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLEdBQUcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0EsZ0JBQWdCLHdEQUF3RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0R0FBNEcsYUFBYSxZQUFZLGVBQWU7QUFDcEo7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1B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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCLElBQUk7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxhQUFhLE1BQXFDO0FBQ2xEO0FBQ0EsRUFBRSxDQUFRO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVUsWUFBWSxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsZ0NBQWdDLE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksR0FBRywwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxHQUFHLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUMsK0JBQStCLENBQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7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QTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUSxvQkFBb0IsdUJBQXVCLE1BQU0sSUFBSSxRQUFRLFFBQVEscUJBQXFCLHNCQUFzQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUssRUFHTjtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQW9FRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz8zZTA5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi45LjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL2R1cGUtZGV0ZWN0aW9uLnRzXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge307XG52YXIgY3Jvc3NMaW5rZWREb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvY3Jvc3MtbGlua2VkXCI7XG52YXIgZHVwZXNEb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvZHVwZXNcIjtcbnZhciBTUEFDRSA9IFwiIFwiO1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVjdER1cGVzKHBrZ05hbWUsIHBrZ1ZlcnNpb24sIHBrZ0Zvcm1hdCkge1xuICBjb25zdCBwa2dJZCA9IFN5bWJvbC5mb3IocGtnTmFtZSk7XG4gIGNvbnN0IHBrZ0J1aWxkSW5mbyA9IHBrZ0Zvcm1hdCA/IGAke3BrZ1ZlcnNpb24gfHwgXCJkZXZcIn0gKCR7cGtnRm9ybWF0fSlgIDogcGtnVmVyc2lvbiB8fCBcImRldlwiO1xuICBpZiAoIWdbcGtnSWRdKSB7XG4gICAgZ1twa2dJZF0gPSBwa2dCdWlsZEluZm87XG4gIH0gZWxzZSBpZiAoZ1twa2dJZF0gPT09IHBrZ0J1aWxkSW5mbykge1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBNdWx0aXBsZSBjb3BpZXMgb2YgTGl2ZWJsb2NrcyBhcmUgYmVpbmcgbG9hZGVkIGluIHlvdXIgcHJvamVjdC4gVGhpcyB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7ZHVwZXNEb2NzICsgU1BBQ0V9YCxcbiAgICAgIFwiXCIsXG4gICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtnW3BrZ0lkXX0gKGFscmVhZHkgbG9hZGVkKWAsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7cGtnQnVpbGRJbmZvfSAodHJ5aW5nIHRvIGxvYWQgdGhpcyBub3cpYFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBlcnJvcihtc2cpO1xuICB9XG4gIGlmIChwa2dWZXJzaW9uICYmIFBLR19WRVJTSU9OICYmIHBrZ1ZlcnNpb24gIT09IFBLR19WRVJTSU9OKSB7XG4gICAgZXJyb3IoXG4gICAgICBbXG4gICAgICAgIGBDcm9zcy1saW5rZWQgdmVyc2lvbnMgb2YgTGl2ZWJsb2NrcyBmb3VuZCwgd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2Nyb3NzTGlua2VkRG9jcyArIFNQQUNFfWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgICBgLSAke1BLR19OQU1FfSBpcyBhdCAke1BLR19WRVJTSU9OfWAsXG4gICAgICAgIGAtICR7cGtnTmFtZX0gaXMgYXQgJHtwa2dWZXJzaW9ufWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQWx3YXlzIHVwZ3JhZGUgYWxsIExpdmVibG9ja3MgcGFja2FnZXMgdG8gdGhlIHNhbWUgdmVyc2lvbiBudW1iZXIuXCJcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdO1xufVxuZnVuY3Rpb24gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCkge1xuICBjb25zdCBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vbmV0aW1lT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29uZXRpbWVPYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIF9mb3JjZUNsZWFyKCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb25ldGltZU9ic2VydmVycy5zaXplICsgX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIF9mb3JjZUNsZWFyLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBwYXVzZSxcbiAgICB1bnBhdXNlLFxuICAgIC8vIFB1YmxpY2x5IGV4cG9zYWJsZSBzdWJzY3JpcHRpb24gQVBJXG4gICAgb2JzZXJ2YWJsZToge1xuICAgICAgc3Vic2NyaWJlLFxuICAgICAgc3Vic2NyaWJlT25jZSxcbiAgICAgIHdhaXRVbnRpbFxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mYW5jeS1jb25zb2xlLnRzXG52YXIgZmFuY3lfY29uc29sZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYW5jeV9jb25zb2xlX2V4cG9ydHMsIHtcbiAgZXJyb3I6ICgpID0+IGVycm9yMixcbiAgZXJyb3JXaXRoVGl0bGU6ICgpID0+IGVycm9yV2l0aFRpdGxlLFxuICB3YXJuOiAoKSA9PiB3YXJuLFxuICB3YXJuV2l0aFRpdGxlOiAoKSA9PiB3YXJuV2l0aFRpdGxlXG59KTtcbnZhciBiYWRnZSA9IFwiYmFja2dyb3VuZDojMGUwZDEyO2JvcmRlci1yYWRpdXM6OTk5OXB4O2NvbG9yOiNmZmY7cGFkZGluZzozcHggN3B4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NjAwO1wiO1xudmFyIGJvbGQgPSBcImZvbnQtd2VpZ2h0OjYwMFwiO1xuZnVuY3Rpb24gd3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcIiVjTGl2ZWJsb2Nrc1wiLCBiYWRnZSwgbWVzc2FnZSwgLi4uYXJncylcbiAgKTtcbn1cbnZhciB3YXJuID0gd3JhcChcIndhcm5cIik7XG52YXIgZXJyb3IyID0gd3JhcChcImVycm9yXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhUaXRsZShtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKHRpdGxlLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXG4gICAgICBgJWNMaXZlYmxvY2tzJWMgJHt0aXRsZX1gLFxuICAgICAgYmFkZ2UsXG4gICAgICBib2xkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApXG4gICk7XG59XG52YXIgd2FybldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJ3YXJuXCIpO1xudmFyIGVycm9yV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcImVycm9yXCIpO1xuXG4vLyBzcmMvbGliL2ZzbS50c1xuZnVuY3Rpb24gZGlzdGFuY2Uoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgaWYgKHN0YXRlMSA9PT0gc3RhdGUyKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBjb25zdCBjaHVua3MxID0gc3RhdGUxLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgY2h1bmtzMiA9IHN0YXRlMi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG1pbkxlbiA9IE1hdGgubWluKGNodW5rczEubGVuZ3RoLCBjaHVua3MyLmxlbmd0aCk7XG4gIGxldCBzaGFyZWQgPSAwO1xuICBmb3IgKDsgc2hhcmVkIDwgbWluTGVuOyBzaGFyZWQrKykge1xuICAgIGlmIChjaHVua3MxW3NoYXJlZF0gIT09IGNodW5rczJbc2hhcmVkXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwID0gY2h1bmtzMS5sZW5ndGggLSBzaGFyZWQ7XG4gIGNvbnN0IGRvd24gPSBjaHVua3MyLmxlbmd0aCAtIHNoYXJlZDtcbiAgcmV0dXJuIFt1cCwgZG93bl07XG59XG5mdW5jdGlvbiBwYXR0ZXJucyh0YXJnZXRTdGF0ZSwgbGV2ZWxzKSB7XG4gIGNvbnN0IHBhcnRzID0gdGFyZ2V0U3RhdGUuc3BsaXQoXCIuXCIpO1xuICBpZiAobGV2ZWxzIDwgMSB8fCBsZXZlbHMgPiBwYXJ0cy5sZW5ndGggKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgbGV2ZWxzXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobGV2ZWxzID4gcGFydHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goXCIqXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSBsZXZlbHMgKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbGljZSA9IHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5qb2luKFwiLlwiKSArIFwiLipcIik7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKHRhcmdldFN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBTYWZlQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmN1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcGF0Y2hpbmcgb2YgdGhlIGNvbnRleHQsIGJ5XG4gICAqIGNhbGxpbmcgYGNvbnRleHQucGF0Y2goKWAuIFBhdGNoaW5nIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoaXMgd2luZG93LlxuICAgKi9cbiAgYWxsb3dQYXRjaGluZyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXRjaGFibGVDb250ZXh0ID0ge1xuICAgICAgLi4udGhpcy5jdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLmN1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLmN1cnIsIHBhdGNoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMocGF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm8gbG9uZ2VyIHBhdGNoIHN0YWxlIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgbmV4dElkID0gMTtcbnZhciBGU00gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RhdGVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0ZXMgZGVmaW5lZCB5ZXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIG1hY2hpbmUgYnkgZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgdGhpcy5lbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAxIC8qIFNUQVJURUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdG9wIGEgc3RhdGUgbWFjaGluZSB0aGF0IGhhc24ndCBzdGFydGVkIHlldFwiKTtcbiAgICB9XG4gICAgdGhpcy5leGl0KG51bGwpO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQrKztcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLmtub3duRXZlbnRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuZXZlbnRIdWIgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbFRyYW5zaXRpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRFbnRlclN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbiBleHBsaWNpdCBmaW5pdGUgc3RhdGUgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAqL1xuICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX09LXCIsIGRhdGEgfSwgb25PSyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBPbiBFcnJvclxuICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuIFRoZSBzdGF0ZSBuYW1lLCBvciBzdGF0ZSBncm91cCBwYXR0ZXJuIG5hbWUuXG4gICAqIEBwYXJhbSBhZnRlciAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGlzIHRha2VuLCB0aGUgdGltZXIgd2lsbCBnZXQgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIG1hcEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFpclsxXTtcbiAgICByZXN1bHRba2V5XSA9IG1hcEZuKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gd2FpdChtaWxsaXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtaWxsaXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9uU3VjY2VzcyhmYWN0b3J5Rm4pIHtcbiAgbGV0IGNhY2hlZCA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgY2FjaGVkID0gZmFjdG9yeUZuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYWNoZWQgPSBudWxsO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL1NlcnZlck1zZy50c1xudmFyIFNlcnZlck1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNc2dDb2RlMikgPT4ge1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfSk9JTkVEXCJdID0gMTAxXSA9IFwiVVNFUl9KT0lORURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0xFRlRcIl0gPSAxMDJdID0gXCJVU0VSX0xFRlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJCUk9BRENBU1RFRF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVEVEX0VWRU5UXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUk9PTV9TVEFURVwiXSA9IDEwNF0gPSBcIlJPT01fU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIl0gPSAyMDBdID0gXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUkVKRUNUX1NUT1JBR0VfT1BcIl0gPSAyOTldID0gXCJSRUpFQ1RfU1RPUkFHRV9PUFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAwXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfQ1JFQVRFRFwiXSA9IDQwMF0gPSBcIlRIUkVBRF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0RFTEVURURcIl0gPSA0MDddID0gXCJUSFJFQURfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCJdID0gNDAxXSA9IFwiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfVVBEQVRFRFwiXSA9IDQwOF0gPSBcIlRIUkVBRF9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9DUkVBVEVEXCJdID0gNDAyXSA9IFwiQ09NTUVOVF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9FRElURURcIl0gPSA0MDNdID0gXCJDT01NRU5UX0VESVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfREVMRVRFRFwiXSA9IDQwNF0gPSBcIkNPTU1FTlRfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIl0gPSA0MDVdID0gXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCJdID0gNDA2XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCI7XG4gIHJldHVybiBTZXJ2ZXJNc2dDb2RlMjtcbn0pKFNlcnZlck1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvSVdlYlNvY2tldC50c1xudmFyIFdlYnNvY2tldENsb3NlQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChXZWJzb2NrZXRDbG9zZUNvZGVzMikgPT4ge1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX05PUk1BTFwiXSA9IDFlM10gPSBcIkNMT1NFX05PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX0FCTk9STUFMXCJdID0gMTAwNl0gPSBcIkNMT1NFX0FCTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVU5FWFBFQ1RFRF9DT05ESVRJT05cIl0gPSAxMDExXSA9IFwiVU5FWFBFQ1RFRF9DT05ESVRJT05cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUUllfQUdBSU5fTEFURVJcIl0gPSAxMDEzXSA9IFwiVFJZX0FHQUlOX0xBVEVSXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiXSA9IDRlM10gPSBcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJOT1RfQUxMT1dFRFwiXSA9IDQwMDFdID0gXCJOT1RfQUxMT1dFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIl0gPSA0MDAyXSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiXSA9IDQwMDNdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiXSA9IDQwMDRdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiXSA9IDQwMDVdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJST09NX0lEX1VQREFURURcIl0gPSA0MDA2XSA9IFwiUk9PTV9JRF9VUERBVEVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiS0lDS0VEXCJdID0gNDEwMF0gPSBcIktJQ0tFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRPS0VOX0VYUElSRURcIl0gPSA0MTA5XSA9IFwiVE9LRU5fRVhQSVJFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX1dJVEhPVVRfUkVUUllcIl0gPSA0OTk5XSA9IFwiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiO1xuICByZXR1cm4gV2Vic29ja2V0Q2xvc2VDb2RlczI7XG59KShXZWJzb2NrZXRDbG9zZUNvZGVzIHx8IHt9KTtcbmZ1bmN0aW9uIHNob3VsZERpc2Nvbm5lY3QoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gNDk5OSAvKiBDTE9TRV9XSVRIT1VUX1JFVFJZICovIHx8IGNvZGUgPj0gNGUzICYmIGNvZGUgPCA0MTAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNDEwMCAmJiBjb2RlIDwgNDIwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDEzIC8qIFRSWV9BR0FJTl9MQVRFUiAqLyB8fCBjb2RlID49IDQyMDAgJiYgY29kZSA8IDQzMDA7XG59XG5cbi8vIHNyYy9jb25uZWN0aW9uLnRzXG5mdW5jdGlvbiBpc0lkbGUoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXR1cyA9PT0gXCJkaXNjb25uZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXRlID0gbWFjaGluZS5jdXJyZW50U3RhdGU7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiQG9rLmNvbm5lY3RlZFwiOlxuICAgIGNhc2UgXCJAb2suYXdhaXRpbmctcG9uZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gICAgY2FzZSBcIkBpZGxlLmluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICBjYXNlIFwiQGF1dGguYnVzeVwiOlxuICAgIGNhc2UgXCJAYXV0aC5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiOlxuICAgIGNhc2UgXCJAaWRsZS56b21iaWVcIjpcbiAgICAgIHJldHVybiBtYWNoaW5lLmNvbnRleHQuc3VjY2Vzc0NvdW50ID4gMCA/IFwicmVjb25uZWN0aW5nXCIgOiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiQGlkbGUuZmFpbGVkXCI6XG4gICAgICByZXR1cm4gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICBjb25zdCBkZXRhaWxzID0gW2Bjb2RlOiAke2V2ZW50LmNvZGV9YF07XG4gIGlmIChldmVudC5yZWFzb24pIHtcbiAgICBkZXRhaWxzLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gIH1cbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoJHtkZXRhaWxzLmpvaW4oXCIsIFwiKX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgb25NZXNzYWdlLnBhdXNlKCk7XG4gIGNvbnN0IG9uTGl2ZWJsb2Nrc0Vycm9yID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGZpcmVFcnJvckV2ZW50KGVycm1zZywgZXJyY29kZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKGVycm1zZywgZXJyY29kZSk7XG4gICAgICBvbkxpdmVibG9ja3NFcnJvci5ub3RpZnkoZXJyKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0ge1xuICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICBhdXRoVmFsdWU6IG51bGwsXG4gICAgc29ja2V0OiBudWxsLFxuICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgfTtcbiAgY29uc3QgbWFjaGluZSA9IG5ldyBGU00oaW5pdGlhbENvbnRleHQpLmFkZFN0YXRlKFwiQGlkbGUuaW5pdGlhbFwiKS5hZGRTdGF0ZShcIkBpZGxlLmZhaWxlZFwiKS5hZGRTdGF0ZShcIkBpZGxlLnpvbWJpZVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJ1c3lcIikuYWRkU3RhdGUoXCJAYXV0aC5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYnVzeVwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAb2suY29ubmVjdGVkXCIpLmFkZFN0YXRlKFwiQG9rLmF3YWl0aW5nLXBvbmdcIik7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCIqXCIsIHtcbiAgICBSRUNPTk5FQ1Q6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgcmVzZXRTdWNjZXNzQ291bnRdXG4gICAgfSxcbiAgICBESVNDT05ORUNUOiBcIkBpZGxlLmluaXRpYWxcIlxuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQGlkbGUuKlwiLCByZXNldFN1Y2Nlc3NDb3VudCkuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS4qXCIsIHtcbiAgICBDT05ORUNUOiAoXywgY3R4KSA9PiAoXG4gICAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlIGEga25vd24gYXV0aFZhbHVlLCB0cnkgdG8gcmVjb25uZWN0IHRvIHRoZSBzb2NrZXQgZGlyZWN0bHksXG4gICAgICAvLyBvdGhlcndpc2UsIHRyeSB0byBvYnRhaW4gYSBuZXcgYXV0aFZhbHVlXG4gICAgICBjdHguYXV0aFZhbHVlICE9PSBudWxsID8gXCJAY29ubmVjdGluZy5idXN5XCIgOiBcIkBhdXRoLmJ1c3lcIlxuICAgIClcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAYXV0aC5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBhdXRoLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBhdXRoLmJ1c3lcIixcbiAgICAoKSA9PiB3aXRoVGltZW91dChcbiAgICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKSxcbiAgICAgIEFVVEhfVElNRU9VVCxcbiAgICAgIFwiVGltZWQgb3V0IGR1cmluZyBhdXRoXCJcbiAgICApLFxuICAgIC8vIE9uIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIGF1dGhWYWx1ZTogb2tFdmVudC5kYXRhXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIEF1dGggZmFpbGVkXG4gICAgKGZhaWxlZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheSxcbiAgICAgICAgICBsb2coXG4gICAgICAgICAgICAyIC8qIEVSUk9SICovLFxuICAgICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlIDogU3RyaW5nKGZhaWxlZEV2ZW50LnJlYXNvbil9YFxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IG9uU29ja2V0RXJyb3IgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0VSUk9SXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldENsb3NlID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRNZXNzYWdlID0gKGV2ZW50KSA9PiBldmVudC5kYXRhID09PSBcInBvbmdcIiA/IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUE9OR1wiIH0pIDogb25NZXNzYWdlLm5vdGlmeShldmVudCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duU29ja2V0KHNvY2tldCkge1xuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBjb25uZWN0aW5nLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vXG4gICAgLy8gVXNlIHRoZSBcImNyZWF0ZVNvY2tldFwiIGRlbGVnYXRlIGZ1bmN0aW9uIChwcm92aWRlZCB0byB0aGVcbiAgICAvLyBNYW5hZ2VkU29ja2V0KSB0byBjcmVhdGUgdGhlIGFjdHVhbCBXZWJTb2NrZXQgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICAvLyBUaGVuLCBzZXQgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLCBhbmQgd2FpdCBmb3IgdGhlXG4gICAgLy8gXCJvcGVuXCIgZXZlbnQgdG8gb2NjdXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBcIm9wZW5cIiBldmVudCBoYXBwZW5zLCB3ZSdyZSByZWFkeSB0byB0cmFuc2l0aW9uIHRvIHRoZVxuICAgIC8vIE9LIHN0YXRlLiBUaGlzIGlzIGRvbmUgYnkgcmVzb2x2aW5nIHRoZSBQcm9taXNlLlxuICAgIC8vXG4gICAgYXN5bmMgKGN0eCwgc2lnbmFsKSA9PiB7XG4gICAgICBsZXQgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IG51bGw7XG4gICAgICBsZXQgdW5jb25maXJtZWRTb2NrZXQgPSBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdCQgPSBuZXcgUHJvbWlzZShcbiAgICAgICAgKHJlc29sdmUsIHJlaikgPT4ge1xuICAgICAgICAgIGlmIChjdHguYXV0aFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIGF1dGhWYWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc29ja2V0ID0gZGVsZWdhdGVzLmNyZWF0ZVNvY2tldChjdHguYXV0aFZhbHVlKTtcbiAgICAgICAgICB1bmNvbmZpcm1lZFNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgICBmdW5jdGlvbiByZWplY3QoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgW2FjdG9yJCwgZGlkUmVjZWl2ZUFjdG9yXSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gd2FpdEZvckFjdG9ySWQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlck1zZyA9IHRyeVBhcnNlSnNvbihldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJNc2c/LnR5cGUgPT09IDEwNCAvKiBST09NX1NUQVRFICovKSB7XG4gICAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdm9pZCBhY3RvciQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoW3NvY2tldCwgdW5zdWJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHdpdGhUaW1lb3V0KFxuICAgICAgICBjb25uZWN0JCxcbiAgICAgICAgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCxcbiAgICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIHdlYnNvY2tldCBjb25uZWN0aW9uXCJcbiAgICAgICkudGhlbihcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFydCAzOlxuICAgICAgICAvLyBCeSBub3csIG91ciBcIm9wZW5cIiBldmVudCBoYXMgZmlyZWQsIGFuZCB0aGUgcHJvbWlzZSBoYXMgYmVlblxuICAgICAgICAvLyByZXNvbHZlZC4gVHdvIHBvc3NpYmxlIHNjZW5hcmlvczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gVGhlIGhhcHB5IHBhdGguIE1vc3QgbGlrZWx5LlxuICAgICAgICAvLyAyLiBVaC1vaC4gQSBwcmVtYXR1cmUgY2xvc2UvZXJyb3IgZXZlbnQgaGFzIGJlZW4gb2JzZXJ2ZWQuIExldCdzXG4gICAgICAgIC8vICAgIHJlamVjdCB0aGUgcHJvbWlzZSBhZnRlciBhbGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFueSBjbG9zZS9lcnJvciBldmVudCB0aGF0IHdpbGwgZ2V0IHNjaGVkdWxlZCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIG9ud2FyZHMsIHdpbGwgYmUgY2F1Z2h0IGluIHRoZSBPSyBzdGF0ZSwgYW5kIGRlYWx0IHdpdGhcbiAgICAgICAgLy8gYWNjb3JkaW5nbHkuXG4gICAgICAgIC8vXG4gICAgICAgIChbc29ja2V0LCB1bnN1Yl0pID0+IHtcbiAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJvcnRlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQpIHtcbiAgICAgICAgICAgIHRocm93IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQodW5jb25maXJtZWRTb2NrZXQpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBPbmx5IHRyYW5zaXRpb24gdG8gT0sgc3RhdGUgYWZ0ZXIgYSBzdWNjZXNzZnVsbHkgb3BlbmVkIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQG9rLmNvbm5lY3RlZFwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBzb2NrZXQ6IG9rRXZlbnQuZGF0YSxcbiAgICAgICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkXG4gICAgKGZhaWx1cmUpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGZhaWx1cmUucmVhc29uO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xvc2VFdmVudChlcnIpKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksXG4gICAgICAgICAgICAgIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycilcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5yZWFzb24pLFxuICAgICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIucmVhc29uLCBlcnIuY29kZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKV1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBzZW5kSGVhcnRiZWF0ID0ge1xuICAgIHRhcmdldDogXCJAb2suYXdhaXRpbmctcG9uZ1wiLFxuICAgIGVmZmVjdDogKGN0eCkgPT4ge1xuICAgICAgY3R4LnNvY2tldD8uc2VuZChcInBpbmdcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYXliZUhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCBjYW5ab21iaWUgPSBkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIiAmJiBkZWxlZ2F0ZXMuY2FuWm9tYmllKCk7XG4gICAgcmV0dXJuIGNhblpvbWJpZSA/IFwiQGlkbGUuem9tYmllXCIgOiBzZW5kSGVhcnRiZWF0O1xuICB9O1xuICBtYWNoaW5lLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5jb25uZWN0ZWRcIiwgSEVBUlRCRUFUX0lOVEVSVkFMLCBtYXliZUhlYXJ0YmVhdCkuYWRkVHJhbnNpdGlvbnMoXCJAb2suY29ubmVjdGVkXCIsIHtcbiAgICBOQVZJR0FUT1JfT0ZGTElORTogbWF5YmVIZWFydGJlYXQsXG4gICAgLy8gRG9uJ3QgdGFrZSB0aGUgYnJvd3NlcidzIHdvcmQgZm9yIGl0IHdoZW4gaXQgc2F5cyBpdCdzIG9mZmxpbmUuIERvIGEgcGluZy9wb25nIHRvIG1ha2Ugc3VyZS5cbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBzZW5kSGVhcnRiZWF0XG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuem9tYmllXCIsIHtcbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIlxuICAgIC8vIFdoZW4gaW4gem9tYmllIHN0YXRlLCB0aGUgY2xpZW50IHdpbGwgdHJ5IHRvIHdha2UgdXAgYXV0b21hdGljYWxseSB3aGVuIHRoZSB3aW5kb3cgcmVnYWlucyBmb2N1c1xuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQG9rLipcIiwgKGN0eCkgPT4ge1xuICAgIGN0eC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogY3R4LnN1Y2Nlc3NDb3VudCArIDEgfSk7XG4gICAgY29uc3QgdGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAvLyBPbiB0aGUgbmV4dCB0aWNrLCBzdGFydCBkZWxpdmVyaW5nIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYWxyZWFkeVxuICAgICAgLy8gYmVlbiByZWNlaXZlZCwgYW5kIGNvbnRpbnVlIHN5bmNocm9ub3VzIGRlbGl2ZXJ5IG9mIGFsbCBmdXR1cmVcbiAgICAgIC8vIGluY29taW5nIG1lc3NhZ2VzLlxuICAgICAgb25NZXNzYWdlLnVucGF1c2UsXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4gKGN0eDIpID0+IHtcbiAgICAgIHRlYXJkb3duU29ja2V0KGN0eDIuc29ja2V0KTtcbiAgICAgIGN0eDIucGF0Y2goeyBzb2NrZXQ6IG51bGwgfSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG4gICAgICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgICB9O1xuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5hd2FpdGluZy1wb25nXCIsIHsgUE9ORzogXCJAb2suY29ubmVjdGVkXCIgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgUE9OR19USU1FT1VULCB7XG4gICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvLyBMb2cgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzIGFuZCBkcm9wIHRoZSBjdXJyZW50IG9wZW4gc29ja2V0XG4gICAgZWZmZWN0OiBsb2coXG4gICAgICAxIC8qIFdBUk4gKi8sXG4gICAgICBcIlJlY2VpdmVkIG5vIHBvbmcgZnJvbSBzZXJ2ZXIsIGFzc3VtZSBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MuXCJcbiAgICApXG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLipcIiwge1xuICAgIC8vIFdoZW4gYSBzb2NrZXQgcmVjZWl2ZXMgYW4gZXJyb3IsIHRoaXMgY2FuIGNhdXNlIHRoZSBjbG9zaW5nIG9mIHRoZVxuICAgIC8vIHNvY2tldCwgb3Igbm90LiBTbyBhbHdheXMgY2hlY2sgdG8gc2VlIGlmIHRoZSBzb2NrZXQgaXMgc3RpbGwgT1BFTiBvclxuICAgIC8vIG5vdC4gV2hlbiBzdGlsbCBPUEVOLCBkb24ndCB0cmFuc2l0aW9uLlxuICAgIEVYUExJQ0lUX1NPQ0tFVF9FUlJPUjogKF8sIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChjb250ZXh0LnNvY2tldD8ucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogaW5jcmVhc2VCYWNrb2ZmRGVsYXlcbiAgICAgIH07XG4gICAgfSxcbiAgICBFWFBMSUNJVF9TT0NLRVRfQ0xPU0U6IChlKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nUGVybWFuZW50Q2xvc2UsXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlLmV2ZW50LnJlYXNvbiwgZS5ldmVudC5jb2RlKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICBpZiAoZS5ldmVudC5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICAgIGNvbnN0IHJvb3QgPSB3aW4gPz8gZG9jO1xuICAgIG1hY2hpbmUub25FbnRlcihcIipcIiwgKGN0eCkgPT4ge1xuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrT2ZmbGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT0ZGTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrQmFja09ubGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT05MSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIldJTkRPV19HT1RfRk9DVVNcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgIHJvb3Q/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByb290Py5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KGN0eC5zb2NrZXQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBjbGVhbnVwcyA9IFtdO1xuICBjb25zdCB7IHN0YXR1c0RpZENoYW5nZSwgZGlkQ29ubmVjdCwgZGlkRGlzY29ubmVjdCwgdW5zdWJzY3JpYmUgfSA9IGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKTtcbiAgY2xlYW51cHMucHVzaCh1bnN1YnNjcmliZSk7XG4gIGlmIChvcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZykge1xuICAgIGNsZWFudXBzLnB1c2goZW5hYmxlVHJhY2luZyhtYWNoaW5lKSk7XG4gIH1cbiAgbWFjaGluZS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIG1hY2hpbmUsXG4gICAgY2xlYW51cHMsXG4gICAgLy8gT2JzZXJ2YWJsZSBldmVudHMgdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhpcyBtYWNoaW5lXG4gICAgZXZlbnRzOiB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2UsXG4gICAgICBkaWRDb25uZWN0LFxuICAgICAgZGlkRGlzY29ubmVjdCxcbiAgICAgIG9uTWVzc2FnZTogb25NZXNzYWdlLm9ic2VydmFibGUsXG4gICAgICBvbkxpdmVibG9ja3NFcnJvcjogb25MaXZlYmxvY2tzRXJyb3Iub2JzZXJ2YWJsZVxuICAgIH1cbiAgfTtcbn1cbnZhciBNYW5hZ2VkU29ja2V0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy5tYWNoaW5lID0gbWFjaGluZTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmNsZWFudXBzID0gY2xlYW51cHM7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMubWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNoaW5lLmNvbnRleHQuYXV0aFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRyeSB0byBjb25uZWN0IHRvIGEgV2ViU29ja2V0LiBUaGlzIG9ubHkgaGFzIGFuIGVmZmVjdFxuICAgKiBpZiB0aGUgbWFjaGluZSBpcyBpZGxlIGF0IHRoZSBtb21lbnQsIG90aGVyd2lzZSB0aGlzIGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJESVNDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzdG9wIHRoZSBtYWNoaW5lIGFuZCBydW4gbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLiBBZnRlclxuICAgKiBjYWxsaW5nIGRlc3Ryb3koKSwgeW91IGNhbiBubyBsb25nZXIgdXNlIHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpcyBiZWZvcmVcbiAgICogbGV0dGluZyB0aGUgaW5zdGFuY2UgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy5jbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubWFjaGluZS5jb250ZXh0Py5zb2NrZXQ7XG4gICAgaWYgKHNvY2tldCA9PT0gbnVsbCkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBub3QgY29ubmVjdGVkIHlldFwiLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IFdlYlNvY2tldCBubyBsb25nZXIgb3BlblwiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOT1RFOiBVc2VkIGJ5IHRoZSBFMkUgYXBwIG9ubHksIHRvIHNpbXVsYXRlIGV4cGxpY2l0IGV2ZW50cy5cbiAgICogTm90IGlkZWFsIHRvIGtlZXAgZXhwb3NlZCA6KFxuICAgKi9cbiAgX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0aW9uLmNhbGxiYWNrKG9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIiwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gyLCBlbmRwb2ludCwgYm9keSkge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaDIoZW5kcG9pbnQsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICB9KTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICBjb25zdCByZWFzb24gPSBgJHsoYXdhaXQgcmVzLnRleHQoKSkudHJpbSgpIHx8IFwicmVhc29uIG5vdCBwcm92aWRlZCBpbiBhdXRoIHJlc3BvbnNlXCJ9ICgke3Jlcy5zdGF0dXN9IHJldHVybmVkIGJ5IFBPU1QgJHtlbmRwb2ludH0pYDtcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxIHx8IHJlcy5zdGF0dXMgPT09IDQwMykge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhgVW5hdXRob3JpemVkOiAke3JlYXNvbn1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXV0aGVudGljYXRlOiAke3JlYXNvbn1gKTtcbiAgICB9XG4gIH1cbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIi4gJHtTdHJpbmcoXG4gICAgICAgIGVyXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSB8fCB0eXBlb2YgZGF0YS50b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugb2YgdGhlIGZvcm0gXFxgeyB0b2tlbjogXCIuLi5cIiB9XFxgIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGRhdGFcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgY29uc3QgeyB0b2tlbiB9ID0gZGF0YTtcbiAgcmV0dXJuIHsgdG9rZW4gfTtcbn1cblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxpdmVibG9ja3MuaW9cIjtcblxuLy8gc3JjL2ludGVybmFsLnRzXG52YXIga0ludGVybmFsID0gU3ltYm9sKCk7XG5cbi8vIHNyYy9kZXZ0b29scy9icmlkZ2UudHNcbnZhciBfYnJpZGdlQWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBhY3RpdmF0ZUJyaWRnZShhbGxvd2VkKSB7XG4gIF9icmlkZ2VBY3RpdmUgPSBhbGxvd2VkO1xufVxuZnVuY3Rpb24gc2VuZFRvUGFuZWwobWVzc2FnZSwgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZnVsbE1zZyA9IHtcbiAgICAuLi5tZXNzYWdlLFxuICAgIHNvdXJjZTogXCJsaXZlYmxvY2tzLWRldnRvb2xzLWNsaWVudFwiXG4gIH07XG4gIGlmICghKG9wdGlvbnM/LmZvcmNlIHx8IF9icmlkZ2VBY3RpdmUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5wb3N0TWVzc2FnZShmdWxsTXNnLCBcIipcIik7XG59XG52YXIgZXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2ZW50LmRhdGE/LnNvdXJjZSA9PT0gXCJsaXZlYmxvY2tzLWRldnRvb2xzLXBhbmVsXCIpIHtcbiAgICAgIGV2ZW50U291cmNlLm5vdGlmeShldmVudC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgIH1cbiAgfSk7XG59XG52YXIgb25NZXNzYWdlRnJvbVBhbmVsID0gZXZlbnRTb3VyY2Uub2JzZXJ2YWJsZTtcblxuLy8gc3JjL2RldnRvb2xzL2luZGV4LnRzXG52YXIgVkVSU0lPTiA9IFBLR19WRVJTSU9OIHx8IFwiZGV2XCI7XG52YXIgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwRGV2VG9vbHMoZ2V0QWxsUm9vbXMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChfZGV2dG9vbHNTZXR1cEhhc1J1bikge1xuICAgIHJldHVybjtcbiAgfVxuICBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IHRydWU7XG4gIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgY2FzZSBcImNvbm5lY3RcIjoge1xuICAgICAgICBhY3RpdmF0ZUJyaWRnZSh0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCByb29tSWQgb2YgZ2V0QWxsUm9vbXMoKSkge1xuICAgICAgICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgICAgICAgIG1zZzogXCJyb29tOjphdmFpbGFibGVcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IFZFUlNJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJ3YWtlLXVwLWRldnRvb2xzXCIgfSwgeyBmb3JjZTogdHJ1ZSB9KTtcbn1cbnZhciB1bnN1YnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wU3luY1N0cmVhbShyb29tSWQpIHtcbiAgY29uc3QgdW5zdWJzID0gdW5zdWJzQnlSb29tSWQuZ2V0KHJvb21JZCkgPz8gW107XG4gIHVuc3Vic0J5Um9vbUlkLmRlbGV0ZShyb29tSWQpO1xuICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgIHVuc3ViKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0U3luY1N0cmVhbShyb29tKSB7XG4gIHN0b3BTeW5jU3RyZWFtKHJvb20uaWQpO1xuICBmdWxsU3luYyhyb29tKTtcbiAgdW5zdWJzQnlSb29tSWQuc2V0KHJvb20uaWQsIFtcbiAgICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkpLFxuICAgIC8vIFdoZW4gc3RvcmFnZSBpbml0aWFsaXplcywgc2VuZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHN0b3JhZ2UgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHN0b3JhZ2Ugcm9vdFxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBcIm1lXCIgb3IgXCJvdGhlcnNcIiB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgdmFsdWVzIGFjY29yZGluZ2x5XG4gICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNNZShyb29tKSksXG4gICAgcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY090aGVycyhyb29tKSksXG4gICAgLy8gQW55IHRpbWUgeWRvYyBpcyB1cGRhdGVkLCBmb3J3YXJkIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgodXBkYXRlKSA9PiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpKSxcbiAgICAvLyBBbnkgdGltZSBhIGN1c3RvbSByb29tIGV2ZW50IGlzIHJlY2VpdmVkLCBmb3J3YXJkIGl0XG4gICAgcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50RGF0YSkgPT4gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSlcbiAgICApXG4gIF0pO1xufVxuZnVuY3Rpb24gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6eWRvY1wiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICB1cGRhdGVcbiAgfSk7XG59XG52YXIgbG9hZGVkQXQgPSBEYXRlLm5vdygpO1xudmFyIGV2ZW50Q291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGBldmVudC0ke2xvYWRlZEF0fS0ke2V2ZW50Q291bnRlcisrfWA7XG59XG5mdW5jdGlvbiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6ZXZlbnRzOjpjdXN0b20tZXZlbnRcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXZlbnRcIixcbiAgICAgIGlkOiBuZXh0RXZlbnRJZCgpLFxuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBjb25uZWN0aW9uSWQ6IGV2ZW50RGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICBwYXlsb2FkOiBldmVudERhdGEuZXZlbnRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBpZiAocm9vdCkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBzdG9yYWdlOiByb290LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNNZShyb29tKSB7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG1lKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG1lXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pIHtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICBpZiAob3RoZXJzKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG90aGVyc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmdWxsU3luYyhyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgcm9vbS5mZXRjaFlEb2MoXCJcIik7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6ZnVsbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKCksXG4gICAgc3RvcmFnZTogcm9vdD8udG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZCA/PyBudWxsLFxuICAgIG1lLFxuICAgIG90aGVyc1xuICB9KTtcbn1cbnZhciByb29tQ2hhbm5lbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSByb29tQ2hhbm5lbExpc3RlbmVycy5nZXQocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZGVsZXRlKHJvb21JZCk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmtEZXZUb29scyhyb29tSWQsIHJvb20pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLCByb29tSWQsIGNsaWVudFZlcnNpb246IFZFUlNJT04gfSk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLnNldChcbiAgICByb29tSWQsXG4gICAgLy8gUmV0dXJucyB0aGUgdW5zdWJzY3JpYmUgY2FsbGJhY2ssIHRoYXQgd2Ugc3RvcmUgaW4gdGhlXG4gICAgLy8gcm9vbUNoYW5uZWxMaXN0ZW5lcnMgcmVnaXN0cnlcbiAgICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgICBjYXNlIFwicm9vbTo6c3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdGFydFN5bmNTdHJlYW0ocm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyb29tOjp1bnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdW5saW5rRGV2VG9vbHMocm9vbUlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnVuYXZhaWxhYmxlXCIsXG4gICAgcm9vbUlkXG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncyk7XG4gIH1cbiAgY29uc3Qgc29ydGVkT2JqZWN0ID0gT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCkucmVkdWNlKFxuICAgIChzb3J0ZWRPYmplY3QyLCBrZXkpID0+IHtcbiAgICAgIHNvcnRlZE9iamVjdDJba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIHNvcnRlZE9iamVjdDI7XG4gICAgfSxcbiAgICB7fVxuICApO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc29ydGVkT2JqZWN0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL2xpYi9iYXRjaC50c1xudmFyIERFRkFVTFRfU0laRSA9IDUwO1xudmFyIEJhdGNoQ2FsbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IFByb21pc2Vfd2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgfVxufTtcbnZhciBCYXRjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemUgPz8gREVGQVVMVF9TSVpFO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG4gIGNsZWFyRGVsYXlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLmRlbGF5VGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNjaGVkdWxlKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gdGhpcy5zaXplKSB7XG4gICAgICB2b2lkIHRoaXMuZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmNsZWFyRGVsYXlUaW1lb3V0KCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuZmx1c2goKSwgdGhpcy5kZWxheSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWxscyA9IHRoaXMucXVldWUuc3BsaWNlKDApO1xuICAgIGNvbnN0IGlucHV0cyA9IGNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5pbnB1dCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmNhbGxiYWNrKGlucHV0cyk7XG4gICAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzPy5baW5kZXhdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChuZXcgRXJyb3IoXCJDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheS5cIikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGxzLmxlbmd0aCAhPT0gcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIHByb3ZpZGVkIGl0ZW1zLiBFeHBlY3RlZCAke2NhbGxzLmxlbmd0aH0sIGJ1dCBnb3QgJHtyZXN1bHRzLmxlbmd0aH0uYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGwucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSB0cnVlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgICAgICBjYWxsLnJlamVjdChlcnJvcjMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldChpbnB1dCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2FsbCA9IHRoaXMucXVldWUuZmluZChcbiAgICAgIChjYWxsMikgPT4gc3RyaW5naWZ5KGNhbGwyLmlucHV0KSA9PT0gc3RyaW5naWZ5KGlucHV0KVxuICAgICk7XG4gICAgaWYgKGV4aXN0aW5nQ2FsbCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FsbC5wcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBjYWxsID0gbmV3IEJhdGNoQ2FsbChpbnB1dCk7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGNhbGwpO1xuICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICByZXR1cm4gY2FsbC5wcm9taXNlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZW91dCgpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaCkge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV2ZW50U291cmNlMiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRDYWNoZUtleShhcmdzKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHN0YXRlKTtcbiAgICBldmVudFNvdXJjZTIubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0KGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoLmdldChpbnB1dCk7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiByZXN1bHQgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMi5vYnNlcnZhYmxlLFxuICAgIGdldCxcbiAgICBnZXRTdGF0ZVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2NyZWF0ZS1zdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gIGxldCBub3RpZnlJbW1lZGlhdGVseSA9IHRydWU7XG4gIGxldCBkaXJ0eSA9IGZhbHNlO1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHN0YXRlO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY2FsbGJhY2sob2xkU3RhdGUpO1xuICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBkaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChub3RpZnlJbW1lZGlhdGVseSkge1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBpZiAoIWRpcnR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2IpIHtcbiAgICBpZiAobm90aWZ5SW1tZWRpYXRlbHkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG4gICAgbm90aWZ5SW1tZWRpYXRlbHkgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbm90aWZ5SW1tZWRpYXRlbHkgPSB0cnVlO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgYmF0Y2gsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgdXBkYXRlZEF0ID0gZGF0YS51cGRhdGVkQXQgPyBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgY29tbWVudHMgPSBkYXRhLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdCxcbiAgICB1cGRhdGVkQXQsXG4gICAgY29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24oZGF0YSkge1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShkYXRhKSB7XG4gIGNvbnN0IG5vdGlmaWVkQXQgPSBuZXcgRGF0ZShkYXRhLm5vdGlmaWVkQXQpO1xuICBjb25zdCByZWFkQXQgPSBkYXRhLnJlYWRBdCA/IG5ldyBEYXRlKGRhdGEucmVhZEF0KSA6IG51bGw7XG4gIGlmIChcImFjdGl2aXRpZXNcIiBpbiBkYXRhKSB7XG4gICAgY29uc3QgYWN0aXZpdGllcyA9IGRhdGEuYWN0aXZpdGllcy5tYXAoKGFjdGl2aXR5KSA9PiAoe1xuICAgICAgLi4uYWN0aXZpdHksXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGFjdGl2aXR5LmNyZWF0ZWRBdClcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBub3RpZmllZEF0LFxuICAgICAgcmVhZEF0LFxuICAgICAgYWN0aXZpdGllc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIG5vdGlmaWVkQXQsXG4gICAgcmVhZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cblxuLy8gc3JjL2h0dHAtY2xpZW50LnRzXG5mdW5jdGlvbiBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG5cbi8vIHNyYy9saWIvdXJsLnRzXG5mdW5jdGlvbiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVybGpvaW4oYmFzZVVybCwgcGF0aCwgcGFyYW1zKSB7XG4gIGNvbnN0IHVybDIgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwyLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwyLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBzdHJpbmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBzdHIsIGkpID0+IHJlc3VsdCArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaSAtIDFdID8/IFwiXCIpICsgc3RyXG4gICk7XG59XG5cbi8vIHNyYy9ub3RpZmljYXRpb25zLnRzXG5mdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25zQXBpKHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGN1cnJlbnRVc2VySWRTdG9yZSxcbiAgZmV0Y2hlclxufSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGlmICghZW5kcG9pbnQuc3RhcnRzV2l0aChcIi92Mi9jL1wiKSkge1xuICAgICAgcmFpc2UoXCJFeHBlY3RlZCBhIC92Mi9jLyogZW5kcG9pbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCJcbiAgICB9KTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIgJiYgYXV0aFZhbHVlLnRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgY29uc3QgdXNlcklkID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZC51aWQ7XG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuc2V0KCgpID0+IHVzZXJJZCk7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKGJhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hlcih1cmwyLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gLFxuICAgICAgICBcIlgtTEItQ2xpZW50XCI6IFBLR19WRVJTSU9OIHx8IFwiZGV2XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9uc2AsIHZvaWQgMCwge1xuICAgICAgY3Vyc29yOiBvcHRpb25zPy5jdXJzb3IsXG4gICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGFcbiAgICAgICksXG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgbmV4dEN1cnNvcjoganNvbi5tZXRhLm5leHRDdXJzb3IsXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2Uoc2luY2UpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hKc29uKHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2RlbHRhYCwgdm9pZCAwLCB7XG4gICAgICBzaW5jZTogc2luY2UudG9JU09TdHJpbmcoKVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB0aHJlYWRzOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KCkge1xuICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9jb3VudGApO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICAgIGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzOiBcImFsbFwiIH0pXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24odXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnNgLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zLyR7aW5ib3hOb3RpZmljYXRpb25JZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvdGhyZWFkc2AsIHZvaWQgMCwge1xuICAgICAgY3Vyc29yOiBvcHRpb25zLmN1cnNvcixcbiAgICAgIHF1ZXJ5LFxuICAgICAgbGltaXQ6IFBBR0VfU0laRVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hKc29uKHVybGAvdjIvYy90aHJlYWRzYCwgdm9pZCAwLCB7XG4gICAgICBzaW5jZTogb3B0aW9ucy5zaW5jZS50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2UsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uLFxuICAgIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICBnZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3Bvc2l0aW9uLnRzXG52YXIgTUlOX0NPREUgPSAzMjtcbnZhciBNQVhfQ09ERSA9IDEyNjtcbnZhciBOVU1fRElHSVRTID0gTUFYX0NPREUgLSBNSU5fQ09ERSArIDE7XG52YXIgWkVSTyA9IG50aERpZ2l0KDApO1xudmFyIE9ORSA9IG50aERpZ2l0KDEpO1xudmFyIFpFUk9fTklORSA9IFpFUk8gKyBudGhEaWdpdCgtMSk7XG5mdW5jdGlvbiBudGhEaWdpdChuKSB7XG4gIGNvbnN0IGNvZGUgPSBNSU5fQ09ERSArIChuIDwgMCA/IE5VTV9ESUdJVFMgKyBuIDogbik7XG4gIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG4gdmFsdWU6ICR7bn1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQb3NpdGlvbih4LCB5KSB7XG4gIGlmICh4ICE9PSB2b2lkIDAgJiYgeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJldHdlZW4oeCwgeSk7XG4gIH0gZWxzZSBpZiAoeCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGFmdGVyKHgpO1xuICB9IGVsc2UgaWYgKHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZWZvcmUoeSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9ORTtcbiAgfVxufVxuZnVuY3Rpb24gYmVmb3JlKHBvcykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwb3MubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPD0gTUlOX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICBpZiAoY29kZSA9PT0gTUlOX0NPREUgKyAxKSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgWkVST19OSU5FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT05FO1xufVxuZnVuY3Rpb24gYWZ0ZXIocG9zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gTUFYX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDEpO1xuICB9XG4gIHJldHVybiBwb3MgKyBPTkU7XG59XG5mdW5jdGlvbiBiZXR3ZWVuKGxvLCBoaSkge1xuICBpZiAobG8gPCBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihsbywgaGkpO1xuICB9IGVsc2UgaWYgKGxvID4gaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4oaGksIGxvKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB2YWx1ZSBiZXR3ZWVuIHR3byBlcXVhbCBwb3NpdGlvbnNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9iZXR3ZWVuKGxvLCBoaSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsb0xlbiA9IGxvLmxlbmd0aDtcbiAgY29uc3QgaGlMZW4gPSBoaS5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbG9Db2RlID0gaW5kZXggPCBsb0xlbiA/IGxvLmNoYXJDb2RlQXQoaW5kZXgpIDogTUlOX0NPREU7XG4gICAgY29uc3QgaGlDb2RlID0gaW5kZXggPCBoaUxlbiA/IGhpLmNoYXJDb2RlQXQoaW5kZXgpIDogTUFYX0NPREU7XG4gICAgaWYgKGxvQ29kZSA9PT0gaGlDb2RlKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoaUNvZGUgLSBsb0NvZGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpbmRleCArIDE7XG4gICAgICBsZXQgcHJlZml4ID0gbG8uc3Vic3RyaW5nKDAsIHNpemUpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHByZWZpeCArPSBaRVJPLnJlcGVhdChzaXplIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBsby5zdWJzdHJpbmcoc2l6ZSk7XG4gICAgICBjb25zdCBuaW5lcyA9IFwiXCI7XG4gICAgICByZXR1cm4gcHJlZml4ICsgX2JldHdlZW4oc3VmZml4LCBuaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWtlTihsbywgaW5kZXgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShoaUNvZGUgKyBsb0NvZGUgPj4gMSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0YWtlTihwb3MsIG4pIHtcbiAgcmV0dXJuIG4gPCBwb3MubGVuZ3RoID8gcG9zLnN1YnN0cmluZygwLCBuKSA6IHBvcyArIFpFUk8ucmVwZWF0KG4gLSBwb3MubGVuZ3RoKTtcbn1cbnZhciBNSU5fTk9OX1pFUk9fQ09ERSA9IE1JTl9DT0RFICsgMTtcbmZ1bmN0aW9uIGlzUG9zKHN0cikge1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RJZHggPSBzdHIubGVuZ3RoIC0gMTtcbiAgY29uc3QgbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJZHgpO1xuICBpZiAobGFzdCA8IE1JTl9OT05fWkVST19DT0RFIHx8IGxhc3QgPiBNQVhfQ09ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1BvcyhzdHIpIHtcbiAgY29uc3QgY29kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZXMucHVzaChjb2RlIDwgTUlOX0NPREUgPyBNSU5fQ09ERSA6IGNvZGUgPiBNQVhfQ09ERSA/IE1BWF9DT0RFIDogY29kZSk7XG4gIH1cbiAgd2hpbGUgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPT09IE1JTl9DT0RFKSB7XG4gICAgY29kZXMubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIGNvZGVzLmxlbmd0aCA+IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvZGVzKSA6IChcbiAgICAvLyBFZGdlIGNhc2U6IHRoZSBzdHIgd2FzIGEgMC1vbmx5IHN0cmluZywgd2hpY2ggaXMgaW52YWxpZC4gRGVmYXVsdCBiYWNrIHRvIC4xXG4gICAgT05FXG4gICk7XG59XG5mdW5jdGlvbiBhc1BvcyhzdHIpIHtcbiAgcmV0dXJuIGlzUG9zKHN0cikgPyBzdHIgOiBjb252ZXJ0VG9Qb3Moc3RyKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL09wLnRzXG52YXIgT3BDb2RlID0gLyogQF9fUFVSRV9fICovICgoT3BDb2RlMikgPT4ge1xuICBPcENvZGUyW09wQ29kZTJbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiU0VUX1BBUkVOVF9LRVlcIl0gPSAxXSA9IFwiU0VUX1BBUkVOVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX0xJU1RcIl0gPSAyXSA9IFwiQ1JFQVRFX0xJU1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiVVBEQVRFX09CSkVDVFwiXSA9IDNdID0gXCJVUERBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9PQkpFQ1RcIl0gPSA0XSA9IFwiQ1JFQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfQ1JEVFwiXSA9IDVdID0gXCJERUxFVEVfQ1JEVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfT0JKRUNUX0tFWVwiXSA9IDZdID0gXCJERUxFVEVfT0JKRUNUX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTUFQXCJdID0gN10gPSBcIkNSRUFURV9NQVBcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX1JFR0lTVEVSXCJdID0gOF0gPSBcIkNSRUFURV9SRUdJU1RFUlwiO1xuICByZXR1cm4gT3BDb2RlMjtcbn0pKE9wQ29kZSB8fCB7fSk7XG5mdW5jdGlvbiBhY2tPcChvcElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICBpZDogXCJBQ0tcIixcbiAgICAvLyAoSClBQ0tcbiAgICBvcElkXG4gIH07XG59XG5mdW5jdGlvbiBpc0Fja09wKG9wKSB7XG4gIHJldHVybiBvcC50eXBlID09PSA1IC8qIERFTEVURV9DUkRUICovICYmIG9wLmlkID09PSBcIkFDS1wiO1xufVxuXG4vLyBzcmMvY3JkdHMvQWJzdHJhY3RDcmR0LnRzXG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sID8gdGhpcy5fX3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9faWQgfHwgdGhpcy5fX3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy5fX2lkID0gaWQ7XG4gICAgdGhpcy5fX3Bvb2wgPSBwb29sO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBpZiAodGhpcy5fX3Bvb2wgJiYgdGhpcy5fX2lkKSB7XG4gICAgICB0aGlzLl9fcG9vbC5kZWxldGVOb2RlKHRoaXMuX19pZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX19wb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQ2xlYXIgdGhlIEltbXV0YWJsZSBjYWNoZSwgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHRvIGAudG9JbW11dGFibGUoKWAgd2lsbFxuICAgKiByZWNvbXB1dGUgdGhlIGVxdWl2YWxlbnQgSW1tdXRhYmxlIHZhbHVlIGFnYWluLiAgQ2FsbCB0aGlzIGFmdGVyIGV2ZXJ5XG4gICAqIG11dGF0aW9uIHRvIHRoZSBMaXZlIG5vZGUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgIT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybiBhbiBzbmFwc2hvdCBvZiB0aGlzIExpdmUgdHJlZSBmb3IgdXNlIGluIERldlRvb2xzLlxuICAgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVHJlZU5vZGUgPT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSA9IGtleTtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdGhpcy5fdG9UcmVlTm9kZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbW11dGFibGUgc25hcHNob3Qgb2YgdGhpcyBMaXZlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdGhpcy5fdG9JbW11dGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEltbXV0YWJsZTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1NlcmlhbGl6ZWRDcmR0LnRzXG52YXIgQ3JkdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDcmR0VHlwZTIpID0+IHtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk9CSkVDVFwiXSA9IDBdID0gXCJPQkpFQ1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIkxJU1RcIl0gPSAxXSA9IFwiTElTVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTUFQXCJdID0gMl0gPSBcIk1BUFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiUkVHSVNURVJcIl0gPSAzXSA9IFwiUkVHSVNURVJcIjtcbiAgcmV0dXJuIENyZHRUeXBlMjtcbn0pKENyZHRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzUm9vdENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLyAmJiAhaXNDaGlsZENyZHQoY3JkdCk7XG59XG5mdW5jdGlvbiBpc0NoaWxkQ3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnBhcmVudElkICE9PSB2b2lkIDAgJiYgY3JkdC5wYXJlbnRLZXkgIT09IHZvaWQgMDtcbn1cblxuLy8gc3JjL2xpYi9uYW5vaWQudHNcbnZhciBuYW5vaWQgPSAodCA9IDIxKSA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHQpKS5yZWR1Y2UoXG4gICh0MiwgZSkgPT4gdDIgKz0gKGUgJj0gNjMpIDwgMzYgPyBlLnRvU3RyaW5nKDM2KSA6IGUgPCA2MiA/IChlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpIDogZSA8IDYzID8gXCJfXCIgOiBcIi1cIixcbiAgXCJcIlxuKTtcblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLl9pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdChbXSk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0Ll9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IEpTT04uc3RyaW5naWZ5KGNyZHQuZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvYXV0b1JldHJ5LnRzXG5hc3luYyBmdW5jdGlvbiBhdXRvUmV0cnkocHJvbWlzZUZuLCBtYXhUcmllcywgYmFja29mZiwgdGhyb3dFcnJvcikge1xuICBjb25zdCBmYWxsYmFja0JhY2tvZmYgPSBiYWNrb2ZmLmxlbmd0aCA+IDAgPyBiYWNrb2ZmW2JhY2tvZmYubGVuZ3RoIC0gMV0gOiAwO1xuICBsZXQgYXR0ZW1wdCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYXR0ZW1wdCsrO1xuICAgIGNvbnN0IHByb21pc2UgPSBwcm9taXNlRm4oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhyb3dFcnJvcj8uKGVycikgfHwgZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nMikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ZW1wdCA+PSBtYXhUcmllcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCBhZnRlciAke21heFRyaWVzfSBhdHRlbXB0czogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBiYWNrb2ZmW2F0dGVtcHQgLSAxXSA/PyBmYWxsYmFja0JhY2tvZmY7XG4gICAgd2FybihcbiAgICAgIGBBdHRlbXB0ICR7YXR0ZW1wdH0gd2FzIHVuc3VjY2Vzc2Z1bC4gUmV0cnlpbmcgaW4gJHtkZWxheX0gbWlsbGlzZWNvbmRzLmBcbiAgICApO1xuICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICB9XG59XG52YXIgU3RvcFJldHJ5aW5nMiA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2NodW5rLnRzXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8vIHNyYy9saWIvY3JlYXRlSWRzLnRzXG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBDT01NRU5UX0FUVEFDSE1FTlRfSURfUFJFRklYID0gXCJhdFwiO1xudmFyIElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVggPSBcImluXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvbGliL2RlYnVnLnRzXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShtc2csIHRyYWNlUm9vdCkge1xuICBjb25zdCBlcnJvckxpa2UgPSB7IG5hbWU6IG1zZyB9O1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yTGlrZSwgdHJhY2VSb290KTtcbiAgcmV0dXJuIGVycm9yTGlrZS5zdGFjaztcbn1cblxuLy8gc3JjL2xpYi9Kc29uLnRzXG5mdW5jdGlvbiBpc0pzb25TY2FsYXIoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0pzb25BcnJheShkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuICFpc0pzb25TY2FsYXIoZGF0YSkgJiYgIWlzSnNvbkFycmF5KGRhdGEpO1xufVxuXG4vLyBzcmMvbGliL29iamVjdFRvUXVlcnkudHNcbnZhciBpZGVudGlmaWVyUmVnZXggPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmZ1bmN0aW9uIG9iamVjdFRvUXVlcnkob2JqKSB7XG4gIGxldCBmaWx0ZXJMaXN0ID0gW107XG4gIGNvbnN0IGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IFtdO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gIGNvbnN0IGluZGV4ZWRLZXlzID0gW107XG4gIGVudHJpZXMyLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghaWRlbnRpZmllclJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IG11c3Qgb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIF9cIik7XG4gICAgfVxuICAgIGlmIChpc1NpbXBsZVZhbHVlKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbHVlV2l0aE9wZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIShcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSkpIHtcbiAgICAgIGluZGV4ZWRLZXlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gIH0pO1xuICBmaWx0ZXJMaXN0ID0gW1xuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhrZXlWYWx1ZVBhaXJzKSxcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3Ioa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgXTtcbiAgaW5kZXhlZEtleXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmVzdGVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlycyA9IFtdO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gICAgbmVzdGVkRW50cmllcy5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChpc1N0cmluZ0VtcHR5KG5lc3RlZEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NpbXBsZVZhbHVlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlycy5wdXNoKFtmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLCBuZXN0ZWRWYWx1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlV2l0aE9wZXJhdG9yKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtcbiAgICAgICAgICBmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLFxuICAgICAgICAgIG5lc3RlZFZhbHVlXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZpbHRlckxpc3QgPSBbXG4gICAgICAuLi5maWx0ZXJMaXN0LFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzKG5LZXlWYWx1ZVBhaXJzKSxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcihuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgICBdO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlckxpc3QubWFwKFxuICAgICh7IGtleSwgb3BlcmF0b3IsIHZhbHVlIH0pID0+IGZvcm1hdEZpbHRlcihrZXksIG9wZXJhdG9yLCBmb3JtYXRGaWx0ZXJWYWx1ZSh2YWx1ZSkpXG4gICkuam9pbihcIiBBTkQgXCIpO1xufVxudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyA9IChrZXlWYWx1ZVBhaXJzKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlycy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAga2V5LFxuICAgICAgb3BlcmF0b3I6IFwiOlwiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJzO1xufTtcbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSAoa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcikgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKFwic3RhcnRzV2l0aFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdGFydHNXaXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIG9wZXJhdG9yOiBcIl5cIixcbiAgICAgICAgdmFsdWU6IHZhbHVlLnN0YXJ0c1dpdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJzO1xufTtcbnZhciBpc1NpbXBsZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzVmFsdWVXaXRoT3BlcmF0b3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgZm9ybWF0RmlsdGVyID0gKGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gIHJldHVybiBgJHtrZXl9JHtvcGVyYXRvcn0ke3ZhbHVlfWA7XG59O1xudmFyIGZvcm1hdEZpbHRlcktleSA9IChrZXksIG5lc3RlZEtleSkgPT4ge1xuICBpZiAobmVzdGVkS2V5KSB7XG4gICAgcmV0dXJuIGAke2tleX1bJHtKU09OLnN0cmluZ2lmeShuZXN0ZWRLZXkpfV1gO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xudmFyIGZvcm1hdEZpbHRlclZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNTdHJpbmdFbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn07XG52YXIgaXNTdHJpbmdFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSBcIlwiO1xufTtcblxuLy8gc3JjL3Byb3RvY29sL0NsaWVudE1zZy50c1xudmFyIENsaWVudE1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChDbGllbnRNc2dDb2RlMikgPT4ge1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkJST0FEQ0FTVF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVF9FVkVOVFwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1NUT1JBR0VcIl0gPSAyMDBdID0gXCJGRVRDSF9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1lET0NcIl0gPSAzMDBdID0gXCJGRVRDSF9ZRE9DXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDFdID0gXCJVUERBVEVfWURPQ1wiO1xuICByZXR1cm4gQ2xpZW50TXNnQ29kZTI7XG59KShDbGllbnRNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3JlZnMvSW1tdXRhYmxlUmVmLnRzXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGNvbnN0IG5ld1ZhbHVlID0geyAuLi50YXJnZXQgfTtcbiAgT2JqZWN0LmtleXMocGF0Y2gpLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGNvbnN0IHZhbCA9IHBhdGNoW2tleV07XG4gICAgaWYgKG5ld1ZhbHVlW2tleV0gIT09IHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdWYWx1ZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWVba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1cGRhdGVkID8gbmV3VmFsdWUgOiB0YXJnZXQ7XG59XG52YXIgSW1tdXRhYmxlUmVmID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ldiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICB9XG4gIGdldCBkaWRJbnZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9ldi5vYnNlcnZhYmxlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fZXYubm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZSA/PyAodGhpcy5fY2FjaGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpKTtcbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvT3RoZXJzUmVmLnRzXG5mdW5jdGlvbiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSkge1xuICBjb25zdCB7IGNvbm5lY3Rpb25JZCwgaWQsIGluZm8gfSA9IGNvbm47XG4gIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGNvbm4uc2NvcGVzKTtcbiAgcmV0dXJuIGZyZWV6ZShcbiAgICBjb21wYWN0T2JqZWN0KHtcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGlkLFxuICAgICAgaW5mbyxcbiAgICAgIGNhbldyaXRlLFxuICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChjb25uLnNjb3BlcyksXG4gICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGUsXG4gICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICBwcmVzZW5jZVxuICAgIH0pXG4gICk7XG59XG52YXIgT3RoZXJzUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgdXNlcnMgPSBjb21wYWN0KFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9wcmVzZW5jZXMua2V5cygpKS5tYXAoXG4gICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB1c2VycztcbiAgfVxuICBjbGVhck90aGVycygpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbm4gIT09IHZvaWQgMCAmJiBwcmVzZW5jZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY2FjaGVkVXNlciA9IHRoaXMuX3VzZXJzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjYWNoZWRVc2VyKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVXNlcjtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRVc2VyID0gdGhpcy5fZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuX3VzZXJzLnNldChjb25uZWN0aW9uSWQsIGNvbXB1dGVkVXNlcik7XG4gICAgICByZXR1cm4gY29tcHV0ZWRVc2VyO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGlmICh0aGlzLl91c2Vycy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5fdXNlcnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGZyZWV6ZSh7XG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgaWQ6IG1ldGFVc2VySWQsXG4gICAgICAgIGluZm86IG1ldGFVc2VySW5mbyxcbiAgICAgICAgc2NvcGVzXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMuX3ByZXNlbmNlcy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX3ByZXNlbmNlcy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZXMgYSBuZXcgdXNlciBmcm9tIGEgZnVsbCBwcmVzZW5jZSB1cGRhdGUuIElmIHRoZSB1c2VyIGFscmVhZHkgZXhpc3RzLFxuICAgKiBpdHMga25vd24gcHJlc2VuY2UgZGF0YSBpcyBvdmVyd3JpdHRlbi5cbiAgICovXG4gIHNldE90aGVyKGNvbm5lY3Rpb25JZCwgcHJlc2VuY2UpIHtcbiAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKGNvbXBhY3RPYmplY3QocHJlc2VuY2UpKSk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25zLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIGNvbnN0IG9sZFByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChvbGRQcmVzZW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ByZXNlbmNlID0gbWVyZ2Uob2xkUHJlc2VuY2UsIHBhdGNoKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgIT09IG5ld1ByZXNlbmNlKSB7XG4gICAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvUGF0Y2hhYmxlUmVmLnRzXG52YXIgUGF0Y2hhYmxlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZnJlZXplKGNvbXBhY3RPYmplY3QoZGF0YSkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICovXG4gIHBhdGNoKHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgbmV3RGF0YSA9IG1lcmdlKG9sZERhdGEsIHBhdGNoKTtcbiAgICBpZiAob2xkRGF0YSAhPT0gbmV3RGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShuZXdEYXRhKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvVmFsdWVSZWYudHNcbnZhciBWYWx1ZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShpbml0aWFsVmFsdWUpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShuZXdWYWx1ZSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbn07XG52YXIgRGVyaXZlZFJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtRm4gPSBhcmdzLnBvcCgpO1xuICAgIGNvbnN0IG90aGVyUmVmcyA9IGFyZ3M7XG4gICAgdGhpcy5fcmVmcyA9IG90aGVyUmVmcztcbiAgICB0aGlzLl9yZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgcmVmLmRpZEludmFsaWRhdGUuc3Vic2NyaWJlKCgpID0+IHRoaXMuaW52YWxpZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1GbjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKFxuICAgICAgLi4udGhpcy5fcmVmcy5tYXAoKHJlZikgPT4gcmVmLmN1cnJlbnQpXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3Jvb20udHNcbnZhciBNQVhfU09DS0VUX01FU1NBR0VfU0laRSA9IDEwMjQgKiAxMDI0IC0gMTAyNDtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxudmFyIEdFVF9BVFRBQ0hNRU5UX1VSTFNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBBVFRBQ0hNRU5UX1BBUlRfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcbnZhciBBVFRBQ0hNRU5UX1BBUlRfQkFUQ0hfU0laRSA9IDU7XG52YXIgUkVUUllfQVRURU1QVFMgPSAxMDtcbnZhciBSRVRSWV9ERUxBWVMgPSBbXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlM1xuXTtcbmZ1bmN0aW9uIHNwbGl0RmlsZUludG9QYXJ0cyhmaWxlKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGxldCBzdGFydCA9IDA7XG4gIHdoaWxlIChzdGFydCA8IGZpbGUuc2l6ZSkge1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgQVRUQUNITUVOVF9QQVJUX1NJWkUsIGZpbGUuc2l6ZSk7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICBwYXJ0TnVtYmVyOiBwYXJ0cy5sZW5ndGggKyAxLFxuICAgICAgcGFydDogZmlsZS5zbGljZShzdGFydCwgZW5kKVxuICAgIH0pO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbnZhciBDb21tZW50c0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJvb20ob3B0aW9ucywgY29uZmlnKSB7XG4gIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlO1xuICBjb25zdCBpbml0aWFsU3RvcmFnZSA9IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2U7XG4gIGNvbnN0IFtpbkJhY2tncm91bmRTaW5jZSwgdW5pbnN0YWxsQmdUYWJTcHldID0gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKTtcbiAgY29uc3QgZGVsZWdhdGVzID0ge1xuICAgIC4uLmNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgLy8gQSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gZ28gaW50byBcInpvbWJpZSBzdGF0ZVwiIG9ubHkgaWYgYWxsIG9mIHRoZVxuICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zIGFwcGx5OlxuICAgIC8vXG4gICAgLy8gLSBUaGUgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBjbGllbnQgb3B0aW9uIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyAtIFRoZSBicm93c2VyIHdpbmRvdyBoYXMgYmVlbiBpbiB0aGUgYmFja2dyb3VuZCBmb3IgYXQgbGVhc3RcbiAgICAvLyAgIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgLy8gLSBUaGVyZSBhcmUgbm8gcGVuZGluZyBjaGFuZ2VzXG4gICAgLy9cbiAgICBjYW5ab21iaWUoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICE9PSB2b2lkIDAgJiYgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCAhPT0gbnVsbCAmJiBEYXRlLm5vdygpID4gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCArIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAmJiBnZXRTdG9yYWdlU3RhdHVzKCkgIT09IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGRlbGVnYXRlcyxcbiAgICBjb25maWcuZW5hYmxlRGVidWdMb2dnaW5nXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgYnVmZmVyOiB7XG4gICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgIGxhc3RGbHVzaGVkQXQ6IDAsXG4gICAgICBwcmVzZW5jZVVwZGF0ZXM6IChcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGluaXRpYWwgcHJlc2VuY2UgbWVzc2FnZSBhcyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICBkYXRhOiBpbml0aWFsUHJlc2VuY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXVxuICAgIH0sXG4gICAgc3RhdGljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBteVByZXNlbmNlOiBuZXcgUGF0Y2hhYmxlUmVmKGluaXRpYWxQcmVzZW5jZSksXG4gICAgb3RoZXJzOiBuZXcgT3RoZXJzUmVmKCksXG4gICAgaW5pdGlhbFN0b3JhZ2UsXG4gICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIC8vIFkuanNcbiAgICBwcm92aWRlcjogdm9pZCAwLFxuICAgIG9uUHJvdmlkZXJVcGRhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgY29uc3QgZG9Ob3RCYXRjaFVwZGF0ZXMgPSAoY2IpID0+IGNiKCk7XG4gIGNvbnN0IGJhdGNoVXBkYXRlcyA9IGNvbmZpZy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/PyBkb05vdEJhdGNoVXBkYXRlcztcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VCYXRjaDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENsaWVudEFwaShlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKFwiL3YyL2Mvcm9vbXMvXCIpKSB7XG4gICAgICByYWlzZShcIkV4cGVjdGVkIGEgL3YyL2Mvcm9vbXMvKiBlbmRwb2ludFwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IHVybGpvaW4oY29uZmlnLmJhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIGNvbnN0IGZldGNoZXIgPSBjb25maWcucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaGVyKHVybDIsIHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zMj8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEJlYXJlclRva2VuRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWAsXG4gICAgICAgIFwiWC1MQi1DbGllbnRcIjogUEtHX1ZFUlNJT04gfHwgXCJkZXZcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhWYWx1ZSwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vc3RvcmFnZWAsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGh0dHBQb3N0VG9Sb29tKGVuZHBvaW50LCBib2R5KSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIGVuZHBvaW50ID09PSBcIi9zZW5kLW1lc3NhZ2VcIiA/IHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3NlbmQtbWVzc2FnZWAgOiB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRNZW50aW9uKHVzZXJJZCwgbWVudGlvbklkKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RleHQtbWVudGlvbnNgLFxuICAgICAgbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIG1lbnRpb25JZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24obWVudGlvbklkKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RleHQtbWVudGlvbnMvJHttZW50aW9uSWR9YCxcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydFRleHRFZGl0b3IodHlwZSwgcm9vdEtleSkge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKTtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHJvb3RLZXkgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMoKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3ZlcnNpb25zYCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0veS12ZXJzaW9uLyR7dmVyc2lvbklkfWAsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7IG1ldGhvZDogXCJHRVRcIiB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0VmVyc2lvbigpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdmVyc2lvbmAsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7IG1ldGhvZDogXCJQT1NUXCIgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlcyk7XG4gICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5ub25jZTtcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQICYmIG5vbmNlKSB7XG4gICAgICBjb25zdCBzaXplID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRQYXlsb2FkKS5sZW5ndGg7XG4gICAgICBpZiAoc2l6ZSA+IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICAgIHZvaWQgaHR0cFBvc3RUb1Jvb20oXCIvc2VuZC1tZXNzYWdlXCIsIHsgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oXG4gICAgICAgICAgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcC5vayAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWVzc2FnZSB3YXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzIGFuZCBzZW50IG92ZXIgSFRUUCBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYW5hZ2VkU29ja2V0LnNlbmQoc2VyaWFsaXplZFBheWxvYWQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQubXlQcmVzZW5jZSxcbiAgICAoc3RhdGljU2Vzc2lvbiwgZHluYW1pY1Nlc3Npb24sIG15UHJlc2VuY2UpID0+IHtcbiAgICAgIGlmIChzdGF0aWNTZXNzaW9uID09PSBudWxsIHx8IGR5bmFtaWNTZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoZHluYW1pY1Nlc3Npb24uc2NvcGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGR5bmFtaWNTZXNzaW9uLmFjdG9yLFxuICAgICAgICAgIGlkOiBzdGF0aWNTZXNzaW9uLnVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBzdGF0aWNTZXNzaW9uLnVzZXJJbmZvLFxuICAgICAgICAgIHByZXNlbmNlOiBteVByZXNlbmNlLFxuICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoZHluYW1pY1Nlc3Npb24uc2NvcGVzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgbGV0IF9sYXN0U2VsZjtcbiAgZnVuY3Rpb24gbm90aWZ5U2VsZkNoYW5nZWQoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3QgY3VyclNlbGYgPSBzZWxmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJTZWxmICE9PSBudWxsICYmIGN1cnJTZWxmICE9PSBfbGFzdFNlbGYpIHtcbiAgICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICAgIGV2ZW50SHViLnNlbGYubm90aWZ5KGN1cnJTZWxmKTtcbiAgICAgIH0pO1xuICAgICAgX2xhc3RTZWxmID0gY3VyclNlbGY7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGZBc1RyZWVOb2RlID0gbmV3IERlcml2ZWRSZWYoXG4gICAgc2VsZixcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gdXNlclRvVHJlZU5vZGUoXCJNZVwiLCBtZSkgOiBudWxsXG4gICk7XG4gIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChtZXNzYWdlLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBsb2FkIHN0b3JhZ2Ugd2l0aG91dCBpdGVtc1wiKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICB1cGRhdGVSb290KG1lc3NhZ2UuaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucm9vdCA9IExpdmVPYmplY3QuX2Zyb21JdGVtcyhtZXNzYWdlLml0ZW1zLCBwb29sKTtcbiAgICB9XG4gICAgY29uc3QgY2FuV3JpdGUgPSBzZWxmLmN1cnJlbnQ/LmNhbldyaXRlID8/IHRydWU7XG4gICAgY29uc3Qgc3RhY2tTaXplQmVmb3JlID0gY29udGV4dC51bmRvU3RhY2subGVuZ3RoO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHQuaW5pdGlhbFN0b3JhZ2UpIHtcbiAgICAgIGlmIChjb250ZXh0LnJvb3QuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY2FuV3JpdGUpIHtcbiAgICAgICAgICBjb250ZXh0LnJvb3Quc2V0KGtleSwgY2xvbmVMc29uKGNvbnRleHQuaW5pdGlhbFN0b3JhZ2Vba2V5XSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHBvcHVsYXRlIG1pc3Npbmcgc3RvcmFnZSBrZXkgJyR7a2V5fScsIGJ1dCBjdXJyZW50IHVzZXIgaGFzIG5vIHdyaXRlIGFjY2Vzc2BcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IHN0YWNrU2l6ZUJlZm9yZTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb290KGl0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2YgY29udGV4dC5ub2Rlcykge1xuICAgICAgY3VycmVudEl0ZW1zLnNldChpZCwgbm9kZS5fc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3IE1hcChpdGVtcykpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgZmFsc2UpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5LnVuc2hpZnQoLi4uaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gdXBkYXRlcy5zdG9yYWdlVXBkYXRlcztcbiAgICBjb25zdCBvdGhlcnNVcGRhdGVzID0gdXBkYXRlcy5vdGhlcnM7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICAgIGV2ZW50SHViLm90aGVycy5ub3RpZnkoeyAuLi5ldmVudCwgb3RoZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcy5wcmVzZW5jZSA/PyBmYWxzZSkge1xuICAgICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGV2ZW50SHViLm15UHJlc2VuY2Uubm90aWZ5KGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yYWdlVXBkYXRlcyAhPT0gdm9pZCAwICYmIHN0b3JhZ2VVcGRhdGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICAgIGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5ub3RpZnkodXBkYXRlczIpO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudDtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uYWN0b3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW50ZXJuYWwuIFRyaWVkIHRvIGdldCBjb25uZWN0aW9uIGlkIGJ1dCBjb25uZWN0aW9uIHdhcyBuZXZlciBvcGVuXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3BzKHJhd09wcywgaXNMb2NhbCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZWROb2RlSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBvcHMgPSByYXdPcHMubWFwKChvcCkgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIiAmJiAhb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4geyAuLi5vcCwgb3BJZDogcG9vbC5nZW5lcmF0ZU9wSWQoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICByZXZlcnNlLmRhdGFba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKG9wLmRhdGEpO1xuICAgICAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0geyB0eXBlOiBcInBhcnRpYWxcIiwgZGF0YTogb3AuZGF0YSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvcC5kYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIHNvdXJjZSA9IGRlbGV0ZWQgPyAyIC8qIEFDSyAqLyA6IDEgLyogUkVNT1RFICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5T3BSZXN1bHQgPSBhcHBseU9wKG9wLCBzb3VyY2UpO1xuICAgICAgICBpZiAoYXBwbHlPcFJlc3VsdC5tb2RpZmllZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQ7XG4gICAgICAgICAgaWYgKCEobm9kZUlkICYmIGNyZWF0ZWROb2RlSWRzLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgbm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLmdldChubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSksXG4gICAgICAgICAgICAgICAgYXBwbHlPcFJlc3VsdC5tb2RpZmllZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdCguLi5hcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IG91dHB1dC5yZXZlcnNlLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5fYXBwbHkob3AsIHNvdXJjZSA9PT0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi8pO1xuICAgICAgfVxuICAgICAgY2FzZSAxIC8qIFNFVF9QQVJFTlRfS0VZICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiBpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Lm5vZGUuX3NldENoaWxkS2V5KFxuICAgICAgICAgICAgYXNQb3Mob3AucGFyZW50S2V5KSxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86IHtcbiAgICAgICAgaWYgKG9wLnBhcmVudElkID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgIH1cbiAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gocGF0Y2gpO1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnJldmVyc2VPcHMudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IG9sZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5wcmVzZW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKFxuICAgICAgICAgICAgW3sgdHlwZTogXCJwcmVzZW5jZVwiLCBkYXRhOiBvbGRWYWx1ZXMgfV0sXG4gICAgICAgICAgICBkb05vdEJhdGNoVXBkYXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KHsgcHJlc2VuY2U6IHRydWUgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50YXJnZXRBY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBvbGRVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSk7XG4gICAgICBjb25zdCBuZXdVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGlmIChvbGRVc2VyID09PSB2b2lkIDAgJiYgbmV3VXNlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlcjogbmV3VXNlciB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5wYXRjaE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSksIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICB1cGRhdGVzOiBtZXNzYWdlLmRhdGEsXG4gICAgICAgIHVzZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibGVhdmVcIiwgdXNlciB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgIGFjdG9yOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICBzY29wZXM6IG1lc3NhZ2Uuc2NvcGVzXG4gICAgfSk7XG4gICAgY29udGV4dC5pZEZhY3RvcnkgPSBtYWtlSWRGYWN0b3J5KG1lc3NhZ2UuYWN0b3IpO1xuICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSWQgb2YgY29udGV4dC5vdGhlcnMuY29ubmVjdGlvbklkcygpKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1tjb25uZWN0aW9uSWRdO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2UudXNlcnMpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIoa2V5KTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5pbmZvLFxuICAgICAgICB1c2VyLnNjb3Blc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZXNldFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICByZXR1cm4gY29udGV4dC51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBjYW5SZWRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuaGlzdG9yeS5ub3RpZnkoeyBjYW5VbmRvOiBjYW5VbmRvKCksIGNhblJlZG86IGNhblJlZG8oKSB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgbWVzc2FnZS5hY3RvcixcbiAgICAgIG1lc3NhZ2UuaWQsXG4gICAgICBtZXNzYWdlLmluZm8sXG4gICAgICBtZXNzYWdlLnNjb3Blc1xuICAgICk7XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgZGF0YTogY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvclxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgcmV0dXJuIHVzZXIgPyB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlciB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2VzKHRleHQpIHtcbiAgICBjb25zdCBkYXRhID0gdHJ5UGFyc2VKc29uKHRleHQpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNKc29uQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBjb21wYWN0KGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZVNlcnZlck1lc3NhZ2UoaXRlbSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoW3BhcnNlU2VydmVyTWVzc2FnZShkYXRhKV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBseUFuZFNlbmRPcHMob2ZmbGluZU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IG9wcyA9IEFycmF5LmZyb20ob2ZmbGluZU9wcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCB0cnVlKTtcbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgIG9wczogcmVzdWx0Lm9wc1xuICAgIH0pO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNlcnZlck1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBwYXJzZVNlcnZlck1lc3NhZ2VzKGV2ZW50LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlcyA9PT0gbnVsbCB8fCBtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb3RoZXJzOiBbXVxuICAgIH07XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgICBjb25zdCB1c2VySm9pbmVkVXBkYXRlID0gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh1c2VySm9pbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnNQcmVzZW5jZVVwZGF0ZSA9IG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob3RoZXJzUHJlc2VuY2VVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAzIC8qIEJST0FEQ0FTVEVEX0VWRU5UICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICAgICAgZXZlbnRIdWIuY3VzdG9tRXZlbnQubm90aWZ5KHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLmFjdG9yIDwgMCA/IG51bGwgOiBvdGhlcnMuZmluZCgodSkgPT4gdS5jb25uZWN0aW9uSWQgPT09IG1lc3NhZ2UuYWN0b3IpID8/IG51bGwsXG4gICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Mikge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzMDAgLyogVVBEQVRFX1lET0MgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTA0IC8qIFJPT01fU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovOiB7XG4gICAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5UmVzdWx0ID0gYXBwbHlPcHMobWVzc2FnZS5vcHMsIGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFwcGx5UmVzdWx0LnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXModXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyOTkgLyogUkVKRUNUX1NUT1JBR0VfT1AgKi86IHtcbiAgICAgICAgICAgIGVycm9yV2l0aFRpdGxlKFxuICAgICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCB0cmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wSWQgb2YgbWVzc2FnZS5vcElkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gY29udGV4dC5vcFN0YWNrVHJhY2VzPy5nZXQob3BJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgICB0cmFjZXMuYWRkKHRyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRyYWNlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHdhcm5XaXRoVGl0bGUoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gY2FsbHMgY2F1c2VkIHRoZSByZWplY3RlZCBzdG9yYWdlIG11dGF0aW9uczpcIixcbiAgICAgICAgICAgICAgICAgIGBcblxuJHtBcnJheS5mcm9tKHRyYWNlcykuam9pbihcIlxcblxcblwiKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFN0b3JhZ2UgbXV0YXRpb25zIHJlamVjdGVkIGJ5IHNlcnZlcjogJHttZXNzYWdlLnJlYXNvbn1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0MDAgLyogVEhSRUFEX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDcgLyogVEhSRUFEX0RFTEVURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDggLyogVEhSRUFEX1VQREFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDUgLyogQ09NTUVOVF9SRUFDVElPTl9BRERFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgICAgY2FzZSA0MDIgLyogQ09NTUVOVF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAzIC8qIENPTU1FTlRfRURJVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIuY29tbWVudHMubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3RpZnkodXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoTm93T3JTb29uKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VPcHMgPSBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucztcbiAgICBpZiAoc3RvcmFnZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIHN0b3JhZ2VPcHMpIHtcbiAgICAgICAgY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zZXQobm4ob3Aub3BJZCksIG9wKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdyAtIGNvbnRleHQuYnVmZmVyLmxhc3RGbHVzaGVkQXQ7XG4gICAgaWYgKGVsYXBzZWRNaWxsaXMgPj0gY29uZmlnLnRocm90dGxlRGVsYXkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9GbHVzaCA9IHNlcmlhbGl6ZUJ1ZmZlcigpO1xuICAgICAgaWYgKG1lc3NhZ2VzVG9GbHVzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzVG9GbHVzaCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlciA9IHtcbiAgICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICAgIGxhc3RGbHVzaGVkQXQ6IG5vdyxcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIHByZXNlbmNlVXBkYXRlczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgICBmbHVzaE5vd09yU29vbixcbiAgICAgICAgY29uZmlnLnRocm90dGxlRGVsYXkgLSBlbGFwc2VkTWlsbGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXJpYWxpemVCdWZmZXIoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMudHlwZSA9PT0gXCJmdWxsXCIgPyB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICAvLyBQb3B1bGF0aW5nIHRoZSBgdGFyZ2V0QWN0b3JgIGZpZWxkIHR1cm5zIHRoaXMgbWVzc2FnZSBpbnRvXG4gICAgICAgICAgLy8gYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZSBtZXNzYWdlIChub3QgYSBwYXRjaCksIHdoaWNoIHdpbGwgZ2V0XG4gICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYnkgb3RoZXIgY2xpZW50cyBhcyBzdWNoLlxuICAgICAgICAgIHRhcmdldEFjdG9yOiAtMSxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgICBvcHM6IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVlEb2ModXBkYXRlLCBndWlkKSB7XG4gICAgY29uc3QgY2xpZW50TXNnID0ge1xuICAgICAgdHlwZTogMzAxIC8qIFVQREFURV9ZRE9DICovLFxuICAgICAgdXBkYXRlLFxuICAgICAgZ3VpZFxuICAgIH07XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaChjbGllbnRNc2cpO1xuICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KGNsaWVudE1zZyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBicm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIgPSB7XG4gICAgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIiAmJiAhb3B0aW9uczIuc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDMgLyogQlJPQURDQVNUX0VWRU5UICovLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoT3BzKG9wcykge1xuICAgIGNvbnN0IHsgc3RvcmFnZU9wZXJhdGlvbnMgfSA9IGNvbnRleHQuYnVmZmVyO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBzdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBsZXQgX2dldFN0b3JhZ2UkID0gbnVsbDtcbiAgbGV0IF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BzID0gbmV3IE1hcChjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJlYW1GZXRjaChtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSwgY29uZmlnLnJvb21JZCk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZDtcbiAgICB9KSkge1xuICAgICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDMwMCAvKiBGRVRDSF9ZRE9DICovLFxuICAgICAgICB2ZWN0b3IsXG4gICAgICAgIGd1aWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gMDtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSB7XG4gICAgICAgIG9wczogW10sXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3BzOiBbXVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaFVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzUHJlc2VuY2VSZWFkeSgpIHtcbiAgICByZXR1cm4gc2VsZi5jdXJyZW50ICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1ByZXNlbmNlUmVhZHkoKSkge1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGNvbnN0IHVuc3ViMSA9IGV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBjb25zdCB1bnN1YjIgPSBldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgdW5zdWIxKCk7XG4gICAgICB1bnN1YjIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlUmVhZHkoKSB7XG4gICAgcmV0dXJuIGdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzU3RvcmFnZVJlYWR5KCkpIHtcbiAgICAgIGF3YWl0IGdldFN0b3JhZ2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5vdGhlcnMsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICBlcnJvcjogZXZlbnRIdWIuZXJyb3Iub2JzZXJ2YWJsZSxcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlQmF0Y2gub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlQmF0Y2g6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlXG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29tbWVudHNBcGkoZW5kcG9pbnQsIHBhcmFtcywgb3B0aW9uczIpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMyLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29tbWVudHNKc29uKGVuZHBvaW50LCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMyKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1NpbmNlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICB7IHNpbmNlOiBvcHRpb25zMj8uc2luY2U/LnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICB1cGRhdGVkOiBqc29uLmRhdGEubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICAgIH0sXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICB1cGRhdGVkOiBbXSxcbiAgICAgICAgICBkZWxldGVkOiBbXVxuICAgICAgICB9LFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICB1cGRhdGVkOiBbXSxcbiAgICAgICAgICBkZWxldGVkOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZHMuXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zMj8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zMi5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAge1xuICAgICAgICBjdXJzb3I6IG9wdGlvbnMyPy5jdXJzb3IsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgICB9LFxuICAgICAgeyBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczoganNvbi5kYXRhLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICAgICksXG4gICAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBbXSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgZGVsZXRlZFRocmVhZHM6IFtdLFxuICAgICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgbmV4dEN1cnNvcjogbnVsbCxcbiAgICAgICAgcmVxdWVzdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWRzLlwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHRocmVhZElkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkLXdpdGgtbm90aWZpY2F0aW9uLyR7dGhyZWFkSWR9YFxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiBjb252ZXJ0VG9UaHJlYWREYXRhKGpzb24udGhyZWFkKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IGpzb24uaW5ib3hOb3RpZmljYXRpb24gPyBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoanNvbi5pbmJveE5vdGlmaWNhdGlvbikgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiB2b2lkIDAsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkICR7dGhyZWFkSWR9LmApO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQoe1xuICAgIG1ldGFkYXRhLFxuICAgIGJvZHksXG4gICAgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCksXG4gICAgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpLFxuICAgIGF0dGFjaG1lbnRJZHNcbiAgfSkge1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgYXR0YWNobWVudElkc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGhyZWFkKHRocmVhZElkKSB7XG4gICAgYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCxcbiAgICAgIHsgbWV0aG9kOiBcIkRFTEVURVwiIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YSh7XG4gICAgbWV0YWRhdGEsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIHJldHVybiBhd2FpdCBmZXRjaENvbW1lbnRzSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNSZXNvbHZlZCh0aHJlYWRJZCkge1xuICAgIGF3YWl0IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tYXJrLWFzLXJlc29sdmVkYCxcbiAgICAgIHsgbWV0aG9kOiBcIlBPU1RcIiB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNVbnJlc29sdmVkKHRocmVhZElkKSB7XG4gICAgYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21hcmstYXMtdW5yZXNvbHZlZGAsXG4gICAgICB7IG1ldGhvZDogXCJQT1NUXCIgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCksXG4gICAgYm9keSxcbiAgICBhdHRhY2htZW50SWRzXG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgYXR0YWNobWVudElkc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keSxcbiAgICBhdHRhY2htZW50SWRzXG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBhdHRhY2htZW50SWRzXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaENvbW1lbnRzSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9YCxcbiAgICAgIHsgbWV0aG9kOiBcIkRFTEVURVwiIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfS9yZWFjdGlvbnNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbW9qaSB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH0vcmVhY3Rpb25zLyR7ZW1vaml9YCxcbiAgICAgIHsgbWV0aG9kOiBcIkRFTEVURVwiIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVBdHRhY2htZW50KGZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsb2NhbEF0dGFjaG1lbnRcIixcbiAgICAgIHN0YXR1czogXCJpZGxlXCIsXG4gICAgICBpZDogY3JlYXRlQ29tbWVudEF0dGFjaG1lbnRJZCgpLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGZpbGVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0aW9uczIgPSB7fSkge1xuICAgIGNvbnN0IGFib3J0U2lnbmFsID0gb3B0aW9uczIuc2lnbmFsO1xuICAgIGNvbnN0IGFib3J0RXJyb3IgPSBhYm9ydFNpZ25hbCA/IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBgVXBsb2FkIG9mIGF0dGFjaG1lbnQgJHthdHRhY2htZW50LmlkfSB3YXMgYWJvcnRlZC5gLFxuICAgICAgXCJBYm9ydEVycm9yXCJcbiAgICApIDogdm9pZCAwO1xuICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlUmV0cnlFcnJvciA9IChlcnIpID0+IHtcbiAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChhdHRhY2htZW50LnNpemUgPD0gQVRUQUNITUVOVF9QQVJUX1NJWkUpIHtcbiAgICAgIHJldHVybiBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vdXBsb2FkLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQubmFtZSl9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2htZW50LmZpbGUsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdXBsb2FkSWQ7XG4gICAgICBjb25zdCB1cGxvYWRlZFBhcnRzID0gW107XG4gICAgICBjb25zdCBjcmVhdGVNdWx0aVBhcnRVcGxvYWQgPSBhd2FpdCBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQubmFtZSl9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsZVNpemU6IGF0dGFjaG1lbnQuc2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVwbG9hZElkID0gY3JlYXRlTXVsdGlQYXJ0VXBsb2FkLnVwbG9hZElkO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHNwbGl0RmlsZUludG9QYXJ0cyhhdHRhY2htZW50LmZpbGUpO1xuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSBjaHVuayhwYXJ0cywgQVRUQUNITUVOVF9QQVJUX0JBVENIX1NJWkUpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRzMiBvZiBiYXRjaGVzKSB7XG4gICAgICAgICAgY29uc3QgdXBsb2FkZWRQYXJ0c1Byb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCB7IHBhcnQsIHBhcnROdW1iZXIgfSBvZiBwYXJ0czIpIHtcbiAgICAgICAgICAgIHVwbG9hZGVkUGFydHNQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBhdXRvUmV0cnkoXG4gICAgICAgICAgICAgICAgKCkgPT4gZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke2NyZWF0ZU11bHRpUGFydFVwbG9hZC51cGxvYWRJZH0vJHtTdHJpbmcocGFydE51bWJlcil9YCxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJ0LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgICAgICAgICBSRVRSWV9ERUxBWVMsXG4gICAgICAgICAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGxvYWRlZFBhcnRzLnB1c2goLi4uYXdhaXQgUHJvbWlzZS5hbGwodXBsb2FkZWRQYXJ0c1Byb21pc2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3J0ZWRVcGxvYWRlZFBhcnRzID0gdXBsb2FkZWRQYXJ0cy5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBhLnBhcnROdW1iZXIgLSBiLnBhcnROdW1iZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9L2NvbXBsZXRlYCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGFydHM6IHNvcnRlZFVwbG9hZGVkUGFydHMgfSksXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICAgIGlmICh1cGxvYWRJZCAmJiBlcnJvcjM/Lm5hbWUgJiYgKGVycm9yMy5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvcjMubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIikpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHt1cGxvYWRJZH1gLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjQpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJscyhhdHRhY2htZW50SWRzKSB7XG4gICAgY29uc3QgeyB1cmxzIH0gPSBhd2FpdCBmZXRjaENvbW1lbnRzSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzL3ByZXNpZ25lZC11cmxzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYXR0YWNobWVudElkcyB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZEdldEF0dGFjaG1lbnRVcmxzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkQXR0YWNobWVudElkcykgPT4ge1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGJhdGNoZWRBdHRhY2htZW50SWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRVcmxzID0gYXdhaXQgZ2V0QXR0YWNobWVudFVybHMoYXR0YWNobWVudElkcyk7XG4gICAgICByZXR1cm4gYXR0YWNobWVudFVybHMubWFwKFxuICAgICAgICAodXJsMikgPT4gdXJsMiA/PyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGlzIGF0dGFjaG1lbnQncyBVUkxcIilcbiAgICAgICk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBHRVRfQVRUQUNITUVOVF9VUkxTX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgY29uc3QgYXR0YWNobWVudFVybHNTdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZEdldEF0dGFjaG1lbnRVcmxzKTtcbiAgZnVuY3Rpb24gZ2V0QXR0YWNobWVudFVybChhdHRhY2htZW50SWQpIHtcbiAgICByZXR1cm4gYmF0Y2hlZEdldEF0dGFjaG1lbnRVcmxzLmdldChhdHRhY2htZW50SWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoTm90aWZpY2F0aW9uc0pzb24oZW5kcG9pbnQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDbGllbnRBcGkoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9uczIpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAge1xuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgZ2V0IHByZXNlbmNlQnVmZmVyKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzPy5kYXRhID8/IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IHVuZG9TdGFjaygpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQudW5kb1N0YWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCBub2RlQ291bnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQubm9kZXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldFByb3ZpZGVyKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LnByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICBjb250ZXh0Lm9uUHJvdmlkZXJVcGRhdGUubm90aWZ5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvdmlkZXJVcGRhdGU6IGNvbnRleHQub25Qcm92aWRlclVwZGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgICAvLyBzZW5kIG1ldGFkYXRhIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBkZWxldGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBsaXN0IHZlcnNpb25zIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zLFxuICAgICAgICAvLyBnZXQgYSBzcGVjaWZpYyB2ZXJzaW9uXG4gICAgICAgIGdldFRleHRWZXJzaW9uLFxuICAgICAgICAvLyBjcmVhdGUgYSB2ZXJzaW9uXG4gICAgICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5jdXJyZW50LFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5jdXJyZW50LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNobWVudFVybHNTdG9yZVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cyksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaCxcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgaXNQcmVzZW5jZVJlYWR5LFxuICAgICAgaXNTdG9yYWdlUmVhZHksXG4gICAgICB3YWl0VW50aWxQcmVzZW5jZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFByZXNlbmNlUmVhZHkpLFxuICAgICAgd2FpdFVudGlsU3RvcmFnZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSksXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmN1cnJlbnQsXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgZ2V0T3RoZXJzOiAoKSA9PiBjb250ZXh0Lm90aGVycy5jdXJyZW50LFxuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIGdldFRocmVhZHMsXG4gICAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgICBnZXRUaHJlYWQsXG4gICAgICBjcmVhdGVUaHJlYWQsXG4gICAgICBkZWxldGVUaHJlYWQsXG4gICAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICAgIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgICBjcmVhdGVDb21tZW50LFxuICAgICAgZWRpdENvbW1lbnQsXG4gICAgICBkZWxldGVDb21tZW50LFxuICAgICAgYWRkUmVhY3Rpb24sXG4gICAgICByZW1vdmVSZWFjdGlvbixcbiAgICAgIHByZXBhcmVBdHRhY2htZW50LFxuICAgICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgICBnZXROb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkXG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgaW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5lcnJvci5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29tbWVudHNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGBcIiR7U3RyaW5nKGZpcnN0KX1cIiBpcyBub3QgYSB2YWxpZCBldmVudCBuYW1lYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCB8fCB0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IGZpcnN0O1xuICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgbGlzdGVuZXIgY2FsbGJhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xpdmVOb2RlKGZpcnN0KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGZpcnN0O1xuICAgICAgaWYgKG9wdGlvbnM/LmlzRGVlcCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGVDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBub2RlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtTdHJpbmcoZmlyc3QpfSBpcyBub3QgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdWJzY3JpYmVkIHRvLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBzdWJzY3JpYmU7XG59XG5mdW5jdGlvbiBpc1Jvb21FdmVudE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm15LXByZXNlbmNlXCIgfHwgdmFsdWUgPT09IFwib3RoZXJzXCIgfHwgdmFsdWUgPT09IFwiZXZlbnRcIiB8fCB2YWx1ZSA9PT0gXCJlcnJvclwiIHx8IHZhbHVlID09PSBcImhpc3RvcnlcIiB8fCB2YWx1ZSA9PT0gXCJzdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJzdG9yYWdlLXN0YXR1c1wiIHx8IHZhbHVlID09PSBcImxvc3QtY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb21tZW50c1wiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgdXJsMi5wcm90b2NvbCA9IHVybDIucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsMi5wYXRobmFtZSA9IFwiL3Y3XCI7XG4gICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicHVia2V5XCIsIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoYXV0aFZhbHVlLCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICAgIH1cbiAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsMi50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbnZhciBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZID0gNTA7XG52YXIgUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBnZXRUaHJvdHRsZShjbGllbnRPcHRpb25zLnRocm90dGxlID8/IERFRkFVTFRfVEhST1RUTEUpO1xuICBjb25zdCBsb3N0Q29ubmVjdGlvblRpbWVvdXQgPSBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5sb3N0Q29ubmVjdGlvblRpbWVvdXQgPz8gREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xuICBjb25zdCBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCA9IGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcbiAgKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoY2xpZW50T3B0aW9ucy5iYXNlVXJsKTtcbiAgY29uc3QgYXV0aE1hbmFnZXIgPSBjcmVhdGVBdXRoTWFuYWdlcihvcHRpb25zKTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Sb29tKHJvb20pIHtcbiAgICB1bmxpbmtEZXZUb29scyhyb29tLmlkKTtcbiAgICByb29tc0J5SWQuZGVsZXRlKHJvb20uaWQpO1xuICAgIHJvb20uZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxlYXNlUm9vbShkZXRhaWxzKSB7XG4gICAgY29uc3QgbGVhdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gbGVhdmU7XG4gICAgICBpZiAoIWRldGFpbHMudW5zdWJzLmRlbGV0ZShzZWxmKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhpcyBsZWF2ZSBmdW5jdGlvbiB3YXMgYWxyZWFkeSBjYWxsZWQuIENhbGxpbmcgaXQgbW9yZSB0aGFuIG9uY2UgaGFzIG5vIGVmZmVjdC5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRldGFpbHMudW5zdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0ZWFyZG93blJvb20oZGV0YWlscy5yb29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZGV0YWlscy51bnN1YnMuYWRkKGxlYXZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogZGV0YWlscy5yb29tLFxuICAgICAgbGVhdmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyUm9vbShyb29tSWQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlYXNlUm9vbShleGlzdGluZyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMyID0gYXJnc1swXSA/PyB7fTtcbiAgICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlKHJvb21JZCkgOiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UpID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gKHR5cGVvZiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlKSA/PyB7fTtcbiAgICBjb25zdCBuZXdSb29tID0gY3JlYXRlUm9vbShcbiAgICAgIHsgaW5pdGlhbFByZXNlbmNlLCBpbml0aWFsU3RvcmFnZSB9LFxuICAgICAge1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocm90dGxlRGVsYXksXG4gICAgICAgIGxvc3RDb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgICAgIHBvbHlmaWxsczogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMsXG4gICAgICAgIGRlbGVnYXRlczogY2xpZW50T3B0aW9ucy5tb2NrZWREZWxlZ2F0ZXMgPz8ge1xuICAgICAgICAgIGNyZWF0ZVNvY2tldDogbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uV2ViU29ja2V0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhdXRoZW50aWNhdGU6IG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZURlYnVnTG9nZ2luZzogY2xpZW50T3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcsXG4gICAgICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBvcHRpb25zMj8udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIHVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAsXG4gICAgICAgIHVuc3RhYmxlX3N0cmVhbURhdGE6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9zdHJlYW1EYXRhXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBuZXdSb29tRGV0YWlscyA9IHtcbiAgICAgIHJvb206IG5ld1Jvb20sXG4gICAgICB1bnN1YnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHJvb21zQnlJZC5zZXQocm9vbUlkLCBuZXdSb29tRGV0YWlscyk7XG4gICAgc2V0dXBEZXZUb29scygoKSA9PiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpKTtcbiAgICBsaW5rRGV2VG9vbHMocm9vbUlkLCBuZXdSb29tKTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gb3B0aW9uczIuYXV0b0Nvbm5lY3QgPz8gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uYXRvYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJZb3UgbmVlZCB0byBwb2x5ZmlsbCBhdG9iIHRvIHVzZSB0aGUgY2xpZW50IGluIHlvdXIgZW52aXJvbm1lbnQuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYXRvYi1wb2x5ZmlsbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuYXRvYiA9IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLmF0b2I7XG4gICAgICB9XG4gICAgICBuZXdSb29tLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXNlUm9vbShuZXdSb29tRGV0YWlscyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy5yb29tO1xuICAgIHJldHVybiByb29tID8gcm9vbSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgIGF1dGhNYW5hZ2VyLnJlc2V0KCk7XG4gICAgZm9yIChjb25zdCB7IHJvb20gfSBvZiByb29tc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgIGlmICghaXNJZGxlKHJvb20uZ2V0U3RhdHVzKCkpKSB7XG4gICAgICAgIHJvb20ucmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGN1cnJlbnRVc2VySWRTdG9yZSA9IGNyZWF0ZVN0b3JlKG51bGwpO1xuICBjb25zdCBmZXRjaGVyID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZldGNoO1xuICBjb25zdCBodHRwQ2xpZW50TGlrZSA9IGNyZWF0ZU5vdGlmaWNhdGlvbnNBcGkoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hlcixcbiAgICBhdXRoTWFuYWdlcixcbiAgICBjdXJyZW50VXNlcklkU3RvcmVcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVVzZXJzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoZWRSZXNvbHZlVXNlcnMpO1xuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8gPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVSb29tc0luZm8sXG4gICAgXCJTZXQgdGhlIHJlc29sdmVSb29tc0luZm8gb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHJvb20gaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZFJlc29sdmVSb29tc0luZm8pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAuLi5odHRwQ2xpZW50TGlrZSxcbiAgICAgIC8vIEludGVybmFsXG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBjdXJyZW50VXNlcklkU3RvcmUsXG4gICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IGNsaWVudE9wdGlvbnMucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgICAgICAgdXNlcnNTdG9yZSxcbiAgICAgICAgcm9vbXNJbmZvU3RvcmUsXG4gICAgICAgIGdldFJvb21JZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFwiQWxsXCIgdGhyZWFkcyAoPSBcInVzZXJcIiB0aHJlYWRzKVxuICAgICAgICBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWw6IGh0dHBDbGllbnRMaWtlLmdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICAgICAgZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWw6IGh0dHBDbGllbnRMaWtlLmdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsXG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG59XG52YXIgTm90aWZpY2F0aW9uc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBnZXRUaHJvdHRsZSh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXCJ0aHJvdHRsZVwiLCB2YWx1ZSwgTUlOX1RIUk9UVExFLCBNQVhfVEhST1RUTEUpO1xufVxuZnVuY3Rpb24gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImxvc3RDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG4gIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1dhcm5lZCAmJiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gY29uZGl0aW9uKCkgOiBjb25kaXRpb24pKSB7XG4gICAgICAgIHdhcm4oLi4uYXJncyk7XG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1lbnRzL2NvbW1lbnQtYm9keS50c1xuZnVuY3Rpb24gaXNDb21tZW50Qm9keVBhcmFncmFwaChlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gZWxlbWVudCkgJiYgXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMgPSB7XG4gIHBhcmFncmFwaDogaXNDb21tZW50Qm9keVBhcmFncmFwaCxcbiAgdGV4dDogaXNDb21tZW50Qm9keVRleHQsXG4gIGxpbms6IGlzQ29tbWVudEJvZHlMaW5rLFxuICBtZW50aW9uOiBpc0NvbW1lbnRCb2R5TWVudGlvblxufTtcbnZhciBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMgPSB7XG4gIHBhcmFncmFwaDogXCJibG9ja1wiLFxuICB0ZXh0OiBcImlubGluZVwiLFxuICBsaW5rOiBcImlubGluZVwiLFxuICBtZW50aW9uOiBcImlubGluZVwiXG59O1xuZnVuY3Rpb24gdHJhdmVyc2VDb21tZW50Qm9keShib2R5LCBlbGVtZW50T3JWaXNpdG9yLCBwb3NzaWJseVZpc2l0b3IpIHtcbiAgaWYgKCFib2R5IHx8ICFib2R5Py5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnRPclZpc2l0b3IgOiB2b2lkIDA7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c1R5cGVzW2VsZW1lbnRdIDogXCJhbGxcIjtcbiAgY29uc3QgZ3VhcmQgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c0d1YXJkc1tlbGVtZW50XSA6ICgpID0+IHRydWU7XG4gIGNvbnN0IHZpc2l0b3IgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudE9yVmlzaXRvciA6IHBvc3NpYmx5VmlzaXRvcjtcbiAgZm9yIChjb25zdCBibG9jayBvZiBib2R5LmNvbnRlbnQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGlmIChndWFyZChibG9jaykpIHtcbiAgICAgICAgdmlzaXRvcj8uKGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgZm9yIChjb25zdCBpbmxpbmUgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGd1YXJkKGlubGluZSkpIHtcbiAgICAgICAgICB2aXNpdG9yPy4oaW5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpIHtcbiAgY29uc3QgbWVudGlvbmVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJhdmVyc2VDb21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIFwibWVudGlvblwiLFxuICAgIChtZW50aW9uKSA9PiBtZW50aW9uZWRJZHMuYWRkKG1lbnRpb24uaWQpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1lbnRpb25lZElkcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2Vycykge1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFyZXNvbHZlVXNlcnMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRVc2VycztcbiAgfVxuICBjb25zdCB1c2VySWRzID0gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycyh7XG4gICAgdXNlcklkc1xuICB9KTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB1c2VyID0gdXNlcnM/LltpbmRleF07XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJlc29sdmVkVXNlcnMuc2V0KHVzZXJJZCwgdXNlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNvbHZlZFVzZXJzO1xufVxudmFyIGh0bWxFc2NhcGFibGVzID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbnZhciBodG1sRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMoaHRtbEVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGh0bWxTYWZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1N0cmluZyh2YWx1ZSldLCBbXSk7XG59XG5mdW5jdGlvbiBqb2luSHRtbChzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSHRtbFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbkh0bWwodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBodG1sRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IGh0bWxFc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBIdG1sU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVIdG1sKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbnZhciBtYXJrZG93bkVzY2FwYWJsZXMgPSB7XG4gIF86IFwiXFxcXF9cIixcbiAgXCIqXCI6IFwiXFxcXCpcIixcbiAgXCIjXCI6IFwiXFxcXCNcIixcbiAgXCJgXCI6IFwiXFxcXGBcIixcbiAgXCJ+XCI6IFwiXFxcXH5cIixcbiAgXCIhXCI6IFwiXFxcXCFcIixcbiAgXCJ8XCI6IFwiXFxcXHxcIixcbiAgXCIoXCI6IFwiXFxcXChcIixcbiAgXCIpXCI6IFwiXFxcXClcIixcbiAgXCJ7XCI6IFwiXFxcXHtcIixcbiAgXCJ9XCI6IFwiXFxcXH1cIixcbiAgXCJbXCI6IFwiXFxcXFtcIixcbiAgXCJdXCI6IFwiXFxcXF1cIlxufTtcbnZhciBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKG1hcmtkb3duRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gam9pbk1hcmtkb3duKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVNYXJrZG93bih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXJrZG93blNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbk1hcmtkb3duKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gbWFya2Rvd25Fc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBNYXJrZG93blNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlTWFya2Rvd24obm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFya2Rvd24oc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybDIpIHtcbiAgaWYgKHVybDIuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdXJsMi5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICByZXR1cm4gdXJsMjtcbiAgfSBlbHNlIGlmICh1cmwyLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9cIiArIHVybDI7XG4gIH1cbiAgcmV0dXJuO1xufVxudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiBjaGlsZHJlbixcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQsXG4gIGxpbms6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsLFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyBodG1sYDxwPiR7aHRtbFNhZmUoY2hpbGRyZW4pfTwvcD5gIDogY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGVtPiR7Y2hpbGRyZW59PC9lbT5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHM+JHtjaGlsZHJlbn08L3M+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPGEgaHJlZj1cIiR7aHJlZn1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+JHtlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmx9PC9hPmA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxzcGFuIGRhdGEtbWVudGlvbj5AJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9PC9zcGFuPmA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gKioke2NoaWxkcmVufSoqYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYF8ke2NoaWxkcmVufV9gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYH5+JHtjaGlsZHJlbn1+fmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXFxgJHtjaGlsZHJlbn1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBbJHtlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmx9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnRCb2R5KGJvZHksIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ID8/IFwicGxhaW5cIjtcbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucz8uc2VwYXJhdG9yID8/IChmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IFwiXFxuXFxuXCIgOiBcIlxcblwiKTtcbiAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgLi4uZm9ybWF0ID09PSBcImh0bWxcIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIDogZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgOiBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMsXG4gICAgLi4ub3B0aW9ucz8uZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IGF3YWl0IHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBvcHRpb25zPy5yZXNvbHZlVXNlcnNcbiAgKTtcbiAgY29uc3QgYmxvY2tzID0gYm9keS5jb250ZW50LmZsYXRNYXAoKGJsb2NrLCBibG9ja0luZGV4KSA9PiB7XG4gICAgc3dpdGNoIChibG9jay50eXBlKSB7XG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGJsb2NrLmNoaWxkcmVuLmZsYXRNYXAoKGlubGluZSwgaW5saW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubWVudGlvbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiByZXNvbHZlZFVzZXJzLmdldChpbmxpbmUuaWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5saW5rKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIGhyZWY6IHRvQWJzb2x1dGVVcmwoaW5saW5lLnVybCkgPz8gaW5saW5lLnVybFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlUZXh0KGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMudGV4dCh7IGVsZW1lbnQ6IGlubGluZSB9LCBpbmxpbmVJbmRleCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGVsZW1lbnRzLnBhcmFncmFwaChcbiAgICAgICAgICAgIHsgZWxlbWVudDogYmxvY2ssIGNoaWxkcmVuOiBpbmxpbmVzLmpvaW4oXCJcIikgfSxcbiAgICAgICAgICAgIGJsb2NrSW5kZXhcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcy5qb2luKHNlcGFyYXRvcik7XG59XG5cbi8vIHNyYy9jcmR0cy91dGlscy50c1xuZnVuY3Rpb24gdG9QbGFpbkxzb24obHNvbikge1xuICBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhsc29uLnRvT2JqZWN0KCkpLmZsYXRNYXAoXG4gICAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IFtba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldXSA6IFtdXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgWy4uLmxzb25dLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBkYXRhOiBbLi4ubHNvbl0ubWFwKChpdGVtKSA9PiB0b1BsYWluTHNvbihpdGVtKSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsc29uO1xuICB9XG59XG5cbi8vIHNyYy9pbW11dGFibGUudHNcbmZ1bmN0aW9uIGxzb25PYmplY3RUb0pzb24ob2JqKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbGl2ZU9iamVjdFRvSnNvbihsaXZlT2JqZWN0KSB7XG4gIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QudG9PYmplY3QoKSk7XG59XG5mdW5jdGlvbiBsaXZlTWFwVG9Kc29uKG1hcCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxzb25MaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAobHNvblRvSnNvbik7XG59XG5mdW5jdGlvbiBsaXZlTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUudG9BcnJheSgpKTtcbn1cbmZ1bmN0aW9uIGxzb25Ub0pzb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiBsaXZlT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIGxpdmVMaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4gbGl2ZU1hcFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBMaXZlaWZ5KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3QodmFsdWUubWFwKGRlZXBMaXZlaWZ5KSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBjb25zdCBpbml0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlW2tleV07XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbml0W2tleV0gPSBkZWVwTGl2ZWlmeSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdmVPYmplY3QoaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVMaXN0KGxpdmVMaXN0LCBwcmV2LCBuZXh0KSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IHByZXZFbmQgPSBwcmV2Lmxlbmd0aCAtIDE7XG4gIGxldCBuZXh0RW5kID0gbmV4dC5sZW5ndGggLSAxO1xuICBsZXQgcHJldk5vZGUgPSBwcmV2WzBdO1xuICBsZXQgbmV4dE5vZGUgPSBuZXh0WzBdO1xuICBvdXRlcjoge1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgICsraTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICB9XG4gICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICBwcmV2RW5kLS07XG4gICAgICBuZXh0RW5kLS07XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgfVxuICB9XG4gIGlmIChpID4gcHJldkVuZCkge1xuICAgIGlmIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpID4gbmV4dEVuZCkge1xuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpIDw9IHByZXZFbmQgJiYgaSA8PSBuZXh0RW5kKSB7XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgICBjb25zdCBsaXZlTGlzdE5vZGUgPSBsaXZlTGlzdC5nZXQoaSk7XG4gICAgICBpZiAoaXNMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChuZXh0Tm9kZSkpIHtcbiAgICAgICAgcGF0Y2hMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSwgcHJldk5vZGUsIG5leHROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpdmVMaXN0LnNldChpLCBkZWVwTGl2ZWlmeShuZXh0Tm9kZSkpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0S2V5KGxpdmVPYmplY3QsIGtleSwgcHJldiwgbmV4dCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmV4dCk7XG4gICAgaWYgKG5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICBlcnJvcjIoXG4gICAgICAgIGBOZXcgc3RhdGUgcGF0aDogJyR7bm9uU2VyaWFsaXphYmxlVmFsdWUucGF0aH0nIHZhbHVlOiAnJHtTdHJpbmcoXG4gICAgICAgICAgbm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWVcbiAgICAgICAgKX0nIGlzIG5vdCBzZXJpYWxpemFibGUuXG5Pbmx5IHNlcmlhbGl6YWJsZSB2YWx1ZSBjYW4gYmUgc3luY2VkIHdpdGggTGl2ZWJsb2Nrcy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCB2YWx1ZSA9IGxpdmVPYmplY3QuZ2V0KGtleSk7XG4gIGlmIChuZXh0ID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LmRlbGV0ZShrZXkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfSBlbHNlIGlmIChwcmV2ID09PSBuZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzTGl2ZUxpc3QodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocHJldikgJiYgQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIHBhdGNoTGl2ZUxpc3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2UgaWYgKGlzTGl2ZU9iamVjdCh2YWx1ZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2KSAmJiBpc1BsYWluT2JqZWN0KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0KHJvb3QsIHByZXYsIG5leHQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0S2V5KHJvb3QsIGtleSwgcHJldltrZXldLCBuZXh0W2tleV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICBpZiAobmV4dFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHJvb3QuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyh1cGRhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgcm9vdC51cGRhdGUodXBkYXRlcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmVudHNQYXRoKG5vZGUpIHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICB3aGlsZSAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIGlmIChpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQubm9kZS5faW5kZXhPZlBvc2l0aW9uKG5vZGUucGFyZW50LmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQua2V5KTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Lm5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3Qoc3RhdGUsIHVwZGF0ZXMpIHtcbiAgcmV0dXJuIHVwZGF0ZXMucmVkdWNlKFxuICAgIChzdGF0ZTIsIHVwZGF0ZSkgPT4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZTIsIHVwZGF0ZSksXG4gICAgc3RhdGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoID0gZ2V0UGFyZW50c1BhdGgodXBkYXRlLm5vZGUpO1xuICByZXR1cm4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoSXRlbSA9IHBhdGgucG9wKCk7XG4gIGlmIChwYXRoSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcIkxpdmVPYmplY3RcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU9iamVjdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVMaXN0XCI6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTGlzdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBhcnJheVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3U3RhdGUgPSBzdGF0ZS5tYXAoKHgpID0+IHgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RVcGRhdGUgb2YgdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLm1hcChcbiAgICAgICAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpbmRleCA9PT0gbGlzdFVwZGF0ZS5pbmRleCA/IGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSA6IGl0ZW1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLmluZGV4ID09PSBuZXdTdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUucHVzaChsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNwbGljZShsaXN0VXBkYXRlLmluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggPiBsaXN0VXBkYXRlLmluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4LCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUuaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTWFwXCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVNYXAgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbLi4uc3RhdGVdO1xuICAgIG5ld0FycmF5W3BhdGhJdGVtXSA9IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoXG4gICAgICBzdGF0ZVtwYXRoSXRlbV0sXG4gICAgICBwYXRoLFxuICAgICAgdXBkYXRlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0gZWxzZSBpZiAoaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZVtwYXRoSXRlbV07XG4gICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZUFzT2JqID0gc3RhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZUFzT2JqLFxuICAgICAgICBbcGF0aEl0ZW1dOiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKG5vZGUsIHBhdGgsIHVwZGF0ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2RlcHJlY2F0aW9uLnRzXG52YXIgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIV9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoa2V5KSkge1xuICAgICAgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgZXJyb3JXaXRoVGl0bGUoXCJEZXByZWNhdGlvbiB3YXJuaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBkZXByZWNhdGUobWVzc2FnZSwga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB1c2FnZUVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHVzYWdlRXJyb3IubmFtZSA9IFwiVXNhZ2UgZXJyb3JcIjtcbiAgICBlcnJvcldpdGhUaXRsZShcIlVzYWdlIGVycm9yXCIsIG1lc3NhZ2UpO1xuICAgIHRocm93IHVzYWdlRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySWYoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9saWIvUG9sbGVyLnRzXG5mdW5jdGlvbiBtYWtlUG9sbGVyKGNhbGxiYWNrLCBpbnRlcnZhbCkge1xuICBsZXQgY29udGV4dCA9IHsgc3RhdGU6IFwic3RvcHBlZFwiIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZSgpO1xuICAgIH1cbiAgICB2b2lkIGNhbGxiYWNrKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7IHN0YXRlOiBcInN0b3BwZWRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZShjb25kaXRpb24pIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBzdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5hYmxlXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iakEpIHx8ICFpc1BsYWluT2JqZWN0KG9iakIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgU3RvcFJldHJ5aW5nMiBhcyBTdG9wUmV0cnlpbmcsXG4gIFdlYnNvY2tldENsb3NlQ29kZXMsXG4gIGFja09wLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYXV0b1JldHJ5LFxuICBiNjRkZWNvZGUsXG4gIGNodW5rLFxuICBjbG9uZUxzb24sXG4gIGNvbXBhY3RPYmplY3QsXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRJZCxcbiAgY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCxcbiAgY3JlYXRlU3RvcmUsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGtJbnRlcm5hbCxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbWFwVmFsdWVzLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBuYW5vaWQsXG4gIG5uLFxuICBvYmplY3RUb1F1ZXJ5LFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHJhaXNlLFxuICBzaGFsbG93LFxuICBzdHJpbmdpZnksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5LFxuICB0aHJvd1VzYWdlRXJyb3IsXG4gIHRvUGxhaW5Mc29uLFxuICB0cnlQYXJzZUpzb24sXG4gIHVybCxcbiAgdXJsam9pbixcbiAgd2FpdCxcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-V7FAMENR.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-V7FAMENR.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   CreateThreadError: () => (/* binding */ CreateThreadError),\n/* harmony export */   LiveblocksProvider: () => (/* binding */ LiveblocksProvider),\n/* harmony export */   PKG_FORMAT: () => (/* binding */ PKG_FORMAT),\n/* harmony export */   PKG_NAME: () => (/* binding */ PKG_NAME),\n/* harmony export */   PKG_VERSION: () => (/* binding */ PKG_VERSION),\n/* harmony export */   RoomContext: () => (/* binding */ RoomContext),\n/* harmony export */   _RoomProvider: () => (/* binding */ _RoomProvider),\n/* harmony export */   _useAddReaction: () => (/* binding */ _useAddReaction),\n/* harmony export */   _useBroadcastEvent: () => (/* binding */ _useBroadcastEvent),\n/* harmony export */   _useCreateThread: () => (/* binding */ _useCreateThread),\n/* harmony export */   _useDeleteThread: () => (/* binding */ _useDeleteThread),\n/* harmony export */   _useEditThreadMetadata: () => (/* binding */ _useEditThreadMetadata),\n/* harmony export */   _useEventListener: () => (/* binding */ _useEventListener),\n/* harmony export */   _useHistoryVersions: () => (/* binding */ _useHistoryVersions),\n/* harmony export */   _useHistoryVersionsSuspense: () => (/* binding */ _useHistoryVersionsSuspense),\n/* harmony export */   _useInboxNotificationThread: () => (/* binding */ _useInboxNotificationThread),\n/* harmony export */   _useIsInsideRoom: () => (/* binding */ _useIsInsideRoom),\n/* harmony export */   _useMutation: () => (/* binding */ _useMutation),\n/* harmony export */   _useMyPresence: () => (/* binding */ _useMyPresence),\n/* harmony export */   _useOther: () => (/* binding */ _useOther),\n/* harmony export */   _useOtherSuspense: () => (/* binding */ _useOtherSuspense),\n/* harmony export */   _useOthers: () => (/* binding */ _useOthers),\n/* harmony export */   _useOthersListener: () => (/* binding */ _useOthersListener),\n/* harmony export */   _useOthersMapped: () => (/* binding */ _useOthersMapped),\n/* harmony export */   _useOthersMappedSuspense: () => (/* binding */ _useOthersMappedSuspense),\n/* harmony export */   _useOthersSuspense: () => (/* binding */ _useOthersSuspense),\n/* harmony export */   _useRoom: () => (/* binding */ _useRoom),\n/* harmony export */   _useSelf: () => (/* binding */ _useSelf),\n/* harmony export */   _useSelfSuspense: () => (/* binding */ _useSelfSuspense),\n/* harmony export */   _useStorage: () => (/* binding */ _useStorage),\n/* harmony export */   _useStorageRoot: () => (/* binding */ _useStorageRoot),\n/* harmony export */   _useStorageSuspense: () => (/* binding */ _useStorageSuspense),\n/* harmony export */   _useThreads: () => (/* binding */ _useThreads),\n/* harmony export */   _useThreadsSuspense: () => (/* binding */ _useThreadsSuspense),\n/* harmony export */   _useUpdateMyPresence: () => (/* binding */ _useUpdateMyPresence),\n/* harmony export */   _useUser: () => (/* binding */ _useUser),\n/* harmony export */   _useUserSuspense: () => (/* binding */ _useUserSuspense),\n/* harmony export */   _useUserThreadsSuspense_experimental: () => (/* binding */ _useUserThreadsSuspense_experimental),\n/* harmony export */   _useUserThreads_experimental: () => (/* binding */ _useUserThreads_experimental),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   getUmbrellaStoreForClient: () => (/* binding */ getUmbrellaStoreForClient),\n/* harmony export */   selectThreads: () => (/* binding */ selectThreads),\n/* harmony export */   useAttachmentUrl: () => (/* binding */ useAttachmentUrl),\n/* harmony export */   useAttachmentUrlSuspense: () => (/* binding */ useAttachmentUrlSuspense),\n/* harmony export */   useBatch: () => (/* binding */ useBatch),\n/* harmony export */   useCanRedo: () => (/* binding */ useCanRedo),\n/* harmony export */   useCanUndo: () => (/* binding */ useCanUndo),\n/* harmony export */   useClient: () => (/* binding */ useClient),\n/* harmony export */   useCommentsErrorListener: () => (/* binding */ useCommentsErrorListener),\n/* harmony export */   useCreateComment: () => (/* binding */ useCreateComment),\n/* harmony export */   useDeleteAllInboxNotifications: () => (/* binding */ useDeleteAllInboxNotifications),\n/* harmony export */   useDeleteComment: () => (/* binding */ useDeleteComment),\n/* harmony export */   useDeleteInboxNotification: () => (/* binding */ useDeleteInboxNotification),\n/* harmony export */   useEditComment: () => (/* binding */ useEditComment),\n/* harmony export */   useErrorListener: () => (/* binding */ useErrorListener),\n/* harmony export */   useHistory: () => (/* binding */ useHistory),\n/* harmony export */   useHistoryVersionData: () => (/* binding */ useHistoryVersionData),\n/* harmony export */   useInboxNotifications: () => (/* binding */ useInboxNotifications),\n/* harmony export */   useInboxNotificationsSuspense: () => (/* binding */ useInboxNotificationsSuspense),\n/* harmony export */   useLostConnectionListener: () => (/* binding */ useLostConnectionListener),\n/* harmony export */   useMarkAllInboxNotificationsAsRead: () => (/* binding */ useMarkAllInboxNotificationsAsRead),\n/* harmony export */   useMarkInboxNotificationAsRead: () => (/* binding */ useMarkInboxNotificationAsRead),\n/* harmony export */   useMarkThreadAsRead: () => (/* binding */ useMarkThreadAsRead),\n/* harmony export */   useMarkThreadAsResolved: () => (/* binding */ useMarkThreadAsResolved),\n/* harmony export */   useMarkThreadAsUnresolved: () => (/* binding */ useMarkThreadAsUnresolved),\n/* harmony export */   useOthersConnectionIds: () => (/* binding */ useOthersConnectionIds),\n/* harmony export */   useOthersConnectionIdsSuspense: () => (/* binding */ useOthersConnectionIdsSuspense),\n/* harmony export */   useRedo: () => (/* binding */ useRedo),\n/* harmony export */   useRemoveReaction: () => (/* binding */ useRemoveReaction),\n/* harmony export */   useRoomInfo: () => (/* binding */ useRoomInfo),\n/* harmony export */   useRoomInfoSuspense: () => (/* binding */ useRoomInfoSuspense),\n/* harmony export */   useRoomNotificationSettings: () => (/* binding */ useRoomNotificationSettings),\n/* harmony export */   useStatus: () => (/* binding */ useStatus),\n/* harmony export */   useStorageStatus: () => (/* binding */ useStorageStatus),\n/* harmony export */   useStorageStatusSuspense: () => (/* binding */ useStorageStatusSuspense),\n/* harmony export */   useThreadSubscription: () => (/* binding */ useThreadSubscription),\n/* harmony export */   useUndo: () => (/* binding */ useUndo),\n/* harmony export */   useUnreadInboxNotificationsCount: () => (/* binding */ useUnreadInboxNotificationsCount),\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: () => (/* binding */ useUnreadInboxNotificationsCountSuspense),\n/* harmony export */   useUpdateRoomNotificationSettings: () => (/* binding */ useUpdateRoomNotificationSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"2.9.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n  const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setMounted(true);\n  }, []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: props.fallback }, mounted ? typeof props.children === \"function\" ? props.children() : props.children : props.fallback);\n}\n\n// src/contexts.ts\n\nvar RoomContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomOrNull() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n}\nfunction useIsInsideRoom() {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n\n// src/umbrella-store.ts\n\n\n// src/lib/autobind.ts\nfunction autobind(self) {\n  const seen = /* @__PURE__ */ new Set();\n  seen.add(\"constructor\");\n  let obj = self.constructor.prototype;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        self[key] = self[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n}\n\n// src/lib/compare.ts\nfunction byFirstCreated(a, b) {\n  return a.createdAt.getTime() - b.createdAt.getTime();\n}\nfunction isMoreRecentlyUpdated(a, b) {\n  return byMostRecentlyUpdated(a, b) < 0;\n}\nfunction byMostRecentlyUpdated(a, b) {\n  return (b.updatedAt ?? b.createdAt).getTime() - (a.updatedAt ?? a.createdAt).getTime();\n}\n\n// src/lib/guards.ts\n\nfunction isStartsWith(blob) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(blob) && isString(blob.startsWith);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n// src/lib/querying.ts\nfunction makeThreadsFilter(query) {\n  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);\n}\nfunction matchesQuery(thread, q) {\n  return q.resolved === void 0 || thread.resolved === q.resolved;\n}\nfunction matchesMetadata(thread, q) {\n  const metadata = thread.metadata;\n  return q.metadata === void 0 || Object.entries(q.metadata).every(\n    ([key, op]) => (\n      // Boolean logic: op? => value matches the operator\n      op === void 0 || matchesOperator(metadata[key], op)\n    )\n  );\n}\nfunction matchesOperator(value, op) {\n  if (isStartsWith(op)) {\n    return isString(value) && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n\n// src/umbrella-store.ts\nvar ASYNC_OK = Object.freeze({ isLoading: false, data: void 0 });\nfunction makeRoomThreadsQueryKey(roomId, query) {\n  return `${roomId}-${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stringify)(query ?? {})}`;\n}\nfunction makeUserThreadsQueryKey(query) {\n  return `USER_THREADS:${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stringify)(query ?? {})}`;\n}\nfunction makeNotificationSettingsQueryKey(roomId) {\n  return `${roomId}:NOTIFICATION_SETTINGS`;\n}\nfunction makeVersionsQueryKey(roomId) {\n  return `${roomId}-VERSIONS`;\n}\nfunction selectThreads(state, options) {\n  let threads = state.threads;\n  if (options.roomId !== null) {\n    threads = threads.filter((thread) => thread.roomId === options.roomId);\n  }\n  const query = options.query;\n  if (query) {\n    threads = threads.filter(makeThreadsFilter(query));\n  }\n  return threads.sort(\n    options.orderBy === \"last-update\" ? byMostRecentlyUpdated : byFirstCreated\n  );\n}\nfunction usify(promise) {\n  if (\"status\" in promise) {\n    return promise;\n  }\n  const usable = promise;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      usable.value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      usable.reason = err;\n    }\n  );\n  return usable;\n}\nvar noop = Promise.resolve();\nvar ASYNC_LOADING = Object.freeze({ isLoading: true });\nvar PaginatedResource = class {\n  constructor(fetchPage) {\n    this._cachedPromise = null;\n    this._paginationState = null;\n    this._fetchPage = fetchPage;\n    this._eventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makeEventSource)();\n    this._pendingFetchMore = null;\n    this.observable = this._eventSource.observable;\n    autobind(this);\n  }\n  patchPaginationState(patch) {\n    const state = this._paginationState;\n    if (state === null) return;\n    this._paginationState = { ...state, ...patch };\n    this._eventSource.notify();\n  }\n  async _fetchMore() {\n    const state = this._paginationState;\n    if (!state?.cursor) {\n      return;\n    }\n    this.patchPaginationState({ isFetchingMore: true });\n    try {\n      const nextCursor = await this._fetchPage(state.cursor);\n      this.patchPaginationState({\n        cursor: nextCursor,\n        fetchMoreError: void 0,\n        isFetchingMore: false\n      });\n    } catch (err) {\n      this.patchPaginationState({\n        isFetchingMore: false,\n        fetchMoreError: err\n      });\n    }\n  }\n  fetchMore() {\n    const state = this._paginationState;\n    if (state?.cursor === null) {\n      return noop;\n    }\n    if (!this._pendingFetchMore) {\n      this._pendingFetchMore = this._fetchMore().finally(() => {\n        this._pendingFetchMore = null;\n      });\n    }\n    return this._pendingFetchMore;\n  }\n  get() {\n    const usable = this._cachedPromise;\n    if (usable === null || usable.status === \"pending\") {\n      return ASYNC_LOADING;\n    }\n    if (usable.status === \"rejected\") {\n      return { isLoading: false, error: usable.reason };\n    }\n    const state = this._paginationState;\n    return {\n      isLoading: false,\n      data: {\n        fetchMore: this.fetchMore,\n        isFetchingMore: state.isFetchingMore,\n        fetchMoreError: state.fetchMoreError,\n        hasFetchedAll: state.cursor === null\n      }\n    };\n  }\n  waitUntilLoaded() {\n    if (this._cachedPromise) {\n      return this._cachedPromise;\n    }\n    const initialFetcher = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(\n      () => this._fetchPage(\n        /* cursor */\n        void 0\n      ),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(\n      initialFetcher.then((cursor) => {\n        this._paginationState = {\n          cursor,\n          isFetchingMore: false,\n          fetchMoreError: void 0\n        };\n      })\n    );\n    promise.then(\n      () => this._eventSource.notify(),\n      () => {\n        this._eventSource.notify();\n        setTimeout(() => {\n          this._cachedPromise = null;\n          this._eventSource.notify();\n        }, 5e3);\n      }\n    );\n    this._cachedPromise = promise;\n    return promise;\n  }\n};\nvar UmbrellaStore = class {\n  constructor(client) {\n    this._prevState = null;\n    this._stateCached = null;\n    // Notifications\n    this._notificationsLastRequestedAt = null;\n    // Room Threads\n    this._roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    this._roomThreads = /* @__PURE__ */ new Map();\n    // User Threads\n    this._userThreadsLastRequestedAt = null;\n    this._userThreads = /* @__PURE__ */ new Map();\n    const inboxFetcher = async (cursor) => {\n      if (client === void 0) {\n        throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.StopRetrying(\n          \"Client is required in order to load threads for the room\"\n        );\n      }\n      const result = await client.getInboxNotifications({ cursor });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        // TODO: Figure out how to remove this casting\n        result.inboxNotifications\n      );\n      if (this._notificationsLastRequestedAt === null) {\n        this._notificationsLastRequestedAt = result.requestedAt;\n      }\n      const nextCursor = result.nextCursor;\n      return nextCursor;\n    };\n    this._client = client;\n    this._notifications = new PaginatedResource(inboxFetcher);\n    this._notifications.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._store = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createStore)({\n      rawThreadsById: {},\n      queries3: {},\n      queries4: {},\n      optimisticUpdates: [],\n      notificationsById: {},\n      settingsByRoomId: {},\n      versionsByRoomId: {}\n    });\n    autobind(this);\n  }\n  get() {\n    const rawState = this._store.get();\n    if (this._prevState !== rawState || this._stateCached === null) {\n      this._prevState = rawState;\n      this._stateCached = internalToExternalState(rawState);\n    }\n    return this._stateCached;\n  }\n  batch(callback) {\n    return this._store.batch(callback);\n  }\n  getFullState() {\n    return this.get();\n  }\n  /**\n   * Returns the async result of the given query and room id. If the query is success,\n   * then it will return the threads that match that provided query and room id.\n   *\n   */\n  // XXXX Find a better name for that doesn't associate to 'async'\n  getRoomThreadsAsync(roomId, query) {\n    const queryKey = makeRoomThreadsQueryKey(roomId, query);\n    const paginatedResource = this._roomThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = paginatedResource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const threads = selectThreads(this.getFullState(), {\n      roomId,\n      query,\n      orderBy: \"age\"\n    });\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      threads,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // XXXX - Find a better name for that doesn't associate to 'async'\n  getUserThreadsAsync(query) {\n    const queryKey = makeUserThreadsQueryKey(query);\n    const paginatedResource = this._userThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = paginatedResource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const threads = selectThreads(this.getFullState(), {\n      roomId: null,\n      // Do _not_ filter by roomId\n      query,\n      orderBy: \"last-update\"\n    });\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      threads,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // NOTE: This will read the async result, but WILL NOT start loading at the moment!\n  // XXXX - Find a better name for that doesn't associate to 'async'\n  getInboxNotificationsAsync() {\n    const asyncResult = this._notifications.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      inboxNotifications: this.getFullState().notifications,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // NOTE: This will read the async result, but WILL NOT start loading at the moment!\n  getNotificationSettingsAsync(roomId) {\n    const state = this.get();\n    const query = state.queries3[makeNotificationSettingsQueryKey(roomId)];\n    if (query === void 0 || query.isLoading) {\n      return ASYNC_LOADING;\n    }\n    if (query.error !== void 0) {\n      return query;\n    }\n    return {\n      isLoading: false,\n      settings: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(state.settingsByRoomId[roomId])\n    };\n  }\n  getVersionsAsync(roomId) {\n    const state = this.get();\n    const query = state.queries4[makeVersionsQueryKey(roomId)];\n    if (query === void 0 || query.isLoading) {\n      return ASYNC_LOADING;\n    }\n    if (query.error !== void 0) {\n      return query;\n    }\n    return {\n      isLoading: false,\n      versions: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(state.versionsByRoomId[roomId])\n    };\n  }\n  /**\n   * @private Only used by the E2E test suite.\n   */\n  _hasOptimisticUpdates() {\n    return this._store.get().optimisticUpdates.length > 0;\n  }\n  subscribe(callback) {\n    return this._store.subscribe(callback);\n  }\n  /**\n   * @private Only used by the E2E test suite.\n   */\n  _subscribeOptimisticUpdates(callback) {\n    return this.subscribe(callback);\n  }\n  subscribeThreads(callback) {\n    return this.subscribe(callback);\n  }\n  subscribeUserThreads(callback) {\n    return this.subscribe(callback);\n  }\n  subscribeThreadsOrInboxNotifications(callback) {\n    return this.subscribe(callback);\n  }\n  subscribeNotificationSettings(callback) {\n    return this.subscribe(callback);\n  }\n  subscribeVersions(callback) {\n    return this.subscribe(callback);\n  }\n  // Direct low-level cache mutations ------------------------------------------------- {{{\n  updateThreadsCache(mapFn) {\n    this._store.set((state) => {\n      const threads = mapFn(state.rawThreadsById);\n      return threads !== state.rawThreadsById ? { ...state, rawThreadsById: threads } : state;\n    });\n  }\n  updateInboxNotificationsCache(mapFn) {\n    this._store.set((state) => {\n      const inboxNotifications = mapFn(state.notificationsById);\n      return inboxNotifications !== state.notificationsById ? { ...state, notificationsById: inboxNotifications } : state;\n    });\n  }\n  setNotificationSettings(roomId, settings) {\n    this._store.set((state) => ({\n      ...state,\n      settingsByRoomId: {\n        ...state.settingsByRoomId,\n        [roomId]: settings\n      }\n    }));\n  }\n  setVersions(roomId, versions) {\n    this._store.set((state) => ({\n      ...state,\n      versionsByRoomId: {\n        ...state.versionsByRoomId,\n        [roomId]: versions\n      }\n    }));\n  }\n  setQuery3State(queryKey, queryState) {\n    this._store.set((state) => ({\n      ...state,\n      queries3: {\n        ...state.queries3,\n        [queryKey]: queryState\n      }\n    }));\n  }\n  setQuery4State(queryKey, queryState) {\n    this._store.set((state) => ({\n      ...state,\n      queries4: {\n        ...state.queries4,\n        [queryKey]: queryState\n      }\n    }));\n  }\n  updateOptimisticUpdatesCache(mapFn) {\n    this._store.set((state) => ({\n      ...state,\n      optimisticUpdates: mapFn(state.optimisticUpdates)\n    }));\n  }\n  // ---------------------------------------------------------------------------------- }}}\n  /** @internal - Only call this method from unit tests. */\n  force_set(callback) {\n    return this._store.set(callback);\n  }\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found in\n   * the cache.\n   */\n  updateInboxNotification(inboxNotificationId, optimisticUpdateId, callback) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => {\n        const existing = cache[inboxNotificationId];\n        if (!existing) {\n          return cache;\n        }\n        const inboxNotifications = {\n          ...cache,\n          [inboxNotificationId]: callback(existing)\n        };\n        return inboxNotifications;\n      });\n    });\n  }\n  /**\n   * Updates *all* inbox notifications by running a mapper function over all of\n   * them, replacing the corresponding optimistic update.\n   */\n  updateAllInboxNotifications(optimisticUpdateId, mapFn) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.mapValues)(cache, mapFn));\n    });\n  }\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  deleteInboxNotification(inboxNotificationId, optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => {\n        const { [inboxNotificationId]: removed, ...newCache } = cache;\n        return removed === void 0 ? cache : newCache;\n      });\n    });\n  }\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  deleteAllInboxNotifications(optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache(() => ({}));\n    });\n  }\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  createThread(optimisticUpdateId, thread) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateThreadsCache((cache) => ({ ...cache, [thread.id]: thread }));\n    });\n  }\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found in the cache; or\n   * - The thread ID was already deleted from the cache; or\n   * - The thread ID in the cache was updated more recently than the optimistic\n   *   update's timestamp (if given)\n   */\n  updateThread(threadId, optimisticUpdateId, callback, updatedAt) {\n    this._store.batch(() => {\n      if (optimisticUpdateId !== null) {\n        this.removeOptimisticUpdate(optimisticUpdateId);\n      }\n      this.updateThreadsCache((cache) => {\n        const existing = cache[threadId];\n        if (!existing) {\n          return cache;\n        }\n        if (existing.deletedAt !== void 0) {\n          return cache;\n        }\n        if (!!updatedAt && !!existing.updatedAt && existing.updatedAt > updatedAt) {\n          return cache;\n        }\n        return { ...cache, [threadId]: callback(existing) };\n      });\n    });\n  }\n  patchThread(threadId, optimisticUpdateId, patch, updatedAt) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => ({ ...thread, ...(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.compactObject)(patch) }),\n      updatedAt\n    );\n  }\n  addReaction(threadId, optimisticUpdateId, commentId, reaction, createdAt) {\n    this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n  removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt) {\n    this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found in the cache; or\n   * - The thread ID was already deleted from the cache\n   */\n  deleteThread(threadId, optimisticUpdateId) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })\n    );\n  }\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  createComment(newComment, optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      const existingThread = this._store.get().rawThreadsById[newComment.threadId];\n      if (!existingThread) {\n        return;\n      }\n      this.updateThreadsCache((cache) => ({\n        ...cache,\n        [newComment.threadId]: applyUpsertComment(existingThread, newComment)\n      }));\n      this.updateInboxNotificationsCache((cache) => {\n        const existingNotification = Object.values(cache).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === newComment.threadId\n        );\n        if (!existingNotification) {\n          return cache;\n        }\n        return {\n          ...cache,\n          [existingNotification.id]: {\n            ...existingNotification,\n            notifiedAt: newComment.createdAt,\n            readAt: newComment.createdAt\n          }\n        };\n      });\n    });\n  }\n  editComment(threadId, optimisticUpdateId, editedComment) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyUpsertComment(thread, editedComment)\n    );\n  }\n  deleteComment(threadId, optimisticUpdateId, commentId, deletedAt) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n  updateThreadAndNotification(thread, inboxNotification) {\n    this._store.batch(() => {\n      this.updateThreadsCache((cache) => {\n        const existingThread = cache[thread.id];\n        return existingThread === void 0 || isMoreRecentlyUpdated(thread, existingThread) ? { ...cache, [thread.id]: thread } : cache;\n      });\n      if (inboxNotification !== void 0) {\n        this.updateInboxNotificationsCache((cache) => ({\n          ...cache,\n          [inboxNotification.id]: inboxNotification\n        }));\n      }\n    });\n  }\n  updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads = [], deletedInboxNotifications = []) {\n    this._store.batch(() => {\n      this.updateThreadsCache(\n        (cache) => applyThreadUpdates(cache, {\n          newThreads: threads,\n          deletedThreads\n        })\n      );\n      this.updateInboxNotificationsCache(\n        (cache) => applyNotificationsUpdates(cache, {\n          newInboxNotifications: inboxNotifications,\n          deletedNotifications: deletedInboxNotifications\n        })\n      );\n    });\n  }\n  /**\n   * Updates existing notification setting for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  // XXXX Rename this helper method\n  updateRoomInboxNotificationSettings2(roomId, optimisticUpdateId, settings) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.setNotificationSettings(roomId, settings);\n    });\n  }\n  // XXXX Rename this helper method\n  updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n    this._store.batch(() => {\n      this.setQuery3OK(queryKey);\n      this.setNotificationSettings(roomId, settings);\n    });\n  }\n  updateRoomVersions(roomId, versions, queryKey) {\n    this._store.batch(() => {\n      this.setVersions(roomId, versions);\n      if (queryKey !== void 0) {\n        this.setQuery4OK(queryKey);\n      }\n    });\n  }\n  addOptimisticUpdate(optimisticUpdate) {\n    const id = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nanoid)();\n    const newUpdate = { ...optimisticUpdate, id };\n    this.updateOptimisticUpdatesCache((cache) => [...cache, newUpdate]);\n    return id;\n  }\n  removeOptimisticUpdate(optimisticUpdateId) {\n    this.updateOptimisticUpdatesCache(\n      (cache) => cache.filter((ou) => ou.id !== optimisticUpdateId)\n    );\n  }\n  // Query 3\n  setQuery3Loading(queryKey) {\n    this.setQuery3State(queryKey, ASYNC_LOADING);\n  }\n  setQuery3OK(queryKey) {\n    this.setQuery3State(queryKey, ASYNC_OK);\n  }\n  setQuery3Error(queryKey, error) {\n    this.setQuery3State(queryKey, { isLoading: false, error });\n  }\n  // Query 4\n  setQuery4Loading(queryKey) {\n    this.setQuery4State(queryKey, ASYNC_LOADING);\n  }\n  setQuery4OK(queryKey) {\n    this.setQuery4State(queryKey, ASYNC_OK);\n  }\n  setQuery4Error(queryKey, error) {\n    this.setQuery4State(queryKey, { isLoading: false, error });\n  }\n  async fetchNotificationsDeltaUpdate() {\n    const lastRequestedAt = this._notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\"Notifications polled before first page loaded\");\n      return;\n    }\n    const client = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this._client,\n      \"Client is required in order to load notifications for the room\"\n    );\n    const result = await client.getInboxNotificationsSince(lastRequestedAt);\n    if (lastRequestedAt < result.requestedAt) {\n      this._notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadsAndNotifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  waitUntilNotificationsLoaded() {\n    return this._notifications.waitUntilLoaded();\n  }\n  waitUntilRoomThreadsLoaded(roomId, query) {\n    const threadsFetcher = async (cursor) => {\n      if (this._client === void 0) {\n        throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.StopRetrying(\n          \"Client is required in order to load threads for the room\"\n        );\n      }\n      const room = this._client.getRoom(roomId);\n      if (room === null) {\n        throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.StopRetrying(\n          `Room with id ${roomId} is not available on client`\n        );\n      }\n      const result = await room.getThreads({ cursor, query });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        // TODO: Figure out how to remove this casting\n        result.inboxNotifications\n      );\n      const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);\n      if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n        this._roomThreadsLastRequestedAtByRoom.set(roomId, result.requestedAt);\n      }\n      return result.nextCursor;\n    };\n    const queryKey = makeRoomThreadsQueryKey(roomId, query);\n    let paginatedResource = this._roomThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      paginatedResource = new PaginatedResource(threadsFetcher);\n    }\n    paginatedResource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomThreads.set(queryKey, paginatedResource);\n    return paginatedResource.waitUntilLoaded();\n  }\n  async fetchRoomThreadsDeltaUpdate(roomId) {\n    const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\"Room threads polled before first page loaded\");\n      return;\n    }\n    const client = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this._client,\n      \"Client is required in order to load notifications for the room\"\n    );\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room.getThreadsSince({\n      since: lastRequestedAt\n    });\n    this.updateThreadsAndNotifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted\n    );\n    if (lastRequestedAt < updates.requestedAt) {\n      this._roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  waitUntilUserThreadsLoaded(query) {\n    const queryKey = makeUserThreadsQueryKey(query);\n    const threadsFetcher = async (cursor) => {\n      if (this._client === void 0) {\n        throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.StopRetrying(\n          \"Client is required in order to load threads for the room\"\n        );\n      }\n      const result = await this._client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getUserThreads_experimental({\n        cursor,\n        query\n      });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        // TODO: Figure out how to remove this casting\n        result.inboxNotifications\n      );\n      if (this._userThreadsLastRequestedAt === null) {\n        this._userThreadsLastRequestedAt = result.requestedAt;\n      }\n      return result.nextCursor;\n    };\n    let paginatedResource = this._userThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      paginatedResource = new PaginatedResource(threadsFetcher);\n    }\n    paginatedResource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._userThreads.set(queryKey, paginatedResource);\n    return paginatedResource.waitUntilLoaded();\n  }\n  async fetchUserThreadsDeltaUpdate() {\n    const lastRequestedAt = this._userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\"User threads polled before first page loaded\");\n      return;\n    }\n    const client = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this._client,\n      \"Client is required in order to load threads for the user\"\n    );\n    const result = await client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getUserThreadsSince_experimental({\n      since: lastRequestedAt\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this._notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadsAndNotifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n};\nfunction internalToExternalState(state) {\n  const computed = {\n    threadsById: { ...state.rawThreadsById },\n    notificationsById: { ...state.notificationsById },\n    settingsByRoomId: { ...state.settingsByRoomId }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        computed.threadsById[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        computed.threadsById[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = {\n          ...thread,\n          resolved: true\n        };\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = {\n          ...thread,\n          resolved: false\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = computed.threadsById[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = applyUpsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(\n          computed.notificationsById\n        ).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        computed.notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = computed.threadsById[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = applyUpsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = applyDeleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        computed.threadsById[optimisticUpdate.threadId] = {\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        };\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = applyAddReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = computed.threadsById[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        computed.threadsById[thread.id] = applyRemoveReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = computed.notificationsById[optimisticUpdate.inboxNotificationId];\n        if (ibn === void 0) {\n          break;\n        }\n        computed.notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in computed.notificationsById) {\n          const ibn = computed.notificationsById[id];\n          if (ibn === void 0) {\n            break;\n          }\n          computed.notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete computed.notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        computed.notificationsById = {};\n        break;\n      }\n      case \"update-notification-settings\": {\n        const settings = computed.settingsByRoomId[optimisticUpdate.roomId];\n        if (settings === void 0) {\n          break;\n        }\n        computed.settingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  const cleanedThreads = (\n    // Don't expose any soft-deleted threads\n    Object.values(computed.threadsById).filter((thread) => !thread.deletedAt).filter(\n      (thread) => (\n        // Only keep a thread if there is at least one non-deleted comment\n        thread.comments.some((c) => c.deletedAt === void 0)\n      )\n    )\n  );\n  const cleanedNotifications = (\n    // Sort so that the most recent notifications are first\n    Object.values(computed.notificationsById).filter(\n      (ibn) => ibn.kind === \"thread\" ? computed.threadsById[ibn.threadId] && computed.threadsById[ibn.threadId]?.deletedAt === void 0 : true\n    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())\n  );\n  return {\n    notifications: cleanedNotifications,\n    notificationsById: computed.notificationsById,\n    settingsByRoomId: computed.settingsByRoomId,\n    queries3: state.queries3,\n    queries4: state.queries4,\n    threads: cleanedThreads,\n    threadsById: computed.threadsById,\n    versionsByRoomId: state.versionsByRoomId\n  };\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      if (isMoreRecentlyUpdated(existingThread, thread)) {\n        return;\n      }\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0) return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction applyUpsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction applyDeleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      // We optimistically remove the comment body and attachments when marking it as deleted\n      body: void 0,\n      attachments: []\n    } : comment\n  );\n  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction applyAddReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/liveblocks.tsx\n\n\n\n\n\n// src/lib/shallow2.ts\n\nfunction shallow2(a, b) {\n  if (!(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(a) || !(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(b)) {\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow)(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow)(a[key], b[key])\n  );\n}\n\n// src/lib/use-initial.ts\n\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop2 = (state) => state;\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(noop2, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/liveblocks.tsx\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nfunction identity(x) {\n  return x;\n}\nvar _umbrellaStores = /* @__PURE__ */ new WeakMap();\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nvar POLLING_INTERVAL = 60 * 1e3;\nfunction selectUnreadInboxNotificationsCount(inboxNotifications) {\n  let count = 0;\n  for (const notification of inboxNotifications) {\n    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction selectorFor_useUnreadInboxNotificationsCount(result) {\n  if (!result.inboxNotifications) {\n    return result;\n  }\n  return {\n    isLoading: false,\n    count: selectUnreadInboxNotificationsCount(result.inboxNotifications)\n  };\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getUmbrellaStoreForClient(client) {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store;\n}\nfunction getLiveblocksExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeDeltaPoller_Notifications(store) {\n  const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(async () => {\n    try {\n      await store.waitUntilNotificationsLoaded();\n      await store.fetchNotificationsDeltaUpdate();\n    } catch (err) {\n      console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n    }\n  }, POLLING_INTERVAL);\n  let pollerSubscribers = 0;\n  return () => {\n    pollerSubscribers++;\n    poller.enable(pollerSubscribers > 0);\n    return () => {\n      pollerSubscribers--;\n      poller.enable(pollerSubscribers > 0);\n    };\n  };\n}\nfunction makeDeltaPoller_UserThreads(store) {\n  const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(async () => {\n    try {\n      await store.fetchUserThreadsDeltaUpdate();\n    } catch (err) {\n      console.warn(`Polling new user threads failed: ${String(err)}`);\n    }\n  }, POLLING_INTERVAL);\n  let pollerSubscribers = 0;\n  return () => {\n    pollerSubscribers++;\n    poller.enable(pollerSubscribers > 0);\n    return () => {\n      pollerSubscribers--;\n      poller.enable(pollerSubscribers > 0);\n    };\n  };\n}\nfunction makeLiveblocksExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  return {\n    store,\n    /**\n     * Sub/unsub pair to start the process of watching for new incoming inbox\n     * notifications through a stream of delta updates. Call the unsub function\n     * returned to stop this subscription when unmounting. Currently\n     * implemented by a periodic poller.\n     */\n    subscribeToNotificationsDeltaUpdates: makeDeltaPoller_Notifications(store),\n    /**\n     * Sub/unsub pair to start the process of watching for new user threads\n     * through a stream of delta updates. Call the unsub function returned to\n     * stop this subscription when unmounting. Currently implemented by\n     * a periodic poller.\n     */\n    subscribeToUserThreadsDeltaUpdates: makeDeltaPoller_UserThreads(store)\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: client }, props.children);\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client, identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    useUserThreads_experimental,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client, selector, isEqual) {\n  const {\n    store,\n    subscribeToNotificationsDeltaUpdates: subscribeToDeltaUpdates\n  } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.waitUntilNotificationsLoaded().catch(() => {\n    });\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(subscribeToDeltaUpdates, [subscribeToDeltaUpdates]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeThreadsOrInboxNotifications,\n    store.getInboxNotificationsAsync,\n    store.getInboxNotificationsAsync,\n    selector,\n    isEqual\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.waitUntilNotificationsLoaded());\n  const result = useInboxNotifications_withClient(client, identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.waitUntilNotificationsLoaded());\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const readAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt\n      });\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.updateInboxNotification(\n            inboxNotificationId,\n            optimisticUpdateId,\n            (inboxNotification) => ({ ...inboxNotification, readAt })\n          );\n        },\n        () => {\n          store.removeOptimisticUpdate(optimisticUpdateId);\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = /* @__PURE__ */ new Date();\n    const optimisticUpdateId = store.addOptimisticUpdate({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt\n    });\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.updateAllInboxNotifications(\n          optimisticUpdateId,\n          (inboxNotification) => ({ ...inboxNotification, readAt })\n        );\n      },\n      () => {\n        store.removeOptimisticUpdate(optimisticUpdateId);\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt\n      });\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.deleteInboxNotification(\n            inboxNotificationId,\n            optimisticUpdateId\n          );\n        },\n        () => {\n          store.removeOptimisticUpdate(optimisticUpdateId);\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = /* @__PURE__ */ new Date();\n    const optimisticUpdateId = store.addOptimisticUpdate({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt\n    });\n    client.deleteAllInboxNotifications().then(\n      () => {\n        store.deleteAllInboxNotifications(optimisticUpdateId);\n      },\n      () => {\n        store.removeOptimisticUpdate(optimisticUpdateId);\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getLiveblocksExtrasForClient(client);\n  const getter = store.getFullState;\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(`Inbox notification with ID \"${inboxNotificationId}\" not found`);\n      if (inboxNotification.kind !== \"thread\") {\n        (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n        );\n      }\n      const thread = state.threadsById[inboxNotification.threadId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n        `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n      );\n      return thread;\n    },\n    [inboxNotificationId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeThreadsOrInboxNotifications,\n    // Re-evaluate if we need to update any time the notification changes over time\n    getter,\n    getter,\n    selector\n  );\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void usersStore.get(userId);\n  }, [usersStore, userId]);\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.get(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void roomsInfoStore.get(roomId);\n  }, [roomsInfoStore, roomId]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.get(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),\n      useIsInsideRoom\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),\n      useIsInsideRoom\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: props.client }, props.children);\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createClient)(options), []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client }, children);\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useUserThreads_experimental(options = {\n  query: {\n    metadata: {}\n  }\n}) {\n  const client = useClient();\n  const { store, subscribeToUserThreadsDeltaUpdates: subscribeToDeltaUpdates } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => {\n      void store.waitUntilUserThreadsLoaded(options.query).catch(() => {\n      });\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(subscribeToDeltaUpdates, [subscribeToDeltaUpdates]);\n  const getter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => store.getUserThreadsAsync(options.query),\n    [store, options.query]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeUserThreads,\n    getter,\n    getter,\n    identity,\n    shallow2\n    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!\n  );\n}\nfunction useUserThreadsSuspense_experimental(options = {\n  query: {\n    metadata: {}\n  }\n}) {\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient(client);\n  use(store.waitUntilUserThreadsLoaded(options.query));\n  const result = useUserThreads_experimental(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient(), identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\nvar _useUserThreads_experimental = useUserThreads_experimental;\nvar _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;\n\n// src/types/errors.ts\nvar CreateThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateThreadError\";\n  }\n};\nvar DeleteThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteThreadError\";\n  }\n};\nvar EditThreadMetadataError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit thread metadata failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditThreadMetadataError\";\n  }\n};\nvar MarkThreadAsResolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as resolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsResolvedError\";\n  }\n};\nvar MarkThreadAsUnresolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as unresolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsUnresolvedError\";\n  }\n};\nvar CreateCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateCommentError\";\n  }\n};\nvar EditCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditCommentError\";\n  }\n};\nvar DeleteCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteCommentError\";\n  }\n};\nvar AddReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Add reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"AddReactionError\";\n  }\n};\nvar RemoveReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Remove reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"RemoveReactionError\";\n  }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark inbox notification as read failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkInboxNotificationAsReadError\";\n  }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n  constructor(cause, context) {\n    super(\"Update notification settings failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"UpdateNotificationSettingsError\";\n  }\n};\n\n// src/room.tsx\n\n\n\n\n\n// src/lib/retry-error.ts\nvar MAX_ERROR_RETRY_COUNT = 5;\nvar ERROR_RETRY_INTERVAL = 5e3;\nfunction retryError(action, retryCount) {\n  if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n  setTimeout(() => {\n    void action();\n  }, timeout);\n}\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (!state.threads) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\nvar SMOOTH_DELAY = 1e3;\nvar noop3 = () => {\n};\nvar identity2 = (x) => x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n  roomId\n)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don\\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\\u2019re on React 18+ already.\";\nfunction useSyncExternalStore2(s, gs, gss) {\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(s, gs, gss, identity2);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nvar POLLING_INTERVAL2 = 5 * 60 * 1e3;\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(room) {\n  const self = room.getSelf();\n  if (self === null || self.id === void 0) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\nfunction handleApiError(err) {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join(\"\\n\");\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(detailedMessage);\n  }\n  return new Error(message);\n}\nfunction makeDeltaPoller_RoomThreads(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(async () => {\n    const roomIds = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getRoomIds();\n    await Promise.allSettled(\n      roomIds.map((roomId) => {\n        const room = client.getRoom(roomId);\n        if (room === null) return;\n        return store.fetchRoomThreadsDeltaUpdate(room.id);\n      })\n    );\n  }, POLLING_INTERVAL2);\n  let pollerSubscribers = 0;\n  return () => {\n    pollerSubscribers++;\n    poller.enable(pollerSubscribers > 0);\n    return () => {\n      pollerSubscribers--;\n      poller.enable(pollerSubscribers > 0);\n    };\n  };\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getRoomExtrasForClient(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeRoomExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const requestsByQuery = /* @__PURE__ */ new Map();\n  async function getRoomVersions(room, { retryCount } = { retryCount: 0 }) {\n    const queryKey = makeVersionsQueryKey(room.id);\n    const existingRequest = requestsByQuery.get(queryKey);\n    if (existingRequest !== void 0) return existingRequest;\n    const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersions();\n    requestsByQuery.set(queryKey, request);\n    store.setQuery4Loading(queryKey);\n    try {\n      const result = await request;\n      const data = await result.json();\n      const versions = data.versions.map(({ createdAt, ...version2 }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version2\n        };\n      });\n      store.updateRoomVersions(room.id, versions, queryKey);\n      requestsByQuery.delete(queryKey);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n      retryError(() => {\n        void getRoomVersions(room, {\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQuery4Error(queryKey, err);\n    }\n    return;\n  }\n  async function getInboxNotificationSettings(room, { retryCount } = { retryCount: 0 }) {\n    const queryKey = makeNotificationSettingsQueryKey(room.id);\n    const existingRequest = requestsByQuery.get(queryKey);\n    if (existingRequest !== void 0) return existingRequest;\n    try {\n      const request = room.getNotificationSettings();\n      requestsByQuery.set(queryKey, request);\n      store.setQuery3Loading(queryKey);\n      const settings = await request;\n      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n      retryError(() => {\n        void getInboxNotificationSettings(room, {\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQuery3Error(queryKey, err);\n    }\n    return;\n  }\n  const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makeEventSource)();\n  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n    store.removeOptimisticUpdate(optimisticUpdateId);\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.CommentsApiError) {\n      const error = handleApiError(innerError);\n      commentsErrorEventSource.notify(createPublicError(error));\n      return;\n    }\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.NotificationsApiError) {\n      handleApiError(innerError);\n      return;\n    }\n    throw innerError;\n  }\n  return {\n    store,\n    subscribeToRoomThreadsDeltaUpdates: makeDeltaPoller_RoomThreads(client),\n    commentsErrorEventSource,\n    getInboxNotificationSettings,\n    getRoomVersions,\n    onMutationFailure\n  };\n}\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProvider, { ...props }));\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n    useHistoryVersions,\n    useHistoryVersionData,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    },\n    useCommentsErrorListener\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (!isString(roomId)) {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const oldReactVersion = majorReactVersion < 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.errorIf)(\n      oldReactVersion && props.unstable_batchedUpdates === void 0,\n      missing_unstable_batchedUpdates(majorReactVersion, roomId)\n    );\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.deprecateIf)(\n      !oldReactVersion && props.unstable_batchedUpdates !== void 0,\n      superfluous_unstable_batchedUpdates\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    unstable_batchedUpdates: props.unstable_batchedUpdates,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { store } = getRoomExtrasForClient(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const info = await room.getThread(message.threadId);\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const { thread, inboxNotification } = info;\n      const existingThread = store.getFullState().threadsById[message.threadId];\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const store = getRoomExtrasForClient(client).store;\n    void store.fetchRoomThreadsDeltaUpdate(room.id).catch(() => {\n    });\n  }, [client, room.id]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    function handleIsOnline() {\n      const store = getRoomExtrasForClient(client).store;\n      void store.fetchRoomThreadsDeltaUpdate(room.id).catch(() => {\n      });\n    }\n    window.addEventListener(\"online\", handleIsOnline);\n    return () => {\n      window.removeEventListener(\"online\", handleIsOnline);\n    };\n  }, [client, room.id]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, { value: room }, props.children);\n}\nfunction useRoom() {\n  const room = useRoomOrNull();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatus(options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n}\nfunction useStorageStatusImmediate() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatusSmooth() {\n  const room = useRoom();\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let timeoutId;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n  return status;\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useErrorListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.error.subscribe((e) => savedCallback.current(e)),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore2(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore2(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity2;\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity2,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,\n    [room, rootOrNull]\n  );\n  const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const { store, subscribeToRoomThreadsDeltaUpdates: subscribeToDeltaUpdates } = getRoomExtrasForClient(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomThreadsLoaded(room.id, options.query).catch(() => {\n      });\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(subscribeToDeltaUpdates, [subscribeToDeltaUpdates]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getRoomThreadsAsync(room.id, options.query),\n    [store, room.id, options.query]\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeThreads,\n    getter,\n    getter,\n    identity2,\n    shallow2\n    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useCommentsErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  const { commentsErrorEventSource } = getRoomExtrasForClient(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return commentsErrorEventSource.subscribe(savedCallback.current);\n  }, [savedCallback, commentsErrorEventSource]);\n}\nfunction useCreateThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const attachments = options.attachments;\n      const threadId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createThreadId)();\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(room),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId: room.id,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId: room.id\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.createThread({ threadId, commentId, body, metadata, attachmentIds }).then(\n        (thread) => {\n          store.createThread(optimisticUpdateId, thread);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateThreadError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body,\n            metadata\n          })\n        )\n      );\n      return newThread;\n    },\n    [client, room]\n  );\n}\nfunction useDeleteThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const thread = store.getFullState().threadsById[threadId];\n      const userId = getCurrentUserId(room);\n      if (thread?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-thread\",\n        roomId: room.id,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      room.deleteThread(threadId).then(\n        () => {\n          store.deleteThread(threadId, optimisticUpdateId);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useEditThreadMetadata() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt\n      });\n      room.editThreadMetadata({ threadId, metadata }).then(\n        (metadata2) => (\n          // Replace the optimistic update by the real thing\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { metadata: metadata2 },\n            updatedAt\n          )\n        ),\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditThreadMetadataError(error, {\n            roomId: room.id,\n            threadId,\n            metadata\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useCreateComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, body, attachments }) => {\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(room),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"create-comment\",\n        comment\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.createComment({ threadId, commentId, body, attachmentIds }).then(\n        (newComment) => {\n          store.createComment(newComment, optimisticUpdateId);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateCommentError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n      return comment;\n    },\n    [client, room]\n  );\n}\nfunction useEditComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, body, attachments }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const thread = store.getFullState().threadsById[threadId];\n      if (thread === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = thread.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? []\n        }\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.editComment({ threadId, commentId, body, attachmentIds }).then(\n        (editedComment) => {\n          store.editComment(threadId, optimisticUpdateId, editedComment);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useDeleteComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId: room.id\n      });\n      room.deleteComment({ threadId, commentId }).then(\n        () => {\n          store.deleteComment(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            deletedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new DeleteCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useAddReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(room);\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        }\n      });\n      room.addReaction({ threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.addReaction(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            addedReaction,\n            createdAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new AddReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useRemoveReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(room);\n      const removedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt\n      });\n      room.removeReaction({ threadId, commentId, emoji }).then(\n        () => {\n          store.removeReaction(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            emoji,\n            userId,\n            removedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new RemoveReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsRead() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.getFullState().notificationsById\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const now = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      room.markInboxNotificationAsRead(inboxNotification.id).then(\n        () => {\n          store.updateInboxNotification(\n            inboxNotification.id,\n            optimisticUpdateId,\n            (inboxNotification2) => ({ ...inboxNotification2, readAt: now })\n          );\n        },\n        (err) => {\n          onMutationFailure(\n            err,\n            optimisticUpdateId,\n            (error) => new MarkInboxNotificationAsReadError(error, {\n              inboxNotificationId: inboxNotification.id\n            })\n          );\n          return;\n        }\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt\n      });\n      room.markThreadAsResolved(threadId).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { resolved: true },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsResolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt\n      });\n      room.markThreadAsUnresolved(threadId).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { resolved: false },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsUnresolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state) => {\n      const inboxNotification = state.notifications.find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      const thread = state.threadsById[threadId];\n      if (inboxNotification === void 0 || thread === void 0) {\n        return {\n          status: \"not-subscribed\"\n        };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: inboxNotification.readAt\n      };\n    },\n    [threadId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeThreads,\n    store.getFullState,\n    store.getFullState,\n    selector\n  );\n}\nfunction useRoomNotificationSettings() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getNotificationSettingsAsync(room.id),\n    [store, room.id]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { getInboxNotificationSettings } = getRoomExtrasForClient(client);\n    void getInboxNotificationSettings(room);\n  }, [client, room]);\n  const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeNotificationSettings,\n    getter,\n    getter,\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomNotificationSettingsSuspense() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getNotificationSettingsAsync(room.id),\n    [store, room.id]\n  );\n  const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeNotificationSettings,\n    getter,\n    getter,\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  if (settings.isLoading) {\n    const { getInboxNotificationSettings } = getRoomExtrasForClient(client);\n    throw getInboxNotificationSettings(room);\n  } else if (settings.error) {\n    throw settings.error;\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useHistoryVersionData(versionId) {\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    isLoading: true\n  });\n  const room = useRoom();\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error: error instanceof Error ? error : new Error(\n            \"An unknown error occurred while loading this version\"\n          )\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\nfunction useHistoryVersions() {\n  const client = useClient();\n  const room = useRoom();\n  const { store, getRoomVersions } = getRoomExtrasForClient(client);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getVersionsAsync(room.id),\n    [store, room.id]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    void getRoomVersions(room);\n  }, [room]);\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeVersions,\n    getter,\n    getter,\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  return state;\n}\nfunction useHistoryVersionsSuspense() {\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getVersionsAsync(room.id),\n    [store, room.id]\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    store.subscribeVersions,\n    getter,\n    getter,\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  if (state.isLoading) {\n    const { getRoomVersions } = getRoomExtrasForClient(client);\n    throw getRoomVersions(room);\n  } else if (state.error) {\n    throw state.error;\n  }\n  return state;\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (settings) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateRoomInboxNotificationSettings2(\n            room.id,\n            optimisticUpdateId,\n            settings2\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new UpdateNotificationSettingsError(error, {\n            roomId: room.id\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n    );\n  }\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense(options) {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options);\n}\nfunction useThreadsSuspense(options = {\n  query: { metadata: {} }\n}) {\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  use(store.waitUntilRoomThreadsLoaded(room.id, options.query));\n  const result = useThreads(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction selectorFor_useAttachmentUrl(state) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing attachment URL\");\n  return {\n    isLoading: false,\n    url: state.data\n  };\n}\nfunction useAttachmentUrl(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal];\n  const getAttachmentUrlState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => attachmentUrlsStore.getState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    void attachmentUrlsStore.get(attachmentId);\n  }, [attachmentUrlsStore, attachmentId]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStoreWithSelector)(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useAttachmentUrlSuspense(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal];\n  const getAttachmentUrlState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => attachmentUrlsStore.getState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.get(attachmentId);\n  }\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n  const state = useSyncExternalStore2(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: void 0\n  };\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useIsInsideRoom = useIsInsideRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useHistoryVersions = useHistoryVersions;\nvar _useHistoryVersionsSuspense = useHistoryVersionsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-V7FAMENR.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1WN0ZBTUVOUi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDL0I7QUFDQSxnQ0FBZ0MsMkNBQWM7QUFDOUMsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0RBQW1CLENBQUMsMkNBQWMsSUFBSSwwQkFBMEI7QUFDekY7O0FBRUE7QUFDZ0M7QUFDaEMsa0JBQWtCLGdEQUFvQjtBQUN0QztBQUNBLFNBQVMsNkNBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFhMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQSxTQUFTLCtEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQSxZQUFZLE9BQU8sR0FBRywyREFBUyxZQUFZLEVBQUU7QUFDN0M7QUFDQTtBQUNBLHlCQUF5QiwyREFBUyxZQUFZLEVBQUU7QUFDaEQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0NBQW9DO0FBQ3RGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrREFBa0Q7QUFDbEgsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJEQUFTO0FBQzdELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFRO0FBQ1osaUJBQWlCLFlBQVksNEJBQTRCLFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFLHdEQUFNO0FBQ1IsRUFBRSx3REFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxxREFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lEO0FBYy9CO0FBQ007QUFDc0c7O0FBRXRJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQSxFQUFFLHdEQUFPO0FBQ1QsRUFBRSx3REFBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3REFBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0IsT0FBTyx1REFBVTtBQUNqRCxnQ0FBZ0MsOENBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0EsR0FBRztBQUNILFNBQVMsK0dBQWlDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0IsT0FBTyx1REFBVTtBQUNqRCxnQ0FBZ0MsOENBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQU87QUFDVCxFQUFFLHdEQUFPO0FBQ1QsRUFBRSx3REFBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFzRkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BsaXZlYmxvY2tzLWV4YW1wbGVzL25leHRqcy15anMtYmxvY2tub3RlLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0L2Rpc3QvY2h1bmstVjdGQU1FTlIubWpzP2Y4YzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi45LjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL0NsaWVudFNpZGVTdXNwZW5zZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gQ2xpZW50U2lkZVN1c3BlbnNlKHByb3BzKSB7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5TdXNwZW5zZSwgeyBmYWxsYmFjazogcHJvcHMuZmFsbGJhY2sgfSwgbW91bnRlZCA/IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvcHMuY2hpbGRyZW4oKSA6IHByb3BzLmNoaWxkcmVuIDogcHJvcHMuZmFsbGJhY2spO1xufVxuXG4vLyBzcmMvY29udGV4dHMudHNcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbnZhciBSb29tQ29udGV4dCA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlUm9vbU9yTnVsbCgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KFJvb21Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZUlzSW5zaWRlUm9vbSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb21Pck51bGwoKTtcbiAgcmV0dXJuIHJvb20gIT09IG51bGw7XG59XG5cbi8vIHNyYy91bWJyZWxsYS1zdG9yZS50c1xuaW1wb3J0IHtcbiAgYXV0b1JldHJ5LFxuICBjb21wYWN0T2JqZWN0LFxuICBjb25zb2xlIGFzIGNvbnNvbGUyLFxuICBjcmVhdGVTdG9yZSxcbiAga0ludGVybmFsLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1hcFZhbHVlcyxcbiAgbmFub2lkLFxuICBubixcbiAgU3RvcFJldHJ5aW5nLFxuICBzdHJpbmdpZnlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL2xpYi9hdXRvYmluZC50c1xuZnVuY3Rpb24gYXV0b2JpbmQoc2VsZikge1xuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc2Vlbi5hZGQoXCJjb25zdHJ1Y3RvclwiKTtcbiAgbGV0IG9iaiA9IHNlbGYuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICBkbyB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKG9iaikpIHtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3I/LnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgc2VsZltrZXldID0gc2VsZltrZXldLmJpbmQoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgob2JqID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihvYmopKSAmJiBvYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xufVxuXG4vLyBzcmMvbGliL2NvbXBhcmUudHNcbmZ1bmN0aW9uIGJ5Rmlyc3RDcmVhdGVkKGEsIGIpIHtcbiAgcmV0dXJuIGEuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGIuY3JlYXRlZEF0LmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGlzTW9yZVJlY2VudGx5VXBkYXRlZChhLCBiKSB7XG4gIHJldHVybiBieU1vc3RSZWNlbnRseVVwZGF0ZWQoYSwgYikgPCAwO1xufVxuZnVuY3Rpb24gYnlNb3N0UmVjZW50bHlVcGRhdGVkKGEsIGIpIHtcbiAgcmV0dXJuIChiLnVwZGF0ZWRBdCA/PyBiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gKGEudXBkYXRlZEF0ID8/IGEuY3JlYXRlZEF0KS5nZXRUaW1lKCk7XG59XG5cbi8vIHNyYy9saWIvZ3VhcmRzLnRzXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmZ1bmN0aW9uIGlzU3RhcnRzV2l0aChibG9iKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJsb2IpICYmIGlzU3RyaW5nKGJsb2Iuc3RhcnRzV2l0aCk7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuXG4vLyBzcmMvbGliL3F1ZXJ5aW5nLnRzXG5mdW5jdGlvbiBtYWtlVGhyZWFkc0ZpbHRlcihxdWVyeSkge1xuICByZXR1cm4gKHRocmVhZCkgPT4gbWF0Y2hlc1F1ZXJ5KHRocmVhZCwgcXVlcnkpICYmIG1hdGNoZXNNZXRhZGF0YSh0aHJlYWQsIHF1ZXJ5KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNRdWVyeSh0aHJlYWQsIHEpIHtcbiAgcmV0dXJuIHEucmVzb2x2ZWQgPT09IHZvaWQgMCB8fCB0aHJlYWQucmVzb2x2ZWQgPT09IHEucmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtYXRjaGVzTWV0YWRhdGEodGhyZWFkLCBxKSB7XG4gIGNvbnN0IG1ldGFkYXRhID0gdGhyZWFkLm1ldGFkYXRhO1xuICByZXR1cm4gcS5tZXRhZGF0YSA9PT0gdm9pZCAwIHx8IE9iamVjdC5lbnRyaWVzKHEubWV0YWRhdGEpLmV2ZXJ5KFxuICAgIChba2V5LCBvcF0pID0+IChcbiAgICAgIC8vIEJvb2xlYW4gbG9naWM6IG9wPyA9PiB2YWx1ZSBtYXRjaGVzIHRoZSBvcGVyYXRvclxuICAgICAgb3AgPT09IHZvaWQgMCB8fCBtYXRjaGVzT3BlcmF0b3IobWV0YWRhdGFba2V5XSwgb3ApXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gbWF0Y2hlc09wZXJhdG9yKHZhbHVlLCBvcCkge1xuICBpZiAoaXNTdGFydHNXaXRoKG9wKSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aChvcC5zdGFydHNXaXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG9wO1xuICB9XG59XG5cbi8vIHNyYy91bWJyZWxsYS1zdG9yZS50c1xudmFyIEFTWU5DX09LID0gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHZvaWQgMCB9KTtcbmZ1bmN0aW9uIG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb21JZCwgcXVlcnkpIHtcbiAgcmV0dXJuIGAke3Jvb21JZH0tJHtzdHJpbmdpZnkocXVlcnkgPz8ge30pfWA7XG59XG5mdW5jdGlvbiBtYWtlVXNlclRocmVhZHNRdWVyeUtleShxdWVyeSkge1xuICByZXR1cm4gYFVTRVJfVEhSRUFEUzoke3N0cmluZ2lmeShxdWVyeSA/PyB7fSl9YDtcbn1cbmZ1bmN0aW9uIG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb21JZCkge1xuICByZXR1cm4gYCR7cm9vbUlkfTpOT1RJRklDQVRJT05fU0VUVElOR1NgO1xufVxuZnVuY3Rpb24gbWFrZVZlcnNpb25zUXVlcnlLZXkocm9vbUlkKSB7XG4gIHJldHVybiBgJHtyb29tSWR9LVZFUlNJT05TYDtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRocmVhZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgbGV0IHRocmVhZHMgPSBzdGF0ZS50aHJlYWRzO1xuICBpZiAob3B0aW9ucy5yb29tSWQgIT09IG51bGwpIHtcbiAgICB0aHJlYWRzID0gdGhyZWFkcy5maWx0ZXIoKHRocmVhZCkgPT4gdGhyZWFkLnJvb21JZCA9PT0gb3B0aW9ucy5yb29tSWQpO1xuICB9XG4gIGNvbnN0IHF1ZXJ5ID0gb3B0aW9ucy5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhyZWFkcyA9IHRocmVhZHMuZmlsdGVyKG1ha2VUaHJlYWRzRmlsdGVyKHF1ZXJ5KSk7XG4gIH1cbiAgcmV0dXJuIHRocmVhZHMuc29ydChcbiAgICBvcHRpb25zLm9yZGVyQnkgPT09IFwibGFzdC11cGRhdGVcIiA/IGJ5TW9zdFJlY2VudGx5VXBkYXRlZCA6IGJ5Rmlyc3RDcmVhdGVkXG4gICk7XG59XG5mdW5jdGlvbiB1c2lmeShwcm9taXNlKSB7XG4gIGlmIChcInN0YXR1c1wiIGluIHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBjb25zdCB1c2FibGUgPSBwcm9taXNlO1xuICB1c2FibGUuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gIHVzYWJsZS50aGVuKFxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdXNhYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICB1c2FibGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIHVzYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICB1c2FibGUucmVhc29uID0gZXJyO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHVzYWJsZTtcbn1cbnZhciBub29wID0gUHJvbWlzZS5yZXNvbHZlKCk7XG52YXIgQVNZTkNfTE9BRElORyA9IE9iamVjdC5mcmVlemUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZldGNoUGFnZSkge1xuICAgIHRoaXMuX2NhY2hlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2luYXRpb25TdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fZmV0Y2hQYWdlID0gZmV0Y2hQYWdlO1xuICAgIHRoaXMuX2V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gICAgdGhpcy5fcGVuZGluZ0ZldGNoTW9yZSA9IG51bGw7XG4gICAgdGhpcy5vYnNlcnZhYmxlID0gdGhpcy5fZXZlbnRTb3VyY2Uub2JzZXJ2YWJsZTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBwYXRjaFBhZ2luYXRpb25TdGF0ZShwYXRjaCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGFnaW5hdGlvblN0YXRlO1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHRoaXMuX3BhZ2luYXRpb25TdGF0ZSA9IHsgLi4uc3RhdGUsIC4uLnBhdGNoIH07XG4gICAgdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoTW9yZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BhZ2luYXRpb25TdGF0ZTtcbiAgICBpZiAoIXN0YXRlPy5jdXJzb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXRjaFBhZ2luYXRpb25TdGF0ZSh7IGlzRmV0Y2hpbmdNb3JlOiB0cnVlIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXh0Q3Vyc29yID0gYXdhaXQgdGhpcy5fZmV0Y2hQYWdlKHN0YXRlLmN1cnNvcik7XG4gICAgICB0aGlzLnBhdGNoUGFnaW5hdGlvblN0YXRlKHtcbiAgICAgICAgY3Vyc29yOiBuZXh0Q3Vyc29yLFxuICAgICAgICBmZXRjaE1vcmVFcnJvcjogdm9pZCAwLFxuICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5wYXRjaFBhZ2luYXRpb25TdGF0ZSh7XG4gICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IGVyclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZldGNoTW9yZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BhZ2luYXRpb25TdGF0ZTtcbiAgICBpZiAoc3RhdGU/LmN1cnNvciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZldGNoTW9yZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZldGNoTW9yZSA9IHRoaXMuX2ZldGNoTW9yZSgpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLl9wZW5kaW5nRmV0Y2hNb3JlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0ZldGNoTW9yZTtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgdXNhYmxlID0gdGhpcy5fY2FjaGVkUHJvbWlzZTtcbiAgICBpZiAodXNhYmxlID09PSBudWxsIHx8IHVzYWJsZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgaWYgKHVzYWJsZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgcmV0dXJuIHsgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IHVzYWJsZS5yZWFzb24gfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9wYWdpbmF0aW9uU3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZldGNoTW9yZTogdGhpcy5mZXRjaE1vcmUsXG4gICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBzdGF0ZS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHN0YXRlLmZldGNoTW9yZUVycm9yLFxuICAgICAgICBoYXNGZXRjaGVkQWxsOiBzdGF0ZS5jdXJzb3IgPT09IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHdhaXRVbnRpbExvYWRlZCgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxGZXRjaGVyID0gYXV0b1JldHJ5KFxuICAgICAgKCkgPT4gdGhpcy5fZmV0Y2hQYWdlKFxuICAgICAgICAvKiBjdXJzb3IgKi9cbiAgICAgICAgdm9pZCAwXG4gICAgICApLFxuICAgICAgNSxcbiAgICAgIFs1ZTMsIDVlMywgMWU0LCAxNWUzXVxuICAgICk7XG4gICAgY29uc3QgcHJvbWlzZSA9IHVzaWZ5KFxuICAgICAgaW5pdGlhbEZldGNoZXIudGhlbigoY3Vyc29yKSA9PiB7XG4gICAgICAgIHRoaXMuX3BhZ2luYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgaXNGZXRjaGluZ01vcmU6IGZhbHNlLFxuICAgICAgICAgIGZldGNoTW9yZUVycm9yOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB0aGlzLl9ldmVudFNvdXJjZS5ub3RpZnkoKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2NhY2hlZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2V2ZW50U291cmNlLm5vdGlmeSgpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5fY2FjaGVkUHJvbWlzZSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn07XG52YXIgVW1icmVsbGFTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5fcHJldlN0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZUNhY2hlZCA9IG51bGw7XG4gICAgLy8gTm90aWZpY2F0aW9uc1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPSBudWxsO1xuICAgIC8vIFJvb20gVGhyZWFkc1xuICAgIHRoaXMuX3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yb29tVGhyZWFkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLy8gVXNlciBUaHJlYWRzXG4gICAgdGhpcy5fdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPSBudWxsO1xuICAgIHRoaXMuX3VzZXJUaHJlYWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpbmJveEZldGNoZXIgPSBhc3luYyAoY3Vyc29yKSA9PiB7XG4gICAgICBpZiAoY2xpZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIkNsaWVudCBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBsb2FkIHRocmVhZHMgZm9yIHRoZSByb29tXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMoeyBjdXJzb3IgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCBob3cgdG8gcmVtb3ZlIHRoaXMgY2FzdGluZ1xuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRDdXJzb3IgPSByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgIHJldHVybiBuZXh0Q3Vyc29yO1xuICAgIH07XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbnMgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UoaW5ib3hGZXRjaGVyKTtcbiAgICB0aGlzLl9ub3RpZmljYXRpb25zLm9ic2VydmFibGUuc3Vic2NyaWJlKFxuICAgICAgKCkgPT4gKFxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHN0b3JlIGl0c2VsZiBkb2VzIG5vdCBjaGFuZ2UsIGJ1dCBpdCdzIG9ubHkgdmVoaWNsZSBhdFxuICAgICAgICAvLyB0aGUgbW9tZW50IHRvIHRyaWdnZXIgYSByZS1yZW5kZXIsIHNvIHdlJ2xsIGRvIGEgbm8tb3AgdXBkYXRlIGhlcmUuXG4gICAgICAgIHRoaXMuX3N0b3JlLnNldCgoc3RvcmUpID0+ICh7IC4uLnN0b3JlIH0pKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5fc3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgICByYXdUaHJlYWRzQnlJZDoge30sXG4gICAgICBxdWVyaWVzMzoge30sXG4gICAgICBxdWVyaWVzNDoge30sXG4gICAgICBvcHRpbWlzdGljVXBkYXRlczogW10sXG4gICAgICBub3RpZmljYXRpb25zQnlJZDoge30sXG4gICAgICBzZXR0aW5nc0J5Um9vbUlkOiB7fSxcbiAgICAgIHZlcnNpb25zQnlSb29tSWQ6IHt9XG4gICAgfSk7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHJhd1N0YXRlID0gdGhpcy5fc3RvcmUuZ2V0KCk7XG4gICAgaWYgKHRoaXMuX3ByZXZTdGF0ZSAhPT0gcmF3U3RhdGUgfHwgdGhpcy5fc3RhdGVDYWNoZWQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3ByZXZTdGF0ZSA9IHJhd1N0YXRlO1xuICAgICAgdGhpcy5fc3RhdGVDYWNoZWQgPSBpbnRlcm5hbFRvRXh0ZXJuYWxTdGF0ZShyYXdTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUNhY2hlZDtcbiAgfVxuICBiYXRjaChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5iYXRjaChjYWxsYmFjayk7XG4gIH1cbiAgZ2V0RnVsbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3luYyByZXN1bHQgb2YgdGhlIGdpdmVuIHF1ZXJ5IGFuZCByb29tIGlkLiBJZiB0aGUgcXVlcnkgaXMgc3VjY2VzcyxcbiAgICogdGhlbiBpdCB3aWxsIHJldHVybiB0aGUgdGhyZWFkcyB0aGF0IG1hdGNoIHRoYXQgcHJvdmlkZWQgcXVlcnkgYW5kIHJvb20gaWQuXG4gICAqXG4gICAqL1xuICAvLyBYWFhYIEZpbmQgYSBiZXR0ZXIgbmFtZSBmb3IgdGhhdCBkb2Vzbid0IGFzc29jaWF0ZSB0byAnYXN5bmMnXG4gIGdldFJvb21UaHJlYWRzQXN5bmMocm9vbUlkLCBxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVJvb21UaHJlYWRzUXVlcnlLZXkocm9vbUlkLCBxdWVyeSk7XG4gICAgY29uc3QgcGFnaW5hdGVkUmVzb3VyY2UgPSB0aGlzLl9yb29tVGhyZWFkcy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChwYWdpbmF0ZWRSZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSBwYWdpbmF0ZWRSZXNvdXJjZS5nZXQoKTtcbiAgICBpZiAoYXN5bmNSZXN1bHQuaXNMb2FkaW5nIHx8IGFzeW5jUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gYXN5bmNSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHRocmVhZHMgPSBzZWxlY3RUaHJlYWRzKHRoaXMuZ2V0RnVsbFN0YXRlKCksIHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHF1ZXJ5LFxuICAgICAgb3JkZXJCeTogXCJhZ2VcIlxuICAgIH0pO1xuICAgIGNvbnN0IHBhZ2UgPSBhc3luY1Jlc3VsdC5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgdGhyZWFkcyxcbiAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgfTtcbiAgfVxuICAvLyBYWFhYIC0gRmluZCBhIGJldHRlciBuYW1lIGZvciB0aGF0IGRvZXNuJ3QgYXNzb2NpYXRlIHRvICdhc3luYydcbiAgZ2V0VXNlclRocmVhZHNBc3luYyhxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVVzZXJUaHJlYWRzUXVlcnlLZXkocXVlcnkpO1xuICAgIGNvbnN0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fdXNlclRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIEFTWU5DX0xPQURJTkc7XG4gICAgfVxuICAgIGNvbnN0IGFzeW5jUmVzdWx0ID0gcGFnaW5hdGVkUmVzb3VyY2UuZ2V0KCk7XG4gICAgaWYgKGFzeW5jUmVzdWx0LmlzTG9hZGluZyB8fCBhc3luY1Jlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGFzeW5jUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB0aHJlYWRzID0gc2VsZWN0VGhyZWFkcyh0aGlzLmdldEZ1bGxTdGF0ZSgpLCB7XG4gICAgICByb29tSWQ6IG51bGwsXG4gICAgICAvLyBEbyBfbm90XyBmaWx0ZXIgYnkgcm9vbUlkXG4gICAgICBxdWVyeSxcbiAgICAgIG9yZGVyQnk6IFwibGFzdC11cGRhdGVcIlxuICAgIH0pO1xuICAgIGNvbnN0IHBhZ2UgPSBhc3luY1Jlc3VsdC5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgdGhyZWFkcyxcbiAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgfTtcbiAgfVxuICAvLyBOT1RFOiBUaGlzIHdpbGwgcmVhZCB0aGUgYXN5bmMgcmVzdWx0LCBidXQgV0lMTCBOT1Qgc3RhcnQgbG9hZGluZyBhdCB0aGUgbW9tZW50IVxuICAvLyBYWFhYIC0gRmluZCBhIGJldHRlciBuYW1lIGZvciB0aGF0IGRvZXNuJ3QgYXNzb2NpYXRlIHRvICdhc3luYydcbiAgZ2V0SW5ib3hOb3RpZmljYXRpb25zQXN5bmMoKSB7XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSB0aGlzLl9ub3RpZmljYXRpb25zLmdldCgpO1xuICAgIGlmIChhc3luY1Jlc3VsdC5pc0xvYWRpbmcgfHwgYXN5bmNSZXN1bHQuZXJyb3IpIHtcbiAgICAgIHJldHVybiBhc3luY1Jlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcGFnZSA9IGFzeW5jUmVzdWx0LmRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHRoaXMuZ2V0RnVsbFN0YXRlKCkubm90aWZpY2F0aW9ucyxcbiAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgfTtcbiAgfVxuICAvLyBOT1RFOiBUaGlzIHdpbGwgcmVhZCB0aGUgYXN5bmMgcmVzdWx0LCBidXQgV0lMTCBOT1Qgc3RhcnQgbG9hZGluZyBhdCB0aGUgbW9tZW50IVxuICBnZXROb3RpZmljYXRpb25TZXR0aW5nc0FzeW5jKHJvb21JZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICBjb25zdCBxdWVyeSA9IHN0YXRlLnF1ZXJpZXMzW21ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb21JZCldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgcmV0dXJuIEFTWU5DX0xPQURJTkc7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ3M6IG5uKHN0YXRlLnNldHRpbmdzQnlSb29tSWRbcm9vbUlkXSlcbiAgICB9O1xuICB9XG4gIGdldFZlcnNpb25zQXN5bmMocm9vbUlkKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllczRbbWFrZVZlcnNpb25zUXVlcnlLZXkocm9vbUlkKV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB2ZXJzaW9uczogbm4oc3RhdGUudmVyc2lvbnNCeVJvb21JZFtyb29tSWRdKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlIE9ubHkgdXNlZCBieSB0aGUgRTJFIHRlc3Qgc3VpdGUuXG4gICAqL1xuICBfaGFzT3B0aW1pc3RpY1VwZGF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldCgpLm9wdGltaXN0aWNVcGRhdGVzLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlIE9ubHkgdXNlZCBieSB0aGUgRTJFIHRlc3Qgc3VpdGUuXG4gICAqL1xuICBfc3Vic2NyaWJlT3B0aW1pc3RpY1VwZGF0ZXMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIHN1YnNjcmliZVRocmVhZHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIHN1YnNjcmliZVVzZXJUaHJlYWRzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgfVxuICBzdWJzY3JpYmVUaHJlYWRzT3JJbmJveE5vdGlmaWNhdGlvbnMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIHN1YnNjcmliZU5vdGlmaWNhdGlvblNldHRpbmdzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgfVxuICBzdWJzY3JpYmVWZXJzaW9ucyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH1cbiAgLy8gRGlyZWN0IGxvdy1sZXZlbCBjYWNoZSBtdXRhdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB7e3tcbiAgdXBkYXRlVGhyZWFkc0NhY2hlKG1hcEZuKSB7XG4gICAgdGhpcy5fc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdGhyZWFkcyA9IG1hcEZuKHN0YXRlLnJhd1RocmVhZHNCeUlkKTtcbiAgICAgIHJldHVybiB0aHJlYWRzICE9PSBzdGF0ZS5yYXdUaHJlYWRzQnlJZCA/IHsgLi4uc3RhdGUsIHJhd1RocmVhZHNCeUlkOiB0aHJlYWRzIH0gOiBzdGF0ZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZShtYXBGbikge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9ucyA9IG1hcEZuKHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbnMgIT09IHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkID8geyAuLi5zdGF0ZSwgbm90aWZpY2F0aW9uc0J5SWQ6IGluYm94Tm90aWZpY2F0aW9ucyB9IDogc3RhdGU7XG4gICAgfSk7XG4gIH1cbiAgc2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzZXR0aW5ncykge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldHRpbmdzQnlSb29tSWQ6IHtcbiAgICAgICAgLi4uc3RhdGUuc2V0dGluZ3NCeVJvb21JZCxcbiAgICAgICAgW3Jvb21JZF06IHNldHRpbmdzXG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHNldFZlcnNpb25zKHJvb21JZCwgdmVyc2lvbnMpIHtcbiAgICB0aGlzLl9zdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICB2ZXJzaW9uc0J5Um9vbUlkOiB7XG4gICAgICAgIC4uLnN0YXRlLnZlcnNpb25zQnlSb29tSWQsXG4gICAgICAgIFtyb29tSWRdOiB2ZXJzaW9uc1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICBzZXRRdWVyeTNTdGF0ZShxdWVyeUtleSwgcXVlcnlTdGF0ZSkge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHF1ZXJpZXMzOiB7XG4gICAgICAgIC4uLnN0YXRlLnF1ZXJpZXMzLFxuICAgICAgICBbcXVlcnlLZXldOiBxdWVyeVN0YXRlXG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHNldFF1ZXJ5NFN0YXRlKHF1ZXJ5S2V5LCBxdWVyeVN0YXRlKSB7XG4gICAgdGhpcy5fc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcXVlcmllczQ6IHtcbiAgICAgICAgLi4uc3RhdGUucXVlcmllczQsXG4gICAgICAgIFtxdWVyeUtleV06IHF1ZXJ5U3RhdGVcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgdXBkYXRlT3B0aW1pc3RpY1VwZGF0ZXNDYWNoZShtYXBGbikge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBtYXBGbihzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcylcbiAgICB9KSk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB9fX1cbiAgLyoqIEBpbnRlcm5hbCAtIE9ubHkgY2FsbCB0aGlzIG1ldGhvZCBmcm9tIHVuaXQgdGVzdHMuICovXG4gIGZvcmNlX3NldChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5zZXQoY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGluYm94IG5vdGlmaWNhdGlvbiB3aXRoIGEgbmV3IHZhbHVlLCByZXBsYWNpbmcgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgdXBkYXRlIGFueXRoaW5nIGlmIHRoZSBpbmJveCBub3RpZmljYXRpb24gSUQgaXNuJ3QgZm91bmQgaW5cbiAgICogdGhlIGNhY2hlLlxuICAgKi9cbiAgdXBkYXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZSgoY2FjaGUpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjYWNoZVtpbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbnMgPSB7XG4gICAgICAgICAgLi4uY2FjaGUsXG4gICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uSWRdOiBjYWxsYmFjayhleGlzdGluZylcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9ucztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzICphbGwqIGluYm94IG5vdGlmaWNhdGlvbnMgYnkgcnVubmluZyBhIG1hcHBlciBmdW5jdGlvbiBvdmVyIGFsbCBvZlxuICAgKiB0aGVtLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGVBbGxJbmJveE5vdGlmaWNhdGlvbnMob3B0aW1pc3RpY1VwZGF0ZUlkLCBtYXBGbikge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZSgoY2FjaGUpID0+IG1hcFZhbHVlcyhjYWNoZSwgbWFwRm4pKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBleGlzdGluZyBpbmJveCBub3RpZmljYXRpb24sIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZSgoY2FjaGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBbaW5ib3hOb3RpZmljYXRpb25JZF06IHJlbW92ZWQsIC4uLm5ld0NhY2hlIH0gPSBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQgPT09IHZvaWQgMCA/IGNhY2hlIDogbmV3Q2FjaGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyAqYWxsKiBpbmJveCBub3RpZmljYXRpb25zLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpY1xuICAgKiB1cGRhdGUuXG4gICAqL1xuICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMob3B0aW1pc3RpY1VwZGF0ZUlkKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKCgpID0+ICh7fSkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG5ldyB0aHJlYWQsIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIGNyZWF0ZVRocmVhZChvcHRpbWlzdGljVXBkYXRlSWQsIHRocmVhZCkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51cGRhdGVUaHJlYWRzQ2FjaGUoKGNhY2hlKSA9PiAoeyAuLi5jYWNoZSwgW3RocmVhZC5pZF06IHRocmVhZCB9KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggYSBuZXcgdmFsdWUsIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZCBpbiB0aGUgY2FjaGU7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCB3YXMgYWxyZWFkeSBkZWxldGVkIGZyb20gdGhlIGNhY2hlOyBvclxuICAgKiAtIFRoZSB0aHJlYWQgSUQgaW4gdGhlIGNhY2hlIHdhcyB1cGRhdGVkIG1vcmUgcmVjZW50bHkgdGhhbiB0aGUgb3B0aW1pc3RpY1xuICAgKiAgIHVwZGF0ZSdzIHRpbWVzdGFtcCAoaWYgZ2l2ZW4pXG4gICAqL1xuICB1cGRhdGVUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgY2FsbGJhY2ssIHVwZGF0ZWRBdCkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIGlmIChvcHRpbWlzdGljVXBkYXRlSWQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRocmVhZHNDYWNoZSgoY2FjaGUpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjYWNoZVt0aHJlYWRJZF07XG4gICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0aW5nLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIXVwZGF0ZWRBdCAmJiAhIWV4aXN0aW5nLnVwZGF0ZWRBdCAmJiBleGlzdGluZy51cGRhdGVkQXQgPiB1cGRhdGVkQXQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uY2FjaGUsIFt0aHJlYWRJZF06IGNhbGxiYWNrKGV4aXN0aW5nKSB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcGF0Y2hUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgcGF0Y2gsIHVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgKHRocmVhZCkgPT4gKHsgLi4udGhyZWFkLCAuLi5jb21wYWN0T2JqZWN0KHBhdGNoKSB9KSxcbiAgICAgIHVwZGF0ZWRBdFxuICAgICk7XG4gIH1cbiAgYWRkUmVhY3Rpb24odGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgY29tbWVudElkLCByZWFjdGlvbiwgY3JlYXRlZEF0KSB7XG4gICAgdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5QWRkUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIHJlYWN0aW9uKSxcbiAgICAgIGNyZWF0ZWRBdFxuICAgICk7XG4gIH1cbiAgcmVtb3ZlUmVhY3Rpb24odGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgICB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlSZW1vdmVSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSxcbiAgICAgIHJlbW92ZWRBdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNvZnQtZGVsZXRlcyBhbiBleGlzdGluZyB0aHJlYWQgYnkgc2V0dGluZyBpdHMgYGRlbGV0ZWRBdGAgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZCBpbiB0aGUgY2FjaGU7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCB3YXMgYWxyZWFkeSBkZWxldGVkIGZyb20gdGhlIGNhY2hlXG4gICAqL1xuICBkZWxldGVUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgLy8gQSBkZWxldGlvbiBpcyBhY3R1YWxseSBhbiB1cGRhdGUgb2YgdGhlIGRlbGV0ZWRBdCBwcm9wZXJ0eSBpbnRlcm5hbGx5XG4gICAgICAodGhyZWFkKSA9PiAoeyAuLi50aHJlYWQsIHVwZGF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4aXN0aW5nIGNvbW1lbnQgYW5kIGVuc3VyZXMgdGhlIGFzc29jaWF0ZWQgbm90aWZpY2F0aW9uIGlzXG4gICAqIHVwZGF0ZWQgY29ycmVjdGx5LCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBjcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB0aGlzLl9zdG9yZS5nZXQoKS5yYXdUaHJlYWRzQnlJZFtuZXdDb21tZW50LnRocmVhZElkXTtcbiAgICAgIGlmICghZXhpc3RpbmdUaHJlYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUaHJlYWRzQ2FjaGUoKGNhY2hlKSA9PiAoe1xuICAgICAgICAuLi5jYWNoZSxcbiAgICAgICAgW25ld0NvbW1lbnQudGhyZWFkSWRdOiBhcHBseVVwc2VydENvbW1lbnQoZXhpc3RpbmdUaHJlYWQsIG5ld0NvbW1lbnQpXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKChjYWNoZSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZ05vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoY2FjaGUpLmZpbmQoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSBuZXdDb21tZW50LnRocmVhZElkXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZXhpc3RpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jYWNoZSxcbiAgICAgICAgICBbZXhpc3RpbmdOb3RpZmljYXRpb24uaWRdOiB7XG4gICAgICAgICAgICAuLi5leGlzdGluZ05vdGlmaWNhdGlvbixcbiAgICAgICAgICAgIG5vdGlmaWVkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgICAgcmVhZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGVkaXRDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGVkaXRlZENvbW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGVkaXRlZENvbW1lbnQpXG4gICAgKTtcbiAgfVxuICBkZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGhyZWFkKFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAodGhyZWFkKSA9PiBhcHBseURlbGV0ZUNvbW1lbnQodGhyZWFkLCBjb21tZW50SWQsIGRlbGV0ZWRBdCksXG4gICAgICBkZWxldGVkQXRcbiAgICApO1xuICB9XG4gIHVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVUaHJlYWRzQ2FjaGUoKGNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gY2FjaGVbdGhyZWFkLmlkXTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDAgfHwgaXNNb3JlUmVjZW50bHlVcGRhdGVkKHRocmVhZCwgZXhpc3RpbmdUaHJlYWQpID8geyAuLi5jYWNoZSwgW3RocmVhZC5pZF06IHRocmVhZCB9IDogY2FjaGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUoKGNhY2hlKSA9PiAoe1xuICAgICAgICAgIC4uLmNhY2hlLFxuICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IGluYm94Tm90aWZpY2F0aW9uXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyh0aHJlYWRzLCBpbmJveE5vdGlmaWNhdGlvbnMsIGRlbGV0ZWRUaHJlYWRzID0gW10sIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSBbXSkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVGhyZWFkc0NhY2hlKFxuICAgICAgICAoY2FjaGUpID0+IGFwcGx5VGhyZWFkVXBkYXRlcyhjYWNoZSwge1xuICAgICAgICAgIG5ld1RocmVhZHM6IHRocmVhZHMsXG4gICAgICAgICAgZGVsZXRlZFRocmVhZHNcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKFxuICAgICAgICAoY2FjaGUpID0+IGFwcGx5Tm90aWZpY2F0aW9uc1VwZGF0ZXMoY2FjaGUsIHtcbiAgICAgICAgICBuZXdJbmJveE5vdGlmaWNhdGlvbnM6IGluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICBkZWxldGVkTm90aWZpY2F0aW9uczogZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBleGlzdGluZyBub3RpZmljYXRpb24gc2V0dGluZyBmb3IgYSByb29tIHdpdGggYSBuZXcgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIC8vIFhYWFggUmVuYW1lIHRoaXMgaGVscGVyIG1ldGhvZFxuICB1cGRhdGVSb29tSW5ib3hOb3RpZmljYXRpb25TZXR0aW5nczIocm9vbUlkLCBvcHRpbWlzdGljVXBkYXRlSWQsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLnNldE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2V0dGluZ3MpO1xuICAgIH0pO1xuICB9XG4gIC8vIFhYWFggUmVuYW1lIHRoaXMgaGVscGVyIG1ldGhvZFxuICB1cGRhdGVSb29tSW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHNldHRpbmdzLCBxdWVyeUtleSkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UXVlcnkzT0socXVlcnlLZXkpO1xuICAgICAgdGhpcy5zZXROb3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHNldHRpbmdzKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVSb29tVmVyc2lvbnMocm9vbUlkLCB2ZXJzaW9ucywgcXVlcnlLZXkpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFZlcnNpb25zKHJvb21JZCwgdmVyc2lvbnMpO1xuICAgICAgaWYgKHF1ZXJ5S2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5zZXRRdWVyeTRPSyhxdWVyeUtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgICBjb25zdCBuZXdVcGRhdGUgPSB7IC4uLm9wdGltaXN0aWNVcGRhdGUsIGlkIH07XG4gICAgdGhpcy51cGRhdGVPcHRpbWlzdGljVXBkYXRlc0NhY2hlKChjYWNoZSkgPT4gWy4uLmNhY2hlLCBuZXdVcGRhdGVdKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpIHtcbiAgICB0aGlzLnVwZGF0ZU9wdGltaXN0aWNVcGRhdGVzQ2FjaGUoXG4gICAgICAoY2FjaGUpID0+IGNhY2hlLmZpbHRlcigob3UpID0+IG91LmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWQpXG4gICAgKTtcbiAgfVxuICAvLyBRdWVyeSAzXG4gIHNldFF1ZXJ5M0xvYWRpbmcocXVlcnlLZXkpIHtcbiAgICB0aGlzLnNldFF1ZXJ5M1N0YXRlKHF1ZXJ5S2V5LCBBU1lOQ19MT0FESU5HKTtcbiAgfVxuICBzZXRRdWVyeTNPSyhxdWVyeUtleSkge1xuICAgIHRoaXMuc2V0UXVlcnkzU3RhdGUocXVlcnlLZXksIEFTWU5DX09LKTtcbiAgfVxuICBzZXRRdWVyeTNFcnJvcihxdWVyeUtleSwgZXJyb3IpIHtcbiAgICB0aGlzLnNldFF1ZXJ5M1N0YXRlKHF1ZXJ5S2V5LCB7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yIH0pO1xuICB9XG4gIC8vIFF1ZXJ5IDRcbiAgc2V0UXVlcnk0TG9hZGluZyhxdWVyeUtleSkge1xuICAgIHRoaXMuc2V0UXVlcnk0U3RhdGUocXVlcnlLZXksIEFTWU5DX0xPQURJTkcpO1xuICB9XG4gIHNldFF1ZXJ5NE9LKHF1ZXJ5S2V5KSB7XG4gICAgdGhpcy5zZXRRdWVyeTRTdGF0ZShxdWVyeUtleSwgQVNZTkNfT0spO1xuICB9XG4gIHNldFF1ZXJ5NEVycm9yKHF1ZXJ5S2V5LCBlcnJvcikge1xuICAgIHRoaXMuc2V0UXVlcnk0U3RhdGUocXVlcnlLZXksIHsgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3IgfSk7XG4gIH1cbiAgYXN5bmMgZmV0Y2hOb3RpZmljYXRpb25zRGVsdGFVcGRhdGUoKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdDtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlMi53YXJuKFwiTm90aWZpY2F0aW9ucyBwb2xsZWQgYmVmb3JlIGZpcnN0IHBhZ2UgbG9hZGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBubihcbiAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgIFwiQ2xpZW50IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGxvYWQgbm90aWZpY2F0aW9ucyBmb3IgdGhlIHJvb21cIlxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlKGxhc3RSZXF1ZXN0ZWRBdCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgIHJlc3VsdC50aHJlYWRzLnVwZGF0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICByZXN1bHQudGhyZWFkcy5kZWxldGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgfVxuICB3YWl0VW50aWxOb3RpZmljYXRpb25zTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9ub3RpZmljYXRpb25zLndhaXRVbnRpbExvYWRlZCgpO1xuICB9XG4gIHdhaXRVbnRpbFJvb21UaHJlYWRzTG9hZGVkKHJvb21JZCwgcXVlcnkpIHtcbiAgICBjb25zdCB0aHJlYWRzRmV0Y2hlciA9IGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jbGllbnQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiQ2xpZW50IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGxvYWQgdGhyZWFkcyBmb3IgdGhlIHJvb21cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vbSA9IHRoaXMuX2NsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIGBSb29tIHdpdGggaWQgJHtyb29tSWR9IGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcm9vbS5nZXRUaHJlYWRzKHsgY3Vyc29yLCBxdWVyeSB9KTtcbiAgICAgIHRoaXMudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyB0byByZW1vdmUgdGhpcyBjYXN0aW5nXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICk7XG4gICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgICAgdGhpcy5fcm9vbVRocmVhZHNMYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KHJvb21JZCwgcmVzdWx0LnJlcXVlc3RlZEF0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQubmV4dEN1cnNvcjtcbiAgICB9O1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVJvb21UaHJlYWRzUXVlcnlLZXkocm9vbUlkLCBxdWVyeSk7XG4gICAgbGV0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fcm9vbVRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UodGhyZWFkc0ZldGNoZXIpO1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSZXNvdXJjZS5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Jvb21UaHJlYWRzLnNldChxdWVyeUtleSwgcGFnaW5hdGVkUmVzb3VyY2UpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZS53YWl0VW50aWxMb2FkZWQoKTtcbiAgfVxuICBhc3luYyBmZXRjaFJvb21UaHJlYWRzRGVsdGFVcGRhdGUocm9vbUlkKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy5fcm9vbVRocmVhZHNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zb2xlMi53YXJuKFwiUm9vbSB0aHJlYWRzIHBvbGxlZCBiZWZvcmUgZmlyc3QgcGFnZSBsb2FkZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IG5uKFxuICAgICAgdGhpcy5fY2xpZW50LFxuICAgICAgXCJDbGllbnQgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gbG9hZCBub3RpZmljYXRpb25zIGZvciB0aGUgcm9vbVwiXG4gICAgKTtcbiAgICBjb25zdCByb29tID0gbm4oXG4gICAgICBjbGllbnQuZ2V0Um9vbShyb29tSWQpLFxuICAgICAgYFJvb20gd2l0aCBpZCAke3Jvb21JZH0gaXMgbm90IGF2YWlsYWJsZSBvbiBjbGllbnRgXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVzID0gYXdhaXQgcm9vbS5nZXRUaHJlYWRzU2luY2Uoe1xuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICB1cGRhdGVzLnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICB1cGRhdGVzLnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWRcbiAgICApO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPCB1cGRhdGVzLnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbUlkLCB1cGRhdGVzLnJlcXVlc3RlZEF0KTtcbiAgICB9XG4gIH1cbiAgd2FpdFVudGlsVXNlclRocmVhZHNMb2FkZWQocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VVc2VyVGhyZWFkc1F1ZXJ5S2V5KHF1ZXJ5KTtcbiAgICBjb25zdCB0aHJlYWRzRmV0Y2hlciA9IGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jbGllbnQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiQ2xpZW50IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGxvYWQgdGhyZWFkcyBmb3IgdGhlIHJvb21cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fY2xpZW50W2tJbnRlcm5hbF0uZ2V0VXNlclRocmVhZHNfZXhwZXJpbWVudGFsKHtcbiAgICAgICAgY3Vyc29yLFxuICAgICAgICBxdWVyeVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCBob3cgdG8gcmVtb3ZlIHRoaXMgY2FzdGluZ1xuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3VzZXJUaHJlYWRzTGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VzZXJUaHJlYWRzTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0Q3Vyc29yO1xuICAgIH07XG4gICAgbGV0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fdXNlclRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UodGhyZWFkc0ZldGNoZXIpO1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSZXNvdXJjZS5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3VzZXJUaHJlYWRzLnNldChxdWVyeUtleSwgcGFnaW5hdGVkUmVzb3VyY2UpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZS53YWl0VW50aWxMb2FkZWQoKTtcbiAgfVxuICBhc3luYyBmZXRjaFVzZXJUaHJlYWRzRGVsdGFVcGRhdGUoKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy5fdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZTIud2FybihcIlVzZXIgdGhyZWFkcyBwb2xsZWQgYmVmb3JlIGZpcnN0IHBhZ2UgbG9hZGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBubihcbiAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgIFwiQ2xpZW50IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGxvYWQgdGhyZWFkcyBmb3IgdGhlIHVzZXJcIlxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50W2tJbnRlcm5hbF0uZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWwoe1xuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdFxuICAgIH0pO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPCByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICByZXN1bHQudGhyZWFkcy51cGRhdGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy51cGRhdGVkLFxuICAgICAgcmVzdWx0LnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMuZGVsZXRlZFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBpbnRlcm5hbFRvRXh0ZXJuYWxTdGF0ZShzdGF0ZSkge1xuICBjb25zdCBjb21wdXRlZCA9IHtcbiAgICB0aHJlYWRzQnlJZDogeyAuLi5zdGF0ZS5yYXdUaHJlYWRzQnlJZCB9LFxuICAgIG5vdGlmaWNhdGlvbnNCeUlkOiB7IC4uLnN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkIH0sXG4gICAgc2V0dGluZ3NCeVJvb21JZDogeyAuLi5zdGF0ZS5zZXR0aW5nc0J5Um9vbUlkIH1cbiAgfTtcbiAgZm9yIChjb25zdCBvcHRpbWlzdGljVXBkYXRlIG9mIHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgc3dpdGNoIChvcHRpbWlzdGljVXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJjcmVhdGUtdGhyZWFkXCI6IHtcbiAgICAgICAgY29tcHV0ZWQudGhyZWFkc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWQuaWRdID0gb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gY29tcHV0ZWQudGhyZWFkc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLnVwZGF0ZWRBdCAhPT0gdm9pZCAwICYmIHRocmVhZC51cGRhdGVkQXQgPiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkLnRocmVhZHNCeUlkW3RocmVhZC5pZF0gPSB7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHVwZGF0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLnRocmVhZC5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUubWV0YWRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstdGhyZWFkLWFzLXJlc29sdmVkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gY29tcHV0ZWQudGhyZWFkc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC50aHJlYWRzQnlJZFt0aHJlYWQuaWRdID0ge1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICByZXNvbHZlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gY29tcHV0ZWQudGhyZWFkc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC50aHJlYWRzQnlJZFt0aHJlYWQuaWRdID0ge1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiY3JlYXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBjb21wdXRlZC50aHJlYWRzQnlJZFtvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC50aHJlYWRzQnlJZFt0aHJlYWQuaWRdID0gYXBwbHlVcHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkXG4gICAgICAgICkuZmluZChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBjb21wdXRlZC50aHJlYWRzQnlJZFtvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC50aHJlYWRzQnlJZFt0aHJlYWQuaWRdID0gYXBwbHlVcHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBjb21wdXRlZC50aHJlYWRzQnlJZFtvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZWQudGhyZWFkc0J5SWRbdGhyZWFkLmlkXSA9IGFwcGx5RGVsZXRlQ29tbWVudChcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLXRocmVhZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IGNvbXB1dGVkLnRocmVhZHNCeUlkW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC50aHJlYWRzQnlJZFtvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXSA9IHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgZGVsZXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0LFxuICAgICAgICAgIGNvbW1lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhZGQtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBjb21wdXRlZC50aHJlYWRzQnlJZFtvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZWQudGhyZWFkc0J5SWRbdGhyZWFkLmlkXSA9IGFwcGx5QWRkUmVhY3Rpb24oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmVtb3ZlLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gY29tcHV0ZWQudGhyZWFkc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkLnRocmVhZHNCeUlkW3RocmVhZC5pZF0gPSBhcHBseVJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmVtb2ppLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUudXNlcklkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVtb3ZlZEF0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIjoge1xuICAgICAgICBjb25zdCBpYm4gPSBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZFtvcHRpbWlzdGljVXBkYXRlLmluYm94Tm90aWZpY2F0aW9uSWRdO1xuICAgICAgICBpZiAoaWJuID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZFtvcHRpbWlzdGljVXBkYXRlLmluYm94Tm90aWZpY2F0aW9uSWRdID0ge1xuICAgICAgICAgIC4uLmlibixcbiAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstYWxsLWluYm94LW5vdGlmaWNhdGlvbnMtYXMtcmVhZFwiOiB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgaW4gY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWQpIHtcbiAgICAgICAgICBjb25zdCBpYm4gPSBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZFtpZF07XG4gICAgICAgICAgaWYgKGlibiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRbaWRdID0ge1xuICAgICAgICAgICAgLi4uaWJuLFxuICAgICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWluYm94LW5vdGlmaWNhdGlvblwiOiB7XG4gICAgICAgIGRlbGV0ZSBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZFtvcHRpbWlzdGljVXBkYXRlLmluYm94Tm90aWZpY2F0aW9uSWRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtYWxsLWluYm94LW5vdGlmaWNhdGlvbnNcIjoge1xuICAgICAgICBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZCA9IHt9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCI6IHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBjb21wdXRlZC5zZXR0aW5nc0J5Um9vbUlkW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXTtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZC5zZXR0aW5nc0J5Um9vbUlkW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXSA9IHtcbiAgICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLnNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGNsZWFuZWRUaHJlYWRzID0gKFxuICAgIC8vIERvbid0IGV4cG9zZSBhbnkgc29mdC1kZWxldGVkIHRocmVhZHNcbiAgICBPYmplY3QudmFsdWVzKGNvbXB1dGVkLnRocmVhZHNCeUlkKS5maWx0ZXIoKHRocmVhZCkgPT4gIXRocmVhZC5kZWxldGVkQXQpLmZpbHRlcihcbiAgICAgICh0aHJlYWQpID0+IChcbiAgICAgICAgLy8gT25seSBrZWVwIGEgdGhyZWFkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBub24tZGVsZXRlZCBjb21tZW50XG4gICAgICAgIHRocmVhZC5jb21tZW50cy5zb21lKChjKSA9PiBjLmRlbGV0ZWRBdCA9PT0gdm9pZCAwKVxuICAgICAgKVxuICAgIClcbiAgKTtcbiAgY29uc3QgY2xlYW5lZE5vdGlmaWNhdGlvbnMgPSAoXG4gICAgLy8gU29ydCBzbyB0aGF0IHRoZSBtb3N0IHJlY2VudCBub3RpZmljYXRpb25zIGFyZSBmaXJzdFxuICAgIE9iamVjdC52YWx1ZXMoY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWQpLmZpbHRlcihcbiAgICAgIChpYm4pID0+IGlibi5raW5kID09PSBcInRocmVhZFwiID8gY29tcHV0ZWQudGhyZWFkc0J5SWRbaWJuLnRocmVhZElkXSAmJiBjb21wdXRlZC50aHJlYWRzQnlJZFtpYm4udGhyZWFkSWRdPy5kZWxldGVkQXQgPT09IHZvaWQgMCA6IHRydWVcbiAgICApLnNvcnQoKGEsIGIpID0+IGIubm90aWZpZWRBdC5nZXRUaW1lKCkgLSBhLm5vdGlmaWVkQXQuZ2V0VGltZSgpKVxuICApO1xuICByZXR1cm4ge1xuICAgIG5vdGlmaWNhdGlvbnM6IGNsZWFuZWROb3RpZmljYXRpb25zLFxuICAgIG5vdGlmaWNhdGlvbnNCeUlkOiBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZCxcbiAgICBzZXR0aW5nc0J5Um9vbUlkOiBjb21wdXRlZC5zZXR0aW5nc0J5Um9vbUlkLFxuICAgIHF1ZXJpZXMzOiBzdGF0ZS5xdWVyaWVzMyxcbiAgICBxdWVyaWVzNDogc3RhdGUucXVlcmllczQsXG4gICAgdGhyZWFkczogY2xlYW5lZFRocmVhZHMsXG4gICAgdGhyZWFkc0J5SWQ6IGNvbXB1dGVkLnRocmVhZHNCeUlkLFxuICAgIHZlcnNpb25zQnlSb29tSWQ6IHN0YXRlLnZlcnNpb25zQnlSb29tSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5VGhyZWFkVXBkYXRlcyhleGlzdGluZ1RocmVhZHMsIHVwZGF0ZXMpIHtcbiAgY29uc3QgdXBkYXRlZFRocmVhZHMgPSB7IC4uLmV4aXN0aW5nVGhyZWFkcyB9O1xuICB1cGRhdGVzLm5ld1RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB1cGRhdGVkVGhyZWFkc1t0aHJlYWQuaWRdO1xuICAgIGlmIChleGlzdGluZ1RocmVhZCkge1xuICAgICAgaWYgKGlzTW9yZVJlY2VudGx5VXBkYXRlZChleGlzdGluZ1RocmVhZCwgdGhyZWFkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZWRUaHJlYWRzW3RocmVhZC5pZF0gPSB0aHJlYWQ7XG4gIH0pO1xuICB1cGRhdGVzLmRlbGV0ZWRUaHJlYWRzLmZvckVhY2goKHsgaWQsIGRlbGV0ZWRBdCB9KSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB1cGRhdGVkVGhyZWFkc1tpZF07XG4gICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHJldHVybjtcbiAgICBleGlzdGluZ1RocmVhZC5kZWxldGVkQXQgPSBkZWxldGVkQXQ7XG4gICAgZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ID0gZGVsZXRlZEF0O1xuICAgIGV4aXN0aW5nVGhyZWFkLmNvbW1lbnRzID0gW107XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZFRocmVhZHM7XG59XG5mdW5jdGlvbiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKGV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSB7IC4uLmV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zIH07XG4gIHVwZGF0ZXMubmV3SW5ib3hOb3RpZmljYXRpb25zLmZvckVhY2goKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdO1xuICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgIG5vdGlmaWNhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdID0gbm90aWZpY2F0aW9uO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkTm90aWZpY2F0aW9ucy5mb3JFYWNoKFxuICAgICh7IGlkIH0pID0+IGRlbGV0ZSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW2lkXVxuICApO1xuICByZXR1cm4gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoaW5ib3hOb3RpZmljYXRpb25BLCBpbmJveE5vdGlmaWNhdGlvbkIpIHtcbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ICYmIGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAxIDogaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCB8fCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBjb21tZW50KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChjb21tZW50LnRocmVhZElkICE9PSB0aHJlYWQuaWQpIHtcbiAgICBjb25zb2xlMi53YXJuKFxuICAgICAgYENvbW1lbnQgJHtjb21tZW50LmlkfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhyZWFkICR7dGhyZWFkLmlkfWBcbiAgICApO1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoXG4gICAgICBNYXRoLm1heCh0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMCwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbLi4udGhyZWFkLmNvbW1lbnRzLCBjb21tZW50XVxuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGNvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPD0gY29tbWVudC5lZGl0ZWRBdCkge1xuICAgIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZCA/IGNvbW1lbnQgOiBleGlzdGluZ0NvbW1lbnQyXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDAsXG4gICAgICAgICAgY29tbWVudC5lZGl0ZWRBdD8uZ2V0VGltZSgpIHx8IGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgcmV0dXJuIHRocmVhZDtcbn1cbmZ1bmN0aW9uIGFwcGx5RGVsZXRlQ29tbWVudCh0aHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgLy8gV2Ugb3B0aW1pc3RpY2FsbHkgcmVtb3ZlIHRoZSBjb21tZW50IGJvZHkgYW5kIGF0dGFjaG1lbnRzIHdoZW4gbWFya2luZyBpdCBhcyBkZWxldGVkXG4gICAgICBib2R5OiB2b2lkIDAsXG4gICAgICBhdHRhY2htZW50czogW11cbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAodXBkYXRlZENvbW1lbnRzLmV2ZXJ5KChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IHVwc2VydFJlYWN0aW9uKGNvbW1lbnQucmVhY3Rpb25zLCByZWFjdGlvbilcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVhY3Rpb24uY3JlYXRlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDApXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseVJlbW92ZVJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgdXNlcnM6IHJlYWN0aW9uLnVzZXJzLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkKVxuICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICkuZmlsdGVyKChyZWFjdGlvbikgPT4gcmVhY3Rpb24udXNlcnMubGVuZ3RoID4gMClcbiAgICAgIC8vIFJlbW92ZSByZWFjdGlvbnMgd2l0aCBubyB1c2VycyBsZWZ0XG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlbW92ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gdXBzZXJ0UmVhY3Rpb24ocmVhY3Rpb25zLCByZWFjdGlvbikge1xuICBjb25zdCBleGlzdGluZ1JlYWN0aW9uID0gcmVhY3Rpb25zLmZpbmQoXG4gICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamlcbiAgKTtcbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5yZWFjdGlvbnMsXG4gICAgICB7XG4gICAgICAgIGVtb2ppOiByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgY3JlYXRlZEF0OiByZWFjdGlvbi5jcmVhdGVkQXQsXG4gICAgICAgIHVzZXJzOiBbeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoZXhpc3RpbmdSZWFjdGlvbi51c2Vycy5zb21lKCh1c2VyKSA9PiB1c2VyLmlkID09PSByZWFjdGlvbi51c2VySWQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFjdGlvbnMubWFwKFxuICAgICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamkgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nUmVhY3Rpb24yLFxuICAgICAgICB1c2VyczogWy4uLmV4aXN0aW5nUmVhY3Rpb24yLnVzZXJzLCB7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH0gOiBleGlzdGluZ1JlYWN0aW9uMlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9ucztcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGNyZWF0ZUNsaWVudCxcbiAga0ludGVybmFsIGFzIGtJbnRlcm5hbDIsXG4gIG1ha2VQb2xsZXIsXG4gIHJhaXNlLFxuICBzaGFsbG93IGFzIHNoYWxsb3czXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgUmVhY3QzLCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsXG4gIHVzZU1lbW9cbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanNcIjtcblxuLy8gc3JjL2xpYi9zaGFsbG93Mi50c1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0Miwgc2hhbGxvdyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzaGFsbG93MihhLCBiKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdDIoYSkgfHwgIWlzUGxhaW5PYmplY3QyKGIpKSB7XG4gICAgcmV0dXJuIHNoYWxsb3coYSwgYik7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSAmJiBzaGFsbG93KGFba2V5XSwgYltrZXldKVxuICApO1xufVxuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvbGliL3VzZS1sYXRlc3QudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUxhdGVzdCh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYodmFsdWUpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLy8gc3JjL2xpYi91c2UtaW5pdGlhbC50c1xudmFyIG5vb3AyID0gKHN0YXRlKSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIHVzZUluaXRpYWwodmFsdWUpIHtcbiAgcmV0dXJuIHVzZVJlZHVjZXIobm9vcDIsIHZhbHVlKVswXTtcbn1cbmZ1bmN0aW9uIHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihsYXRlc3RWYWx1ZSkge1xuICBjb25zdCBmcm96ZW5WYWx1ZSA9IHVzZUluaXRpYWwobGF0ZXN0VmFsdWUpO1xuICBpZiAodHlwZW9mIGZyb3plblZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCByZWYgPSB1c2VMYXRlc3QobGF0ZXN0VmFsdWUpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4gcmVmLmN1cnJlbnQoLi4uYXJncyksIFtcbiAgICAgIHJlZlxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm96ZW5WYWx1ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3VzZS1wb2x5ZmlsbC50c1xudmFyIHVzZSA9IChcbiAgLy8gUmVhY3QudXNlIHx8XG4gIChwcm9taXNlKSA9PiB7XG4gICAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICAodikgPT4ge1xuICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH1cbiAgfVxuKTtcblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG52YXIgQ2xpZW50Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKG51bGwpO1xuZnVuY3Rpb24gbWlzc2luZ1VzZXJFcnJvcih1c2VySWQpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgcmVzb2x2ZVVzZXJzIGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZm9yIHVzZXIgJyR7dXNlcklkfSdgKTtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdSb29tSW5mb0Vycm9yKHJvb21JZCkge1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgIGByZXNvbHZlUm9vbXNJbmZvIGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZm9yIHJvb20gJyR7cm9vbUlkfSdgXG4gICk7XG59XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxudmFyIF91bWJyZWxsYVN0b3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9leHRyYXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIFBPTExJTkdfSU5URVJWQUwgPSA2MCAqIDFlMztcbmZ1bmN0aW9uIHNlbGVjdFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KGluYm94Tm90aWZpY2F0aW9ucykge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGNvbnN0IG5vdGlmaWNhdGlvbiBvZiBpbmJveE5vdGlmaWNhdGlvbnMpIHtcbiAgICBpZiAobm90aWZpY2F0aW9uLnJlYWRBdCA9PT0gbnVsbCB8fCBub3RpZmljYXRpb24ucmVhZEF0IDwgbm90aWZpY2F0aW9uLm5vdGlmaWVkQXQpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KHJlc3VsdCkge1xuICBpZiAoIXJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBjb3VudDogc2VsZWN0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQocmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucylcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVVzZXIoc3RhdGUsIHVzZXJJZCkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCB8fCBzdGF0ZT8uaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlID8/IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghc3RhdGUuZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG1pc3NpbmdVc2VyRXJyb3IodXNlcklkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVzZXI6IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVJvb21JbmZvKHN0YXRlLCByb29tSWQpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIXN0YXRlLmRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgaW5mbzogc3RhdGUuZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVDb250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBsZXQgYnVuZGxlID0gX2J1bmRsZXMuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZUxpdmVibG9ja3NDb250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMuc2V0KGNsaWVudCwgYnVuZGxlKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IHN0b3JlID0gX3VtYnJlbGxhU3RvcmVzLmdldChjbGllbnQpO1xuICBpZiAoIXN0b3JlKSB7XG4gICAgc3RvcmUgPSBuZXcgVW1icmVsbGFTdG9yZShjbGllbnQpO1xuICAgIF91bWJyZWxsYVN0b3Jlcy5zZXQoY2xpZW50LCBzdG9yZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IGV4dHJhcyA9IF9leHRyYXMuZ2V0KGNsaWVudCk7XG4gIGlmICghZXh0cmFzKSB7XG4gICAgZXh0cmFzID0gbWFrZUxpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBfZXh0cmFzLnNldChjbGllbnQsIGV4dHJhcyk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhcztcbn1cbmZ1bmN0aW9uIG1ha2VEZWx0YVBvbGxlcl9Ob3RpZmljYXRpb25zKHN0b3JlKSB7XG4gIGNvbnN0IHBvbGxlciA9IG1ha2VQb2xsZXIoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzdG9yZS53YWl0VW50aWxOb3RpZmljYXRpb25zTG9hZGVkKCk7XG4gICAgICBhd2FpdCBzdG9yZS5mZXRjaE5vdGlmaWNhdGlvbnNEZWx0YVVwZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBQb2xsaW5nIG5ldyBpbmJveCBub3RpZmljYXRpb25zIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICB9XG4gIH0sIFBPTExJTkdfSU5URVJWQUwpO1xuICBsZXQgcG9sbGVyU3Vic2NyaWJlcnMgPSAwO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHBvbGxlclN1YnNjcmliZXJzKys7XG4gICAgcG9sbGVyLmVuYWJsZShwb2xsZXJTdWJzY3JpYmVycyA+IDApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXJTdWJzY3JpYmVycy0tO1xuICAgICAgcG9sbGVyLmVuYWJsZShwb2xsZXJTdWJzY3JpYmVycyA+IDApO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlRGVsdGFQb2xsZXJfVXNlclRocmVhZHMoc3RvcmUpIHtcbiAgY29uc3QgcG9sbGVyID0gbWFrZVBvbGxlcihhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHN0b3JlLmZldGNoVXNlclRocmVhZHNEZWx0YVVwZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBQb2xsaW5nIG5ldyB1c2VyIHRocmVhZHMgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgIH1cbiAgfSwgUE9MTElOR19JTlRFUlZBTCk7XG4gIGxldCBwb2xsZXJTdWJzY3JpYmVycyA9IDA7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcG9sbGVyU3Vic2NyaWJlcnMrKztcbiAgICBwb2xsZXIuZW5hYmxlKHBvbGxlclN1YnNjcmliZXJzID4gMCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlclN1YnNjcmliZXJzLS07XG4gICAgICBwb2xsZXIuZW5hYmxlKHBvbGxlclN1YnNjcmliZXJzID4gMCk7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICAvKipcbiAgICAgKiBTdWIvdW5zdWIgcGFpciB0byBzdGFydCB0aGUgcHJvY2VzcyBvZiB3YXRjaGluZyBmb3IgbmV3IGluY29taW5nIGluYm94XG4gICAgICogbm90aWZpY2F0aW9ucyB0aHJvdWdoIGEgc3RyZWFtIG9mIGRlbHRhIHVwZGF0ZXMuIENhbGwgdGhlIHVuc3ViIGZ1bmN0aW9uXG4gICAgICogcmV0dXJuZWQgdG8gc3RvcCB0aGlzIHN1YnNjcmlwdGlvbiB3aGVuIHVubW91bnRpbmcuIEN1cnJlbnRseVxuICAgICAqIGltcGxlbWVudGVkIGJ5IGEgcGVyaW9kaWMgcG9sbGVyLlxuICAgICAqL1xuICAgIHN1YnNjcmliZVRvTm90aWZpY2F0aW9uc0RlbHRhVXBkYXRlczogbWFrZURlbHRhUG9sbGVyX05vdGlmaWNhdGlvbnMoc3RvcmUpLFxuICAgIC8qKlxuICAgICAqIFN1Yi91bnN1YiBwYWlyIHRvIHN0YXJ0IHRoZSBwcm9jZXNzIG9mIHdhdGNoaW5nIGZvciBuZXcgdXNlciB0aHJlYWRzXG4gICAgICogdGhyb3VnaCBhIHN0cmVhbSBvZiBkZWx0YSB1cGRhdGVzLiBDYWxsIHRoZSB1bnN1YiBmdW5jdGlvbiByZXR1cm5lZCB0b1xuICAgICAqIHN0b3AgdGhpcyBzdWJzY3JpcHRpb24gd2hlbiB1bm1vdW50aW5nLiBDdXJyZW50bHkgaW1wbGVtZW50ZWQgYnlcbiAgICAgKiBhIHBlcmlvZGljIHBvbGxlci5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmVUb1VzZXJUaHJlYWRzRGVsdGFVcGRhdGVzOiBtYWtlRGVsdGFQb2xsZXJfVXNlclRocmVhZHMoc3RvcmUpXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMiA9IChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIGNvbnN0IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIgPSAoKSA9PiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkMiA9ICgpID0+IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIgPSAoKSA9PiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIgPSAoKSA9PiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpO1xuICBmdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIyKHByb3BzKSB7XG4gICAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIoKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudCB9LCBwcm9wcy5jaGlsZHJlbik7XG4gIH1cbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBjb25zdCBidW5kbGUgPSB7XG4gICAgTGl2ZWJsb2Nrc1Byb3ZpZGVyOiBMaXZlYmxvY2tzUHJvdmlkZXIyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9uczogKCkgPT4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50LCBpZGVudGl0eSwgc2hhbGxvdzMpLFxuICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyLFxuICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uOiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIsXG4gICAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zOiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICAgIC4uLnNoYXJlZC5jbGFzc2ljLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBMaXZlYmxvY2tzUHJvdmlkZXI6IExpdmVibG9ja3NQcm92aWRlcjIsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnM6ICgpID0+IHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDogdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMixcbiAgICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgICAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb246IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMixcbiAgICAgIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgICB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWw6IHVzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsLFxuICAgICAgLi4uc2hhcmVkLnN1c3BlbnNlXG4gICAgfVxuICB9O1xuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50LCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCB7XG4gICAgc3RvcmUsXG4gICAgc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zRGVsdGFVcGRhdGVzOiBzdWJzY3JpYmVUb0RlbHRhVXBkYXRlc1xuICB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICB2b2lkIHN0b3JlLndhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gIH0pO1xuICB1c2VFZmZlY3QzKHN1YnNjcmliZVRvRGVsdGFVcGRhdGVzLCBbc3Vic2NyaWJlVG9EZWx0YVVwZGF0ZXNdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN0b3JlLnN1YnNjcmliZVRocmVhZHNPckluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBzdG9yZS5nZXRJbmJveE5vdGlmaWNhdGlvbnNBc3luYyxcbiAgICBzdG9yZS5nZXRJbmJveE5vdGlmaWNhdGlvbnNBc3luYyxcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLndhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCwgaWRlbnRpdHksIHNoYWxsb3czKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KFxuICAgIGNsaWVudCxcbiAgICBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBzaGFsbG93M1xuICApO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLndhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQoY2xpZW50KTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICByZWFkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50Lm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUudXBkYXRlSW5ib3hOb3RpZmljYXRpb24oXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uKSA9PiAoeyAuLi5pbmJveE5vdGlmaWNhdGlvbiwgcmVhZEF0IH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCByZWFkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCIsXG4gICAgICByZWFkQXRcbiAgICB9KTtcbiAgICBjbGllbnQubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnVwZGF0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uKSA9PiAoeyAuLi5pbmJveE5vdGlmaWNhdGlvbiwgcmVhZEF0IH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJkZWxldGUtaW5ib3gtbm90aWZpY2F0aW9uXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgIGRlbGV0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnQuZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLWFsbC1pbmJveC1ub3RpZmljYXRpb25zXCIsXG4gICAgICBkZWxldGVkQXRcbiAgICB9KTtcbiAgICBjbGllbnQuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRfd2l0aENsaWVudChjbGllbnQsIGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBnZXR0ZXIgPSBzdG9yZS5nZXRGdWxsU3RhdGU7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBzdGF0ZS5ub3RpZmljYXRpb25zQnlJZFtpbmJveE5vdGlmaWNhdGlvbklkXSA/PyByYWlzZShgSW5ib3ggbm90aWZpY2F0aW9uIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uSWR9XCIgbm90IGZvdW5kYCk7XG4gICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24ua2luZCAhPT0gXCJ0aHJlYWRcIikge1xuICAgICAgICByYWlzZShcbiAgICAgICAgICBgSW5ib3ggbm90aWZpY2F0aW9uIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uSWR9XCIgaXMgbm90IG9mIGtpbmQgXCJ0aHJlYWRcImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRocmVhZCA9IHN0YXRlLnRocmVhZHNCeUlkW2luYm94Tm90aWZpY2F0aW9uLnRocmVhZElkXSA/PyByYWlzZShcbiAgICAgICAgYFRocmVhZCB3aXRoIElEIFwiJHtpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZH1cIiBub3QgZm91bmQsIHRoaXMgaW5ib3ggbm90aWZpY2F0aW9uIG1pZ2h0IG5vdCBiZSBvZiBraW5kIFwidGhyZWFkXCJgXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRocmVhZDtcbiAgICB9LFxuICAgIFtpbmJveE5vdGlmaWNhdGlvbklkXVxuICApO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3RvcmUuc3Vic2NyaWJlVGhyZWFkc09ySW5ib3hOb3RpZmljYXRpb25zLFxuICAgIC8vIFJlLWV2YWx1YXRlIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGFueSB0aW1lIHRoZSBub3RpZmljYXRpb24gY2hhbmdlcyBvdmVyIHRpbWVcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIHNlbGVjdG9yXG4gICk7XG59XG5mdW5jdGlvbiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpIHtcbiAgY29uc3QgdXNlcnNTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS51c2Vyc1N0b3JlO1xuICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gdXNlcnNTdG9yZS5nZXRTdGF0ZSh1c2VySWQpLFxuICAgIFt1c2Vyc1N0b3JlLCB1c2VySWRdXG4gICk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIHZvaWQgdXNlcnNTdG9yZS5nZXQodXNlcklkKTtcbiAgfSwgW3VzZXJzU3RvcmUsIHVzZXJJZF0pO1xuICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMihcbiAgICAoc3RhdGUpID0+IHNlbGVjdG9yRm9yX3VzZVVzZXIoc3RhdGUsIHVzZXJJZCksXG4gICAgW3VzZXJJZF1cbiAgKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHVzZXJzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFVzZXJTdGF0ZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgc2VsZWN0b3IsXG4gICAgc2hhbGxvdzNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSB7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0udXNlcnNTdG9yZTtcbiAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICBbdXNlcnNTdG9yZSwgdXNlcklkXVxuICApO1xuICBjb25zdCB1c2VyU3RhdGUgPSBnZXRVc2VyU3RhdGUoKTtcbiAgaWYgKCF1c2VyU3RhdGUgfHwgdXNlclN0YXRlLmlzTG9hZGluZykge1xuICAgIHRocm93IHVzZXJzU3RvcmUuZ2V0KHVzZXJJZCk7XG4gIH1cbiAgaWYgKHVzZXJTdGF0ZS5lcnJvcikge1xuICAgIHRocm93IHVzZXJTdGF0ZS5lcnJvcjtcbiAgfVxuICBpZiAoIXVzZXJTdGF0ZS5kYXRhKSB7XG4gICAgdGhyb3cgbWlzc2luZ1VzZXJFcnJvcih1c2VySWQpO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIGdldFVzZXJTdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXNlcjogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb193aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKSB7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnJvb21zSW5mb1N0b3JlO1xuICBjb25zdCBnZXRSb29tSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldFN0YXRlKHJvb21JZCksXG4gICAgW3Jvb21zSW5mb1N0b3JlLCByb29tSWRdXG4gICk7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4gc2VsZWN0b3JGb3JfdXNlUm9vbUluZm8oc3RhdGUsIHJvb21JZCksXG4gICAgW3Jvb21JZF1cbiAgKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgdm9pZCByb29tc0luZm9TdG9yZS5nZXQocm9vbUlkKTtcbiAgfSwgW3Jvb21zSW5mb1N0b3JlLCByb29tSWRdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHJvb21zSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgc2VsZWN0b3IsXG4gICAgc2hhbGxvdzNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCkge1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS5yb29tc0luZm9TdG9yZTtcbiAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRTdGF0ZShyb29tSWQpLFxuICAgIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkXVxuICApO1xuICBjb25zdCByb29tSW5mb1N0YXRlID0gZ2V0Um9vbUluZm9TdGF0ZSgpO1xuICBpZiAoIXJvb21JbmZvU3RhdGUgfHwgcm9vbUluZm9TdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyByb29tc0luZm9TdG9yZS5nZXQocm9vbUlkKTtcbiAgfVxuICBpZiAocm9vbUluZm9TdGF0ZS5lcnJvcikge1xuICAgIHRocm93IHJvb21JbmZvU3RhdGUuZXJyb3I7XG4gIH1cbiAgaWYgKCFyb29tSW5mb1N0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICBhc3NlcnQoc3RhdGUuZGF0YSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyByb29tIGluZm8gZGF0YVwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpIHtcbiAgY29uc3QgdXNlQ2xpZW50MiA9ICgpID0+IGNsaWVudDtcbiAgcmV0dXJuIHtcbiAgICBjbGFzc2ljOiB7XG4gICAgICB1c2VDbGllbnQ6IHVzZUNsaWVudDIsXG4gICAgICB1c2VVc2VyOiAodXNlcklkKSA9PiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlSXNJbnNpZGVSb29tXG4gICAgfSxcbiAgICBzdXNwZW5zZToge1xuICAgICAgdXNlQ2xpZW50OiB1c2VDbGllbnQyLFxuICAgICAgdXNlVXNlcjogKHVzZXJJZCkgPT4gdXNlVXNlclN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCksXG4gICAgICB1c2VJc0luc2lkZVJvb21cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcihvcHRpb25zKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gdXNlQ2xpZW50T3JOdWxsKCk7XG4gIGlmICghb3B0aW9ucz8uYWxsb3dOZXN0aW5nICYmIGV4aXN0aW5nICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IG5lc3QgbXVsdGlwbGUgTGl2ZWJsb2Nrc1Byb3ZpZGVyIGluc3RhbmNlcyBpbiB0aGUgc2FtZSBSZWFjdCB0cmVlLlwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlQ2xpZW50T3JOdWxsKCkge1xuICByZXR1cm4gdXNlQ29udGV4dDIoQ2xpZW50Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VDbGllbnQoKSB7XG4gIHJldHVybiB1c2VDbGllbnRPck51bGwoKSA/PyByYWlzZShcIkxpdmVibG9ja3NQcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xufVxuZnVuY3Rpb24gTGl2ZWJsb2Nrc1Byb3ZpZGVyV2l0aENsaWVudChwcm9wcykge1xuICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcihwcm9wcyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQ2xpZW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvcHMuY2xpZW50IH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcihwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5vIH0gPSBwcm9wcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBwdWJsaWNBcGlLZXk6IHVzZUluaXRpYWwoby5wdWJsaWNBcGlLZXkpLFxuICAgIHRocm90dGxlOiB1c2VJbml0aWFsKG8udGhyb3R0bGUpLFxuICAgIGxvc3RDb25uZWN0aW9uVGltZW91dDogdXNlSW5pdGlhbChvLmxvc3RDb25uZWN0aW9uVGltZW91dCksXG4gICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQ6IHVzZUluaXRpYWwoby5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCksXG4gICAgcG9seWZpbGxzOiB1c2VJbml0aWFsKG8ucG9seWZpbGxzKSxcbiAgICB1bnN0YWJsZV9mYWxsYmFja1RvSFRUUDogdXNlSW5pdGlhbChvLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQKSxcbiAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiB1c2VJbml0aWFsKG8udW5zdGFibGVfc3RyZWFtRGF0YSksXG4gICAgYXV0aEVuZHBvaW50OiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5hdXRoRW5kcG9pbnQpLFxuICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihcbiAgICAgIG8ucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc1xuICAgICksXG4gICAgcmVzb2x2ZVVzZXJzOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5yZXNvbHZlVXNlcnMpLFxuICAgIHJlc29sdmVSb29tc0luZm86IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLnJlc29sdmVSb29tc0luZm8pLFxuICAgIGJhc2VVcmw6IHVzZUluaXRpYWwoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSGlkZGVuIGNvbmZpZyBvcHRpb25zXG4gICAgICBvLmJhc2VVcmxcbiAgICApLFxuICAgIGVuYWJsZURlYnVnTG9nZ2luZzogdXNlSW5pdGlhbChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBIaWRkZW4gY29uZmlnIG9wdGlvbnNcbiAgICAgIG8uZW5hYmxlRGVidWdMb2dnaW5nXG4gICAgKVxuICB9O1xuICBjb25zdCBjbGllbnQgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudChvcHRpb25zKSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQsIHsgY2xpZW50IH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0KGNsaWVudCkge1xuICByZXR1cm4gZ2V0T3JDcmVhdGVDb250ZXh0QnVuZGxlKGNsaWVudCk7XG59XG5mdW5jdGlvbiB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucyA9IHtcbiAgcXVlcnk6IHtcbiAgICBtZXRhZGF0YToge31cbiAgfVxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSwgc3Vic2NyaWJlVG9Vc2VyVGhyZWFkc0RlbHRhVXBkYXRlczogc3Vic2NyaWJlVG9EZWx0YVVwZGF0ZXMgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRWZmZWN0MyhcbiAgICAoKSA9PiB7XG4gICAgICB2b2lkIHN0b3JlLndhaXRVbnRpbFVzZXJUaHJlYWRzTG9hZGVkKG9wdGlvbnMucXVlcnkpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHVzZUVmZmVjdDMoc3Vic2NyaWJlVG9EZWx0YVVwZGF0ZXMsIFtzdWJzY3JpYmVUb0RlbHRhVXBkYXRlc10pO1xuICBjb25zdCBnZXR0ZXIgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gc3RvcmUuZ2V0VXNlclRocmVhZHNBc3luYyhvcHRpb25zLnF1ZXJ5KSxcbiAgICBbc3RvcmUsIG9wdGlvbnMucXVlcnldXG4gICk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdG9yZS5zdWJzY3JpYmVVc2VyVGhyZWFkcyxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5LFxuICAgIHNoYWxsb3cyXG4gICAgLy8gTk9URTogVXNpbmcgMi1sZXZlbC1kZWVwIHNoYWxsb3cgY2hlY2sgaGVyZSwgYmVjYXVzZSB0aGUgcmVzdWx0IG9mIHNlbGVjdFRocmVhZHMoKSBpcyBub3Qgc3RhYmxlIVxuICApO1xufVxuZnVuY3Rpb24gdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwob3B0aW9ucyA9IHtcbiAgcXVlcnk6IHtcbiAgICBtZXRhZGF0YToge31cbiAgfVxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsVXNlclRocmVhZHNMb2FkZWQob3B0aW9ucy5xdWVyeSkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucyk7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KHVzZUNsaWVudCgpLCBpZGVudGl0eSwgc2hhbGxvdzMpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoXG4gICAgdXNlQ2xpZW50KCksXG4gICAgaW5ib3hOb3RpZmljYXRpb25JZFxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoKSB7XG4gIHJldHVybiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gIHJldHVybiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbigpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVXNlcih1c2VySWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpO1xufVxuZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlKHVzZXJJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvKHJvb21JZCkge1xuICByZXR1cm4gdXNlUm9vbUluZm9fd2l0aENsaWVudCh1c2VDbGllbnQoKSwgcm9vbUlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Uocm9vbUlkKSB7XG4gIHJldHVybiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIHJvb21JZCk7XG59XG52YXIgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkID0gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ7XG52YXIgX3VzZVVzZXIgPSB1c2VVc2VyO1xudmFyIF91c2VVc2VyU3VzcGVuc2UgPSB1c2VVc2VyU3VzcGVuc2U7XG52YXIgX3VzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCA9IHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbDtcbnZhciBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwgPSB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbDtcblxuLy8gc3JjL3R5cGVzL2Vycm9ycy50c1xudmFyIENyZWF0ZVRocmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgdGhyZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJDcmVhdGVUaHJlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIERlbGV0ZVRocmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgdGhyZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJEZWxldGVUaHJlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIEVkaXRUaHJlYWRNZXRhZGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJFZGl0IHRocmVhZCBtZXRhZGF0YSBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRWRpdFRocmVhZE1ldGFkYXRhRXJyb3JcIjtcbiAgfVxufTtcbnZhciBNYXJrVGhyZWFkQXNSZXNvbHZlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJNYXJrIHRocmVhZCBhcyByZXNvbHZlZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTWFya1RocmVhZEFzUmVzb2x2ZWRFcnJvclwiO1xuICB9XG59O1xudmFyIE1hcmtUaHJlYWRBc1VucmVzb2x2ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiTWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTWFya1RocmVhZEFzVW5yZXNvbHZlZEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ3JlYXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdENvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0Q29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRGVsZXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRGVsZXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQWRkUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQWRkIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJBZGRSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgUmVtb3ZlUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiUmVtb3ZlIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJSZW1vdmVSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIk1hcmsgaW5ib3ggbm90aWZpY2F0aW9uIGFzIHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIk1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiVXBkYXRlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IHNoYWxsb3cgYXMgc2hhbGxvdzQgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBhc3NlcnQgYXMgYXNzZXJ0MixcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgY29uc29sZSBhcyBjb25zb2xlMyxcbiAgY3JlYXRlQ29tbWVudElkLFxuICBjcmVhdGVUaHJlYWRJZCxcbiAgZGVwcmVjYXRlSWYsXG4gIGVycm9ySWYsXG4gIGtJbnRlcm5hbCBhcyBrSW50ZXJuYWwzLFxuICBtYWtlRXZlbnRTb3VyY2UgYXMgbWFrZUV2ZW50U291cmNlMixcbiAgbWFrZVBvbGxlciBhcyBtYWtlUG9sbGVyMixcbiAgTm90aWZpY2F0aW9uc0FwaUVycm9yLFxuICBTZXJ2ZXJNc2dDb2RlXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgKiBhcyBSZWFjdDUgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9saWIvcmV0cnktZXJyb3IudHNcbnZhciBNQVhfRVJST1JfUkVUUllfQ09VTlQgPSA1O1xudmFyIEVSUk9SX1JFVFJZX0lOVEVSVkFMID0gNWUzO1xuZnVuY3Rpb24gcmV0cnlFcnJvcihhY3Rpb24sIHJldHJ5Q291bnQpIHtcbiAgaWYgKHJldHJ5Q291bnQgPj0gTUFYX0VSUk9SX1JFVFJZX0NPVU5UKSByZXR1cm47XG4gIGNvbnN0IHRpbWVvdXQgPSBNYXRoLnBvdygyLCByZXRyeUNvdW50KSAqIEVSUk9SX1JFVFJZX0lOVEVSVkFMO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB2b2lkIGFjdGlvbigpO1xuICB9LCB0aW1lb3V0KTtcbn1cblxuLy8gc3JjL3VzZS1zY3JvbGwtdG8tY29tbWVudC1vbi1sb2FkLWVmZmVjdC50c1xuaW1wb3J0ICogYXMgUmVhY3Q0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsVG9Db21tZW50T25Mb2FkKHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgaWYgKHNob3VsZFNjcm9sbE9uTG9hZCA9PT0gZmFsc2UpIHJldHVybjtcbiAgaWYgKCFzdGF0ZS50aHJlYWRzKSByZXR1cm47XG4gIGNvbnN0IGlzV2luZG93RGVmaW5lZCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmICghaXNXaW5kb3dEZWZpbmVkKSByZXR1cm47XG4gIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgY29uc3QgY29tbWVudElkID0gaGFzaC5zbGljZSgxKTtcbiAgaWYgKCFjb21tZW50SWQuc3RhcnRzV2l0aChcImNtX1wiKSkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29tbWVudElkKTtcbiAgaWYgKGNvbW1lbnQgPT09IG51bGwpIHJldHVybjtcbiAgY29uc3QgY29tbWVudHMgPSBzdGF0ZS50aHJlYWRzLmZsYXRNYXAoKHRocmVhZCkgPT4gdGhyZWFkLmNvbW1lbnRzKTtcbiAgY29uc3QgaXNDb21tZW50SW5UaHJlYWRzID0gY29tbWVudHMuc29tZShcbiAgICAoY29tbWVudDIpID0+IGNvbW1lbnQyLmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKCFpc0NvbW1lbnRJblRocmVhZHMpIHJldHVybjtcbiAgY29tbWVudC5zY3JvbGxJbnRvVmlldygpO1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgUmVhY3Q0LnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSk7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFdlIG9ubHkgd2FudCB0byBydW4gdGhpcyBlZmZlY3Qgb25jZVxuICAgIFtzdGF0ZS5pc0xvYWRpbmddXG4gICk7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxudmFyIFNNT09USF9ERUxBWSA9IDFlMztcbnZhciBub29wMyA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkyID0gKHgpID0+IHg7XG52YXIgbWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IChyZWFjdFZlcnNpb24sIHJvb21JZCkgPT4gYFdlIG5vdGljZWQgeW91XFx1MjAxOXJlIHVzaW5nIFJlYWN0ICR7cmVhY3RWZXJzaW9ufS4gUGxlYXNlIHBhc3MgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgYXQgdGhlIFJvb21Qcm92aWRlciBsZXZlbCB1bnRpbCB5b3VcXHUyMDE5cmUgcmVhZHkgdG8gdXBncmFkZSB0byBSZWFjdCAxODpcblxuICAgIGltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiOyAgLy8gb3IgXCJyZWFjdC1uYXRpdmVcIlxuXG4gICAgPFJvb21Qcm92aWRlciBpZD0ke0pTT04uc3RyaW5naWZ5KFxuICByb29tSWRcbil9IC4uLiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz17dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXN9PlxuICAgICAgLi4uXG4gICAgPC9Sb29tUHJvdmlkZXI+XG5cbldoeT8gUGxlYXNlIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS90cm91Ymxlc2hvb3Rpbmcjc3RhbGUtcHJvcHMtem9tYmllLWNoaWxkIGZvciBtb3JlIGluZm9ybWF0aW9uYDtcbnZhciBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IFwiWW91IGRvblxcdTIwMTl0IG5lZWQgdG8gcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB0byBSb29tUHJvdmlkZXIgYW55bW9yZSwgc2luY2UgeW91XFx1MjAxOXJlIG9uIFJlYWN0IDE4KyBhbHJlYWR5LlwiO1xuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUyKHMsIGdzLCBnc3MpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihzLCBncywgZ3NzLCBpZGVudGl0eTIpO1xufVxudmFyIFNUQUJMRV9FTVBUWV9MSVNUID0gT2JqZWN0LmZyZWV6ZShbXSk7XG52YXIgUE9MTElOR19JTlRFUlZBTDIgPSA1ICogNjAgKiAxZTM7XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlT3RoZXJzQ29ubmVjdGlvbklkcyhvdGhlcnMpIHtcbiAgcmV0dXJuIG90aGVycy5tYXAoKHVzZXIpID0+IHVzZXIuY29ubmVjdGlvbklkKTtcbn1cbmZ1bmN0aW9uIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSkge1xuICBjb25zdCBjYW5ub3RVc2VVbnRpbCA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbFwiO1xuICBjb25zdCBuZWVkc1ByZXNlbmNlID0gYCR7Y2Fubm90VXNlVW50aWx9IGNvbm5lY3RlZCB0byB0aGUgTGl2ZWJsb2NrcyByb29tYDtcbiAgY29uc3QgbmVlZHNTdG9yYWdlID0gYCR7Y2Fubm90VXNlVW50aWx9IHN0b3JhZ2UgaGFzIGJlZW4gbG9hZGVkYDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgIGNvbnN0IG11dGFibGVSb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgICAgIGlmIChtdXRhYmxlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNTdG9yYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhYmxlUm9vdDtcbiAgICB9LFxuICAgIGdldCBzZWxmKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICAgICAgaWYgKHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5lZWRzUHJlc2VuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBnZXQgb3RoZXJzKCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gcm9vbS5nZXRPdGhlcnMoKTtcbiAgICAgIGlmIChyb29tLmdldFNlbGYoKSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNQcmVzZW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZChyb29tKSB7XG4gIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgaWYgKHNlbGYgPT09IG51bGwgfHwgc2VsZi5pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlbGYuaWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUFwaUVycm9yKGVycikge1xuICBjb25zdCBtZXNzYWdlID0gYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7ZXJyLnN0YXR1c306ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgaWYgKGVyci5kZXRhaWxzPy5lcnJvciA9PT0gXCJGT1JCSURERU5cIikge1xuICAgIGNvbnN0IGRldGFpbGVkTWVzc2FnZSA9IFttZXNzYWdlLCBlcnIuZGV0YWlscy5zdWdnZXN0aW9uLCBlcnIuZGV0YWlscy5kb2NzXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICBjb25zb2xlMy5lcnJvcihkZXRhaWxlZE1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBtYWtlRGVsdGFQb2xsZXJfUm9vbVRocmVhZHMoY2xpZW50KSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBwb2xsZXIgPSBtYWtlUG9sbGVyMihhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgcm9vbUlkcyA9IGNsaWVudFtrSW50ZXJuYWwzXS5nZXRSb29tSWRzKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgcm9vbUlkcy5tYXAoKHJvb21JZCkgPT4ge1xuICAgICAgICBjb25zdCByb29tID0gY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgaWYgKHJvb20gPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmZldGNoUm9vbVRocmVhZHNEZWx0YVVwZGF0ZShyb29tLmlkKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfSwgUE9MTElOR19JTlRFUlZBTDIpO1xuICBsZXQgcG9sbGVyU3Vic2NyaWJlcnMgPSAwO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHBvbGxlclN1YnNjcmliZXJzKys7XG4gICAgcG9sbGVyLmVuYWJsZShwb2xsZXJTdWJzY3JpYmVycyA+IDApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXJTdWJzY3JpYmVycy0tO1xuICAgICAgcG9sbGVyLmVuYWJsZShwb2xsZXJTdWJzY3JpYmVycyA+IDApO1xuICAgIH07XG4gIH07XG59XG52YXIgX2V4dHJhczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGxldCBidW5kbGUgPSBfYnVuZGxlczIuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMyLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzMi5nZXQoY2xpZW50KTtcbiAgaWYgKCFleHRyYXMpIHtcbiAgICBleHRyYXMgPSBtYWtlUm9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIF9leHRyYXMyLnNldChjbGllbnQsIGV4dHJhcyk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhcztcbn1cbmZ1bmN0aW9uIG1ha2VSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcmVxdWVzdHNCeVF1ZXJ5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0Um9vbVZlcnNpb25zKHJvb20sIHsgcmV0cnlDb3VudCB9ID0geyByZXRyeUNvdW50OiAwIH0pIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VWZXJzaW9uc1F1ZXJ5S2V5KHJvb20uaWQpO1xuICAgIGNvbnN0IGV4aXN0aW5nUmVxdWVzdCA9IHJlcXVlc3RzQnlRdWVyeS5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChleGlzdGluZ1JlcXVlc3QgIT09IHZvaWQgMCkgcmV0dXJuIGV4aXN0aW5nUmVxdWVzdDtcbiAgICBjb25zdCByZXF1ZXN0ID0gcm9vbVtrSW50ZXJuYWwzXS5saXN0VGV4dFZlcnNpb25zKCk7XG4gICAgcmVxdWVzdHNCeVF1ZXJ5LnNldChxdWVyeUtleSwgcmVxdWVzdCk7XG4gICAgc3RvcmUuc2V0UXVlcnk0TG9hZGluZyhxdWVyeUtleSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICAgIGNvbnN0IHZlcnNpb25zID0gZGF0YS52ZXJzaW9ucy5tYXAoKHsgY3JlYXRlZEF0LCAuLi52ZXJzaW9uMiB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShjcmVhdGVkQXQpLFxuICAgICAgICAgIC4uLnZlcnNpb24yXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHN0b3JlLnVwZGF0ZVJvb21WZXJzaW9ucyhyb29tLmlkLCB2ZXJzaW9ucywgcXVlcnlLZXkpO1xuICAgICAgcmVxdWVzdHNCeVF1ZXJ5LmRlbGV0ZShxdWVyeUtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5S2V5KTtcbiAgICAgIHJldHJ5RXJyb3IoKCkgPT4ge1xuICAgICAgICB2b2lkIGdldFJvb21WZXJzaW9ucyhyb29tLCB7XG4gICAgICAgICAgcmV0cnlDb3VudDogcmV0cnlDb3VudCArIDFcbiAgICAgICAgfSk7XG4gICAgICB9LCByZXRyeUNvdW50KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5NEVycm9yKHF1ZXJ5S2V5LCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCB7IHJldHJ5Q291bnQgfSA9IHsgcmV0cnlDb3VudDogMCB9KSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tLmlkKTtcbiAgICBjb25zdCBleGlzdGluZ1JlcXVlc3QgPSByZXF1ZXN0c0J5UXVlcnkuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdSZXF1ZXN0ICE9PSB2b2lkIDApIHJldHVybiBleGlzdGluZ1JlcXVlc3Q7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByb29tLmdldE5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCByZXF1ZXN0KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5M0xvYWRpbmcocXVlcnlLZXkpO1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCByZXF1ZXN0O1xuICAgICAgc3RvcmUudXBkYXRlUm9vbUluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbS5pZCwgc2V0dGluZ3MsIHF1ZXJ5S2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlcXVlc3RzQnlRdWVyeS5kZWxldGUocXVlcnlLZXkpO1xuICAgICAgcmV0cnlFcnJvcigoKSA9PiB7XG4gICAgICAgIHZvaWQgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCB7XG4gICAgICAgICAgcmV0cnlDb3VudDogcmV0cnlDb3VudCArIDFcbiAgICAgICAgfSk7XG4gICAgICB9LCByZXRyeUNvdW50KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5M0Vycm9yKHF1ZXJ5S2V5LCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tbWVudHNFcnJvckV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlMigpO1xuICBmdW5jdGlvbiBvbk11dGF0aW9uRmFpbHVyZShpbm5lckVycm9yLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNyZWF0ZVB1YmxpY0Vycm9yKSB7XG4gICAgc3RvcmUucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgIGlmIChpbm5lckVycm9yIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVBcGlFcnJvcihpbm5lckVycm9yKTtcbiAgICAgIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoY3JlYXRlUHVibGljRXJyb3IoZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBOb3RpZmljYXRpb25zQXBpRXJyb3IpIHtcbiAgICAgIGhhbmRsZUFwaUVycm9yKGlubmVyRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBpbm5lckVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RvcmUsXG4gICAgc3Vic2NyaWJlVG9Sb29tVGhyZWFkc0RlbHRhVXBkYXRlczogbWFrZURlbHRhUG9sbGVyX1Jvb21UaHJlYWRzKGNsaWVudCksXG4gICAgY29tbWVudHNFcnJvckV2ZW50U291cmNlLFxuICAgIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgZ2V0Um9vbVZlcnNpb25zLFxuICAgIG9uTXV0YXRpb25GYWlsdXJlXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQsIHsgY2xpZW50LCBhbGxvd05lc3Rpbmc6IHRydWUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFJvb21Qcm92aWRlciwgeyAuLi5wcm9wcyB9KSk7XG4gIH1cbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBjb25zdCBidW5kbGUgPSB7XG4gICAgUm9vbUNvbnRleHQsXG4gICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgIHVzZVJvb20sXG4gICAgdXNlU3RhdHVzLFxuICAgIHVzZVN0b3JhZ2VTdGF0dXMsXG4gICAgdXNlQmF0Y2gsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgdXNlSGlzdG9yeSxcbiAgICB1c2VVbmRvLFxuICAgIHVzZVJlZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VDYW5VbmRvLFxuICAgIHVzZVN0b3JhZ2VSb290LFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlT3RoZXJzLFxuICAgIHVzZU90aGVyc01hcHBlZCxcbiAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICAgIHVzZU90aGVyLFxuICAgIHVzZU11dGF0aW9uLFxuICAgIHVzZVRocmVhZHMsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgdXNlQXR0YWNobWVudFVybCxcbiAgICB1c2VIaXN0b3J5VmVyc2lvbnMsXG4gICAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLi4uc2hhcmVkLmNsYXNzaWMsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIFJvb21Db250ZXh0LFxuICAgICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgICAgdXNlUm9vbSxcbiAgICAgIHVzZVN0YXR1cyxcbiAgICAgIHVzZVN0b3JhZ2VTdGF0dXM6IHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZSxcbiAgICAgIHVzZUJhdGNoLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICAgIHVzZUhpc3RvcnksXG4gICAgICB1c2VVbmRvLFxuICAgICAgdXNlUmVkbyxcbiAgICAgIHVzZUNhblJlZG8sXG4gICAgICB1c2VDYW5VbmRvLFxuICAgICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgICB1c2VTdG9yYWdlOiB1c2VTdG9yYWdlU3VzcGVuc2UsXG4gICAgICB1c2VTZWxmOiB1c2VTZWxmU3VzcGVuc2UsXG4gICAgICB1c2VNeVByZXNlbmNlLFxuICAgICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICAgIHVzZU90aGVyczogdXNlT3RoZXJzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNNYXBwZWQ6IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkczogdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXI6IHVzZU90aGVyU3VzcGVuc2UsXG4gICAgICB1c2VNdXRhdGlvbixcbiAgICAgIHVzZVRocmVhZHM6IHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgICB1c2VFZGl0Q29tbWVudCxcbiAgICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgICB1c2VBZGRSZWFjdGlvbixcbiAgICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUF0dGFjaG1lbnRVcmw6IHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZSxcbiAgICAgIC8vIFRPRE86IHVzZUhpc3RvcnlWZXJzaW9uRGF0YTogdXNlSGlzdG9yeVZlcnNpb25EYXRhU3VzcGVuc2UsXG4gICAgICB1c2VIaXN0b3J5VmVyc2lvbnM6IHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICAgICAgdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzOiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgICAgIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH0sXG4gICAgdXNlQ29tbWVudHNFcnJvckxpc3RlbmVyXG4gIH07XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCBrSW50ZXJuYWwzLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBSb29tUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IFtjYWNoZV0gPSBSZWFjdDUudXNlU3RhdGUoXG4gICAgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICApO1xuICBjb25zdCBzdGFibGVFbnRlclJvb20gPSBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKHJvb21JZCwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHJvb21JZCk7XG4gICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgY29uc3QgcnYgPSBjbGllbnQuZW50ZXJSb29tKHJvb21JZCwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBvcmlnTGVhdmUgPSBydi5sZWF2ZTtcbiAgICAgIHJ2LmxlYXZlID0gKCkgPT4ge1xuICAgICAgICBvcmlnTGVhdmUoKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKHJvb21JZCk7XG4gICAgICB9O1xuICAgICAgY2FjaGUuc2V0KHJvb21JZCwgcnYpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG4gICAgW2NsaWVudCwgY2FjaGVdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgUm9vbVByb3ZpZGVySW5uZXIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBzdGFibGVFbnRlclJvb21cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBSb29tUHJvdmlkZXJJbm5lcihwcm9wcykge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBpZDogcm9vbUlkLCBzdGFibGVFbnRlclJvb20gfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFyb29tSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgaXMgcmVxdWlyZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1yZWFjdC9Sb29tUHJvdmlkZXItaWQtcHJvcGVydHktaXMtcmVxdWlyZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhyb29tSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbWFqb3JSZWFjdFZlcnNpb24gPSBwYXJzZUludChSZWFjdDUudmVyc2lvbikgfHwgMTtcbiAgICBjb25zdCBvbGRSZWFjdFZlcnNpb24gPSBtYWpvclJlYWN0VmVyc2lvbiA8IDE4O1xuICAgIGVycm9ySWYoXG4gICAgICBvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPT09IHZvaWQgMCxcbiAgICAgIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMobWFqb3JSZWFjdFZlcnNpb24sIHJvb21JZClcbiAgICApO1xuICAgIGRlcHJlY2F0ZUlmKFxuICAgICAgIW9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyAhPT0gdm9pZCAwLFxuICAgICAgc3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbiAgICApO1xuICB9XG4gIGNvbnN0IGZyb3plblByb3BzID0gdXNlSW5pdGlhbCh7XG4gICAgaW5pdGlhbFByZXNlbmNlOiBwcm9wcy5pbml0aWFsUHJlc2VuY2UsXG4gICAgaW5pdGlhbFN0b3JhZ2U6IHByb3BzLmluaXRpYWxTdG9yYWdlLFxuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICBhdXRvQ29ubmVjdDogcHJvcHMuYXV0b0Nvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICB9KTtcbiAgY29uc3QgW3sgcm9vbSB9LCBzZXRSb29tTGVhdmVQYWlyXSA9IFJlYWN0NS51c2VTdGF0ZShcbiAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgfSlcbiAgKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9ERUxFVEVEKSB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHJvb20uZ2V0VGhyZWFkKG1lc3NhZ2UudGhyZWFkSWQpO1xuICAgICAgaWYgKCFpbmZvLnRocmVhZCkge1xuICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbiB9ID0gaW5mbztcbiAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RvcmUuZ2V0RnVsbFN0YXRlKCkudGhyZWFkc0J5SWRbbWVzc2FnZS50aHJlYWRJZF07XG4gICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9FRElURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfTUVUQURBVEFfVVBEQVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9VUERBVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9BRERFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfREVMRVRFRDpcbiAgICAgICAgICBpZiAoIWV4aXN0aW5nVGhyZWFkKSBicmVhaztcbiAgICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0NSRUFURUQ6XG4gICAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm9vbS5ldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKFxuICAgICAgKG1lc3NhZ2UpID0+IHZvaWQgaGFuZGxlQ29tbWVudEV2ZW50KG1lc3NhZ2UpXG4gICAgKTtcbiAgfSwgW2NsaWVudCwgcm9vbV0pO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgICB2b2lkIHN0b3JlLmZldGNoUm9vbVRocmVhZHNEZWx0YVVwZGF0ZShyb29tLmlkKS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gIH0sIFtjbGllbnQsIHJvb20uaWRdKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICBjb25zdCBzdG9yZSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgICAgIHZvaWQgc3RvcmUuZmV0Y2hSb29tVGhyZWFkc0RlbHRhVXBkYXRlKHJvb20uaWQpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICB9O1xuICB9LCBbY2xpZW50LCByb29tLmlkXSk7XG4gIFJlYWN0NS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBzdGFibGVFbnRlclJvb20ocm9vbUlkLCBmcm96ZW5Qcm9wcyk7XG4gICAgc2V0Um9vbUxlYXZlUGFpcihwYWlyKTtcbiAgICBjb25zdCB7IHJvb206IHJvb20yLCBsZWF2ZSB9ID0gcGFpcjtcbiAgICBpZiAoZnJvemVuUHJvcHMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIHJvb20yLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxlYXZlKCk7XG4gICAgfTtcbiAgfSwgW3Jvb21JZCwgZnJvemVuUHJvcHMsIHN0YWJsZUVudGVyUm9vbV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFJvb21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb29tIH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb20oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tT3JOdWxsKCk7XG4gIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gIH1cbiAgcmV0dXJuIHJvb207XG59XG5mdW5jdGlvbiB1c2VTdGF0dXMoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1cyhvcHRpb25zKSB7XG4gIGNvbnN0IHNtb290aCA9IHVzZUluaXRpYWwob3B0aW9ucz8uc21vb3RoID8/IGZhbHNlKTtcbiAgaWYgKHNtb290aCkge1xuICAgIHJldHVybiB1c2VTdG9yYWdlU3RhdHVzU21vb3RoKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2VTdGF0dXNJbW1lZGlhdGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1c0ltbWVkaWF0ZSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU3RhdHVzO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVN0YXR1cztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzU21vb3RoKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3Q1LnVzZVN0YXRlKHJvb20uZ2V0U3RvcmFnZVN0YXR1cyk7XG4gIGNvbnN0IG9sZFN0YXR1cyA9IHVzZUxhdGVzdChyb29tLmdldFN0b3JhZ2VTdGF0dXMoKSk7XG4gIFJlYWN0NS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgdW5zdWIgPSByb29tLmV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZSgobmV3U3RhdHVzKSA9PiB7XG4gICAgICBpZiAob2xkU3RhdHVzLmN1cnJlbnQgPT09IFwic3luY2hyb25pemluZ1wiICYmIG5ld1N0YXR1cyA9PT0gXCJzeW5jaHJvbml6ZWRcIikge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFN0YXR1cyhuZXdTdGF0dXMpLCBTTU9PVEhfREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHNldFN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgfSwgW3Jvb20sIG9sZFN0YXR1c10pO1xuICByZXR1cm4gc3RhdHVzO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2goKSB7XG4gIHJldHVybiB1c2VSb29tKCkuYmF0Y2g7XG59XG5mdW5jdGlvbiB1c2VCcm9hZGNhc3RFdmVudCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQsIG9wdGlvbnMgPSB7IHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZSB9KSA9PiB7XG4gICAgICByb29tLmJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIFJlYWN0NS51c2VFZmZlY3QoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudCkpLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdChcbiAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudClcbiAgICApLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRXJyb3JMaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdChcbiAgICAoKSA9PiByb29tLmV2ZW50cy5lcnJvci5zdWJzY3JpYmUoKGUpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChlKSksXG4gICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudERhdGEpID0+IHtcbiAgICAgIHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudERhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShsaXN0ZW5lcik7XG4gIH0sIFtyb29tLCBzYXZlZENhbGxiYWNrXSk7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5KCkge1xuICByZXR1cm4gdXNlUm9vbSgpLmhpc3Rvcnk7XG59XG5mdW5jdGlvbiB1c2VVbmRvKCkge1xuICByZXR1cm4gdXNlSGlzdG9yeSgpLnVuZG87XG59XG5mdW5jdGlvbiB1c2VSZWRvKCkge1xuICByZXR1cm4gdXNlSGlzdG9yeSgpLnJlZG87XG59XG5mdW5jdGlvbiB1c2VDYW5VbmRvKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgY29uc3QgY2FuVW5kbyA9IHJvb20uaGlzdG9yeS5jYW5VbmRvO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgY2FuVW5kbywgY2FuVW5kbyk7XG59XG5mdW5jdGlvbiB1c2VDYW5SZWRvKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgY29uc3QgY2FuUmVkbyA9IHJvb20uaGlzdG9yeS5jYW5SZWRvO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgY2FuUmVkbywgY2FuUmVkbyk7XG59XG5mdW5jdGlvbiB1c2VTZWxmKG1heWJlU2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTZWxmO1xuICBjb25zdCBzZWxlY3RvciA9IG1heWJlU2VsZWN0b3IgPz8gaWRlbnRpdHkyO1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHNlbGVjdG9yKG1lKSA6IG51bGwsXG4gICAgW3NlbGVjdG9yXVxuICApO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNuYXBzaG90LFxuICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNeVByZXNlbmNlKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFByZXNlbmNlO1xuICBjb25zdCBwcmVzZW5jZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG4gIGNvbnN0IHNldFByZXNlbmNlID0gcm9vbS51cGRhdGVQcmVzZW5jZTtcbiAgcmV0dXJuIFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlTXlQcmVzZW5jZSgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS51cGRhdGVQcmVzZW5jZTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVycyhzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0T3RoZXJzO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c0VtcHR5TGlzdDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgc2VsZWN0b3IgPz8gaWRlbnRpdHkyLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlcikgPT4gW290aGVyLmNvbm5lY3Rpb25JZCwgaXRlbVNlbGVjdG9yKG90aGVyKV0pLFxuICAgIFtpdGVtU2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgIChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBlcSA9IGl0ZW1Jc0VxdWFsID8/IE9iamVjdC5pcztcbiAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoYXR1cGxlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBidHVwbGUgPSBiW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGF0dXBsZVswXSA9PT0gYnR1cGxlWzBdICYmIGVxKGF0dXBsZVsxXSwgYnR1cGxlWzFdKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2l0ZW1Jc0VxdWFsXVxuICApO1xuICByZXR1cm4gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkcygpIHtcbiAgcmV0dXJuIHVzZU90aGVycyhzZWxlY3RvckZvcl91c2VPdGhlcnNDb25uZWN0aW9uSWRzLCBzaGFsbG93NCk7XG59XG52YXIgTk9UX0ZPVU5EID0gU3ltYm9sKCk7XG5mdW5jdGlvbiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAob3RoZXJzKSA9PiB7XG4gICAgICBjb25zdCBvdGhlcjIgPSBvdGhlcnMuZmluZCgob3RoZXIzKSA9PiBvdGhlcjMuY29ubmVjdGlvbklkID09PSBjb25uZWN0aW9uSWQpO1xuICAgICAgcmV0dXJuIG90aGVyMiAhPT0gdm9pZCAwID8gc2VsZWN0b3Iob3RoZXIyKSA6IE5PVF9GT1VORDtcbiAgICB9LFxuICAgIFtjb25uZWN0aW9uSWQsIHNlbGVjdG9yXVxuICApO1xuICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAocHJldiwgY3VycikgPT4ge1xuICAgICAgaWYgKHByZXYgPT09IE5PVF9GT1VORCB8fCBjdXJyID09PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIHByZXYgPT09IGN1cnI7XG4gICAgICB9XG4gICAgICBjb25zdCBlcSA9IGlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgcmV0dXJuIGVxKHByZXYsIGN1cnIpO1xuICAgIH0sXG4gICAgW2lzRXF1YWxdXG4gICk7XG4gIGNvbnN0IG90aGVyID0gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICBpZiAob3RoZXIgPT09IE5PVF9GT1VORCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBObyBzdWNoIG90aGVyIHVzZXIgd2l0aCBjb25uZWN0aW9uIGlkICR7Y29ubmVjdGlvbklkfSBleGlzdHNgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3RoZXI7XG59XG5mdW5jdGlvbiB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2U7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3Q7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlUm9vdCgpIHtcbiAgcmV0dXJuIFt1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKV07XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgIChyb290T3JOdWxsMikgPT4gcm9vdE9yTnVsbDIgIT09IG51bGwgPyBzZWxlY3Rvcihyb290T3JOdWxsMikgOiBudWxsLFxuICAgIFtzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgIChvblN0b3JlQ2hhbmdlKSA9PiByb290T3JOdWxsICE9PSBudWxsID8gcm9vbS5zdWJzY3JpYmUocm9vdE9yTnVsbCwgb25TdG9yZUNoYW5nZSwgeyBpc0RlZXA6IHRydWUgfSkgOiBub29wMyxcbiAgICBbcm9vbSwgcm9vdE9yTnVsbF1cbiAgKTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSBSZWFjdDUudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm9vdCA9IHJvb3RPck51bGw7XG4gICAgICBjb25zdCBpbW0gPSByb290LnRvSW1tdXRhYmxlKCk7XG4gICAgICByZXR1cm4gaW1tO1xuICAgIH1cbiAgfSwgW3Jvb3RPck51bGxdKTtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlTXV0YXRpb24oY2FsbGJhY2ssIGRlcHMpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VNZW1vKFxuICAgICgpID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4gKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcm9vbS5iYXRjaChcbiAgICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICBtYWtlTXV0YXRpb25Db250ZXh0KHJvb20pLFxuICAgICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtyb29tLCAuLi5kZXBzXVxuICApO1xufVxuZnVuY3Rpb24gdXNlVGhyZWFkcyhvcHRpb25zID0ge1xuICBxdWVyeTogeyBtZXRhZGF0YToge30gfVxufSkge1xuICBjb25zdCB7IHNjcm9sbE9uTG9hZCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlLCBzdWJzY3JpYmVUb1Jvb21UaHJlYWRzRGVsdGFVcGRhdGVzOiBzdWJzY3JpYmVUb0RlbHRhVXBkYXRlcyB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBSZWFjdDUudXNlRWZmZWN0KFxuICAgICgpID0+IHtcbiAgICAgIHZvaWQgc3RvcmUud2FpdFVudGlsUm9vbVRocmVhZHNMb2FkZWQocm9vbS5pZCwgb3B0aW9ucy5xdWVyeSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdChzdWJzY3JpYmVUb0RlbHRhVXBkYXRlcywgW3N1YnNjcmliZVRvRGVsdGFVcGRhdGVzXSk7XG4gIGNvbnN0IGdldHRlciA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBzdG9yZS5nZXRSb29tVGhyZWFkc0FzeW5jKHJvb20uaWQsIG9wdGlvbnMucXVlcnkpLFxuICAgIFtzdG9yZSwgcm9vbS5pZCwgb3B0aW9ucy5xdWVyeV1cbiAgKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlVGhyZWFkcyxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5MixcbiAgICBzaGFsbG93MlxuICAgIC8vIE5PVEU6IFVzaW5nIDItbGV2ZWwtZGVlcCBzaGFsbG93IGNoZWNrIGhlcmUsIGJlY2F1c2UgdGhlIHJlc3VsdCBvZiBzZWxlY3RUaHJlYWRzKCkgaXMgbm90IHN0YWJsZSFcbiAgKTtcbiAgdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNjcm9sbE9uTG9hZCwgc3RhdGUpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VDb21tZW50c0Vycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBjb25zdCB7IGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gY29tbWVudHNFcnJvckV2ZW50U291cmNlLnN1YnNjcmliZShzYXZlZENhbGxiYWNrLmN1cnJlbnQpO1xuICB9LCBbc2F2ZWRDYWxsYmFjaywgY29tbWVudHNFcnJvckV2ZW50U291cmNlXSk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhID8/IHt9O1xuICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBvcHRpb25zLmF0dGFjaG1lbnRzO1xuICAgICAgY29uc3QgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpO1xuICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG5ld0NvbW1lbnQgPSB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIHR5cGU6IFwidGhyZWFkXCIsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdXBkYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGNvbW1lbnRzOiBbbmV3Q29tbWVudF0sXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtdGhyZWFkXCIsXG4gICAgICAgIHRocmVhZDogbmV3VGhyZWFkLFxuICAgICAgICByb29tSWQ6IHJvb20uaWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGF0dGFjaG1lbnRzPy5tYXAoKGF0dGFjaG1lbnQpID0+IGF0dGFjaG1lbnQuaWQpO1xuICAgICAgcm9vbS5jcmVhdGVUaHJlYWQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBtZXRhZGF0YSwgYXR0YWNobWVudElkcyB9KS50aGVuKFxuICAgICAgICAodGhyZWFkKSA9PiB7XG4gICAgICAgICAgc3RvcmUuY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNVcGRhdGVJZCwgdGhyZWFkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyMikgPT4gbmV3IENyZWF0ZVRocmVhZEVycm9yKGVycjIsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdUaHJlYWQ7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlVGhyZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCB0aHJlYWQgPSBzdG9yZS5nZXRGdWxsU3RhdGUoKS50aHJlYWRzQnlJZFt0aHJlYWRJZF07XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgaWYgKHRocmVhZD8uY29tbWVudHM/LlswXT8udXNlcklkICE9PSB1c2VySWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB0aGUgdGhyZWFkIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgdGhyZWFkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLXRocmVhZFwiLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIHJvb20uZGVsZXRlVGhyZWFkKHRocmVhZElkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlVGhyZWFkKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnIyKSA9PiBuZXcgRGVsZXRlVGhyZWFkRXJyb3IoZXJyMiwgeyByb29tSWQ6IHJvb20uaWQsIHRocmVhZElkIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRWRpdFRocmVhZE1ldGFkYXRhKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKCFvcHRpb25zLm1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9ucy50aHJlYWRJZDtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCIsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20uZWRpdFRocmVhZE1ldGFkYXRhKHsgdGhyZWFkSWQsIG1ldGFkYXRhIH0pLnRoZW4oXG4gICAgICAgIChtZXRhZGF0YTIpID0+IChcbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBieSB0aGUgcmVhbCB0aGluZ1xuICAgICAgICAgIHN0b3JlLnBhdGNoVGhyZWFkKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICB7IG1ldGFkYXRhOiBtZXRhZGF0YTIgfSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdFxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlQ3JlYXRlQ29tbWVudCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKHsgdGhyZWFkSWQsIGJvZHksIGF0dGFjaG1lbnRzIH0pID0+IHtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgIGJvZHksXG4gICAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cyA/PyBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtY29tbWVudFwiLFxuICAgICAgICBjb21tZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBhdHRhY2htZW50cz8ubWFwKChhdHRhY2htZW50KSA9PiBhdHRhY2htZW50LmlkKTtcbiAgICAgIHJvb20uY3JlYXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKG5ld0NvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5jcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycjIpID0+IG5ldyBDcmVhdGVDb21tZW50RXJyb3IoZXJyMiwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRDb21tZW50KCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50cyB9KSA9PiB7XG4gICAgICBjb25zdCBlZGl0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHRocmVhZCA9IHN0b3JlLmdldEZ1bGxTdGF0ZSgpLnRocmVhZHNCeUlkW3RocmVhZElkXTtcbiAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlMy53YXJuKFxuICAgICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZWRpdCBjb21tZW50IGluIHRocmVhZCBcIiR7dGhyZWFkSWR9XCIgYmVjYXVzZSB0aGUgdGhyZWFkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZS5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAgICAgKGNvbW1lbnQyKSA9PiBjb21tZW50Mi5pZCA9PT0gY29tbWVudElkXG4gICAgICApO1xuICAgICAgaWYgKGNvbW1lbnQgPT09IHZvaWQgMCB8fCBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUzLndhcm4oXG4gICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgXCIke2NvbW1lbnRJZH1cIiBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIGNvbW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZWRpdC1jb21tZW50XCIsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgIGVkaXRlZEF0LFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGF0dGFjaG1lbnRzPy5tYXAoKGF0dGFjaG1lbnQpID0+IGF0dGFjaG1lbnQuaWQpO1xuICAgICAgcm9vbS5lZGl0Q29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKGVkaXRlZENvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5lZGl0Q29tbWVudCh0aHJlYWRJZCwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBlZGl0ZWRDb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBFZGl0Q29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQgfSkgPT4ge1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLWNvbW1lbnRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgZGVsZXRlZEF0LFxuICAgICAgICByb29tSWQ6IHJvb20uaWRcbiAgICAgIH0pO1xuICAgICAgcm9vbS5kZWxldGVDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlQ29tbWVudChcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZGVsZXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBEZWxldGVDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VBZGRSZWFjdGlvbigpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImFkZC1yZWFjdGlvblwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICByZWFjdGlvbjoge1xuICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb29tLmFkZFJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkudGhlbihcbiAgICAgICAgKGFkZGVkUmVhY3Rpb24pID0+IHtcbiAgICAgICAgICBzdG9yZS5hZGRSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYWRkZWRSZWFjdGlvbixcbiAgICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgQWRkUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBlbW9qaVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24oKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICBjb25zdCByZW1vdmVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmUtcmVhY3Rpb25cIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgZW1vamksXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcmVtb3ZlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20ucmVtb3ZlUmVhY3Rpb24oeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgcmVtb3ZlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBSZW1vdmVSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgIHN0b3JlLmdldEZ1bGxTdGF0ZSgpLm5vdGlmaWNhdGlvbnNCeUlkXG4gICAgICApLmZpbmQoXG4gICAgICAgIChpbmJveE5vdGlmaWNhdGlvbjIpID0+IGluYm94Tm90aWZpY2F0aW9uMi5raW5kID09PSBcInRocmVhZFwiICYmIGluYm94Tm90aWZpY2F0aW9uMi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBpZiAoIWluYm94Tm90aWZpY2F0aW9uKSByZXR1cm47XG4gICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIixcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWQsXG4gICAgICAgIHJlYWRBdDogbm93XG4gICAgICB9KTtcbiAgICAgIHJvb20ubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uLmlkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUudXBkYXRlSW5ib3hOb3RpZmljYXRpb24oXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChpbmJveE5vdGlmaWNhdGlvbjIpID0+ICh7IC4uLmluYm94Tm90aWZpY2F0aW9uMiwgcmVhZEF0OiBub3cgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZXNvbHZlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20ubWFya1RocmVhZEFzUmVzb2x2ZWQodGhyZWFkSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5wYXRjaFRocmVhZChcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgeyByZXNvbHZlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgdXBkYXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBNYXJrVGhyZWFkQXNSZXNvbHZlZEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICB1cGRhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgcm9vbS5tYXJrVGhyZWFkQXNVbnJlc29sdmVkKHRocmVhZElkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IE1hcmtUaHJlYWRBc1VucmVzb2x2ZWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZFN1YnNjcmlwdGlvbih0aHJlYWRJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBzZWxlY3RvciA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gc3RhdGUubm90aWZpY2F0aW9ucy5maW5kKFxuICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24yKSA9PiBpbmJveE5vdGlmaWNhdGlvbjIua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBpbmJveE5vdGlmaWNhdGlvbjIudGhyZWFkSWQgPT09IHRocmVhZElkXG4gICAgICApO1xuICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc0J5SWRbdGhyZWFkSWRdO1xuICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDAgfHwgdGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgdW5yZWFkU2luY2U6IGluYm94Tm90aWZpY2F0aW9uLnJlYWRBdFxuICAgICAgfTtcbiAgICB9LFxuICAgIFt0aHJlYWRJZF1cbiAgKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdG9yZS5zdWJzY3JpYmVUaHJlYWRzLFxuICAgIHN0b3JlLmdldEZ1bGxTdGF0ZSxcbiAgICBzdG9yZS5nZXRGdWxsU3RhdGUsXG4gICAgc2VsZWN0b3JcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgY29uc3QgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IGdldHRlciA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBzdG9yZS5nZXROb3RpZmljYXRpb25TZXR0aW5nc0FzeW5jKHJvb20uaWQpLFxuICAgIFtzdG9yZSwgcm9vbS5pZF1cbiAgKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgdm9pZCBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20pO1xuICB9LCBbY2xpZW50LCByb29tXSk7XG4gIGNvbnN0IHNldHRpbmdzID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN0b3JlLnN1YnNjcmliZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIGdldHRlcixcbiAgICBnZXR0ZXIsXG4gICAgaWRlbnRpdHkyLFxuICAgIHNoYWxsb3c0XG4gICk7XG4gIHJldHVybiBSZWFjdDUudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXTtcbiAgfSwgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlKCkge1xuICBjb25zdCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgZ2V0dGVyID0gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgICgpID0+IHN0b3JlLmdldE5vdGlmaWNhdGlvblNldHRpbmdzQXN5bmMocm9vbS5pZCksXG4gICAgW3N0b3JlLCByb29tLmlkXVxuICApO1xuICBjb25zdCBzZXR0aW5ncyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdG9yZS5zdWJzY3JpYmVOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5MixcbiAgICBzaGFsbG93NFxuICApO1xuICBpZiAoc2V0dGluZ3MuaXNMb2FkaW5nKSB7XG4gICAgY29uc3QgeyBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgdGhyb3cgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tKTtcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5lcnJvcikge1xuICAgIHRocm93IHNldHRpbmdzLmVycm9yO1xuICB9XG4gIHJldHVybiBSZWFjdDUudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXTtcbiAgfSwgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9uRGF0YSh2ZXJzaW9uSWQpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdDUudXNlU3RhdGUoe1xuICAgIGlzTG9hZGluZzogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgY29uc3QgbG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcm9vbVtrSW50ZXJuYWwzXS5nZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbG9hZGluZyB0aGlzIHZlcnNpb25cIlxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2b2lkIGxvYWQoKTtcbiAgfSwgW3Jvb20sIHZlcnNpb25JZF0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5VmVyc2lvbnMoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlLCBnZXRSb29tVmVyc2lvbnMgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgZ2V0dGVyID0gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgICgpID0+IHN0b3JlLmdldFZlcnNpb25zQXN5bmMocm9vbS5pZCksXG4gICAgW3N0b3JlLCByb29tLmlkXVxuICApO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGdldFJvb21WZXJzaW9ucyhyb29tKTtcbiAgfSwgW3Jvb21dKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlVmVyc2lvbnMsXG4gICAgZ2V0dGVyLFxuICAgIGdldHRlcixcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzRcbiAgKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeVZlcnNpb25zU3VzcGVuc2UoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IGdldHRlciA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBzdG9yZS5nZXRWZXJzaW9uc0FzeW5jKHJvb20uaWQpLFxuICAgIFtzdG9yZSwgcm9vbS5pZF1cbiAgKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlVmVyc2lvbnMsXG4gICAgZ2V0dGVyLFxuICAgIGdldHRlcixcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzRcbiAgKTtcbiAgaWYgKHN0YXRlLmlzTG9hZGluZykge1xuICAgIGNvbnN0IHsgZ2V0Um9vbVZlcnNpb25zIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgdGhyb3cgZ2V0Um9vbVZlcnNpb25zKHJvb20pO1xuICB9IGVsc2UgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgc3RhdGUuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoc2V0dGluZ3MpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgcm9vbS51cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVJvb21JbmJveE5vdGlmaWNhdGlvblNldHRpbmdzMihcbiAgICAgICAgICAgIHJvb20uaWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICBzZXR0aW5nczJcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IFVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gZW5zdXJlTm90U2VydmVyU2lkZSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3QgdXNlIHRoZSBTdXNwZW5zZSB2ZXJzaW9uIG9mIHRoaXMgaG9vayBvbiB0aGUgc2VydmVyIHNpZGUuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdGhlbSBvbiB0aGUgY2xpZW50IHNpZGUuXFxuRm9yIHRpcHMsIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtcmVhY3Qjc3VzcGVuc2UtYXZvaWQtc3NyXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTZWxmU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU2VsZihcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnMoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlKCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZShpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyU3VzcGVuc2UoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uocm9vbS53YWl0VW50aWxTdG9yYWdlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZShvcHRpb25zKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1cyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zID0ge1xuICBxdWVyeTogeyBtZXRhZGF0YToge30gfVxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsUm9vbVRocmVhZHNMb2FkZWQocm9vbS5pZCwgb3B0aW9ucy5xdWVyeSkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VUaHJlYWRzKG9wdGlvbnMpO1xuICBhc3NlcnQyKCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydDIoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZUF0dGFjaG1lbnRVcmwoc3RhdGUpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBhc3NlcnQyKHN0YXRlLmRhdGEgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3NpbmcgYXR0YWNobWVudCBVUkxcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1cmw6IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgYXR0YWNobWVudFVybHNTdG9yZSB9ID0gcm9vbVtrSW50ZXJuYWwzXTtcbiAgY29uc3QgZ2V0QXR0YWNobWVudFVybFN0YXRlID0gUmVhY3Q1LnVzZUNhbGxiYWNrKFxuICAgICgpID0+IGF0dGFjaG1lbnRVcmxzU3RvcmUuZ2V0U3RhdGUoYXR0YWNobWVudElkKSxcbiAgICBbYXR0YWNobWVudFVybHNTdG9yZSwgYXR0YWNobWVudElkXVxuICApO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGF0dGFjaG1lbnRVcmxzU3RvcmUuZ2V0KGF0dGFjaG1lbnRJZCk7XG4gIH0sIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBhdHRhY2htZW50VXJsc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgZ2V0QXR0YWNobWVudFVybFN0YXRlLFxuICAgIHNlbGVjdG9yRm9yX3VzZUF0dGFjaG1lbnRVcmwsXG4gICAgc2hhbGxvdzRcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZShhdHRhY2htZW50SWQpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBhdHRhY2htZW50VXJsc1N0b3JlIH0gPSByb29tW2tJbnRlcm5hbDNdO1xuICBjb25zdCBnZXRBdHRhY2htZW50VXJsU3RhdGUgPSBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gYXR0YWNobWVudFVybHNTdG9yZS5nZXRTdGF0ZShhdHRhY2htZW50SWQpLFxuICAgIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxTdGF0ZSA9IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSgpO1xuICBpZiAoIWF0dGFjaG1lbnRVcmxTdGF0ZSB8fCBhdHRhY2htZW50VXJsU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybHNTdG9yZS5nZXQoYXR0YWNobWVudElkKTtcbiAgfVxuICBpZiAoYXR0YWNobWVudFVybFN0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybFN0YXRlLmVycm9yO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgIGF0dGFjaG1lbnRVcmxzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGVcbiAgKTtcbiAgYXNzZXJ0MihzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0Mighc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0Mighc3RhdGUuZXJyb3IsIFwiVW5leHBlY3RlZCBlcnJvciBzdGF0ZVwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVybDogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tQ29udGV4dChjbGllbnQpIHtcbiAgcmV0dXJuIGdldE9yQ3JlYXRlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KTtcbn1cbnZhciBfUm9vbVByb3ZpZGVyID0gUm9vbVByb3ZpZGVyO1xudmFyIF91c2VCcm9hZGNhc3RFdmVudCA9IHVzZUJyb2FkY2FzdEV2ZW50O1xudmFyIF91c2VPdGhlcnNMaXN0ZW5lciA9IHVzZU90aGVyc0xpc3RlbmVyO1xudmFyIF91c2VSb29tID0gdXNlUm9vbTtcbnZhciBfdXNlSXNJbnNpZGVSb29tID0gdXNlSXNJbnNpZGVSb29tO1xudmFyIF91c2VBZGRSZWFjdGlvbiA9IHVzZUFkZFJlYWN0aW9uO1xudmFyIF91c2VNdXRhdGlvbiA9IHVzZU11dGF0aW9uO1xudmFyIF91c2VDcmVhdGVUaHJlYWQgPSB1c2VDcmVhdGVUaHJlYWQ7XG52YXIgX3VzZURlbGV0ZVRocmVhZCA9IHVzZURlbGV0ZVRocmVhZDtcbnZhciBfdXNlRWRpdFRocmVhZE1ldGFkYXRhID0gdXNlRWRpdFRocmVhZE1ldGFkYXRhO1xudmFyIF91c2VFdmVudExpc3RlbmVyID0gdXNlRXZlbnRMaXN0ZW5lcjtcbnZhciBfdXNlTXlQcmVzZW5jZSA9IHVzZU15UHJlc2VuY2U7XG52YXIgX3VzZU90aGVyc01hcHBlZCA9IHVzZU90aGVyc01hcHBlZDtcbnZhciBfdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UgPSB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZTtcbnZhciBfdXNlVGhyZWFkcyA9IHVzZVRocmVhZHM7XG52YXIgX3VzZVRocmVhZHNTdXNwZW5zZSA9IHVzZVRocmVhZHNTdXNwZW5zZTtcbnZhciBfdXNlSGlzdG9yeVZlcnNpb25zID0gdXNlSGlzdG9yeVZlcnNpb25zO1xudmFyIF91c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSA9IHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlO1xudmFyIF91c2VPdGhlciA9IHVzZU90aGVyO1xuZnVuY3Rpb24gX3VzZU90aGVycyguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VPdGhlcnMoLi4uYXJncyk7XG59XG52YXIgX3VzZU90aGVyU3VzcGVuc2UgPSB1c2VPdGhlclN1c3BlbnNlO1xuZnVuY3Rpb24gX3VzZU90aGVyc1N1c3BlbnNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZU90aGVyc1N1c3BlbnNlKC4uLmFyZ3MpO1xufVxudmFyIF91c2VTdG9yYWdlID0gdXNlU3RvcmFnZTtcbnZhciBfdXNlU3RvcmFnZVN1c3BlbnNlID0gdXNlU3RvcmFnZVN1c3BlbnNlO1xuZnVuY3Rpb24gX3VzZVNlbGYoLi4uYXJncykge1xuICByZXR1cm4gdXNlU2VsZiguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIF91c2VTZWxmU3VzcGVuc2UoLi4uYXJncykge1xuICByZXR1cm4gdXNlU2VsZlN1c3BlbnNlKC4uLmFyZ3MpO1xufVxudmFyIF91c2VTdG9yYWdlUm9vdCA9IHVzZVN0b3JhZ2VSb290O1xudmFyIF91c2VVcGRhdGVNeVByZXNlbmNlID0gdXNlVXBkYXRlTXlQcmVzZW5jZTtcblxuZXhwb3J0IHtcbiAgUEtHX05BTUUsXG4gIFBLR19WRVJTSU9OLFxuICBQS0dfRk9STUFULFxuICBDbGllbnRTaWRlU3VzcGVuc2UsXG4gIFJvb21Db250ZXh0LFxuICBzZWxlY3RUaHJlYWRzLFxuICBDbGllbnRDb250ZXh0LFxuICBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50LFxuICB1c2VDbGllbnQsXG4gIExpdmVibG9ja3NQcm92aWRlcixcbiAgY3JlYXRlTGl2ZWJsb2Nrc0NvbnRleHQsXG4gIHVzZUluYm94Tm90aWZpY2F0aW9ucyxcbiAgdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UsXG4gIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UsXG4gIHVzZVJvb21JbmZvLFxuICB1c2VSb29tSW5mb1N1c3BlbnNlLFxuICBfdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQsXG4gIF91c2VVc2VyLFxuICBfdXNlVXNlclN1c3BlbnNlLFxuICBfdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwsXG4gIENyZWF0ZVRocmVhZEVycm9yLFxuICB1c2VTdGF0dXMsXG4gIHVzZVN0b3JhZ2VTdGF0dXMsXG4gIHVzZUJhdGNoLFxuICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICB1c2VFcnJvckxpc3RlbmVyLFxuICB1c2VIaXN0b3J5LFxuICB1c2VVbmRvLFxuICB1c2VSZWRvLFxuICB1c2VDYW5VbmRvLFxuICB1c2VDYW5SZWRvLFxuICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICB1c2VDb21tZW50c0Vycm9yTGlzdGVuZXIsXG4gIHVzZUNyZWF0ZUNvbW1lbnQsXG4gIHVzZUVkaXRDb21tZW50LFxuICB1c2VEZWxldGVDb21tZW50LFxuICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICB1c2VIaXN0b3J5VmVyc2lvbkRhdGEsXG4gIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICB1c2VTdG9yYWdlU3RhdHVzU3VzcGVuc2UsXG4gIHVzZUF0dGFjaG1lbnRVcmwsXG4gIHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZSxcbiAgY3JlYXRlUm9vbUNvbnRleHQsXG4gIF9Sb29tUHJvdmlkZXIsXG4gIF91c2VCcm9hZGNhc3RFdmVudCxcbiAgX3VzZU90aGVyc0xpc3RlbmVyLFxuICBfdXNlUm9vbSxcbiAgX3VzZUlzSW5zaWRlUm9vbSxcbiAgX3VzZUFkZFJlYWN0aW9uLFxuICBfdXNlTXV0YXRpb24sXG4gIF91c2VDcmVhdGVUaHJlYWQsXG4gIF91c2VEZWxldGVUaHJlYWQsXG4gIF91c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gIF91c2VFdmVudExpc3RlbmVyLFxuICBfdXNlTXlQcmVzZW5jZSxcbiAgX3VzZU90aGVyc01hcHBlZCxcbiAgX3VzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICBfdXNlVGhyZWFkcyxcbiAgX3VzZVRocmVhZHNTdXNwZW5zZSxcbiAgX3VzZUhpc3RvcnlWZXJzaW9ucyxcbiAgX3VzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICBfdXNlT3RoZXIsXG4gIF91c2VPdGhlcnMsXG4gIF91c2VPdGhlclN1c3BlbnNlLFxuICBfdXNlT3RoZXJzU3VzcGVuc2UsXG4gIF91c2VTdG9yYWdlLFxuICBfdXNlU3RvcmFnZVN1c3BlbnNlLFxuICBfdXNlU2VsZixcbiAgX3VzZVNlbGZTdXNwZW5zZSxcbiAgX3VzZVN0b3JhZ2VSb290LFxuICBfdXNlVXBkYXRlTXlQcmVzZW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVY3RkFNRU5SLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-V7FAMENR.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/yjs/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/yjs/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksYjsProvider: () => (/* binding */ LiveblocksYjsProvider)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n// src/index.ts\n\n\n\n// ../../node_modules/lib0/map.js\nvar create = () => /* @__PURE__ */ new Map();\nvar setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === void 0) {\n    map.set(key, set = createT());\n  }\n  return set;\n};\n\n// ../../node_modules/lib0/set.js\nvar create2 = () => /* @__PURE__ */ new Set();\n\n// ../../node_modules/lib0/array.js\nvar from = Array.from;\nvar isArray = Array.isArray;\n\n// ../../node_modules/lib0/observable.js\nvar Observable = class {\n  constructor() {\n    this._observers = create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on(name, f) {\n    setIfUndefined(this._observers, name, create2).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once(name, f) {\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off(name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== void 0) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit(name, args) {\n    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args));\n  }\n  destroy() {\n    this._observers = create();\n  }\n};\n\n// src/index.ts\n\n\n// src/awareness.ts\nvar Y_PRESENCE_KEY = \"__yjs\";\nvar Y_PRESENCE_ID_KEY = \"__yjs_clientid\";\nvar Awareness = class extends Observable {\n  constructor(doc, room) {\n    super();\n    this.states = /* @__PURE__ */ new Map();\n    // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client\n    this.actorToClientMap = /* @__PURE__ */ new Map();\n    // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to\n    // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.\n    this.meta = /* @__PURE__ */ new Map();\n    // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this\n    // unfortunately it's typed by various integrations\n    this._checkInterval = 0;\n    this.doc = doc;\n    this.room = room;\n    this.room.updatePresence({\n      [Y_PRESENCE_ID_KEY]: this.doc.clientID\n    });\n    this.othersUnsub = this.room.events.others.subscribe((event) => {\n      let updates;\n      if (event.type === \"leave\") {\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = { added: [], updated: [], removed: [targetClientId] };\n        }\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (event.type === \"enter\" || event.type === \"update\") {\n        this.rebuildActorToClientMap(event.others);\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = {\n            added: event.type === \"enter\" ? [targetClientId] : [],\n            updated: event.type === \"update\" ? [targetClientId] : [],\n            removed: []\n          };\n        }\n      }\n      if (event.type === \"reset\") {\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (updates !== void 0) {\n        this.emit(\"change\", [updates, \"presence\"]);\n        this.emit(\"update\", [updates, \"presence\"]);\n      }\n    });\n  }\n  rebuildActorToClientMap(others) {\n    this.actorToClientMap.clear();\n    others.forEach((user) => {\n      if (user.presence[Y_PRESENCE_ID_KEY] !== void 0) {\n        this.actorToClientMap.set(\n          user.connectionId,\n          user.presence[Y_PRESENCE_ID_KEY]\n        );\n      }\n    });\n  }\n  destroy() {\n    this.emit(\"destroy\", [this]);\n    this.othersUnsub();\n    this.setLocalState(null);\n    super.destroy();\n  }\n  getLocalState() {\n    const presence = this.room.getPresence();\n    if (Object.keys(presence).length === 0 || typeof presence[Y_PRESENCE_KEY] === \"undefined\") {\n      return null;\n    }\n    return presence[Y_PRESENCE_KEY];\n  }\n  setLocalState(state) {\n    const presence = this.room.getSelf()?.presence;\n    if (state === null) {\n      if (presence === void 0) {\n        return;\n      }\n      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });\n      this.emit(\"update\", [\n        { added: [], updated: [], removed: [this.doc.clientID] },\n        \"local\"\n      ]);\n      return;\n    }\n    const yPresence = presence?.[Y_PRESENCE_KEY];\n    const added = yPresence === void 0 ? [this.doc.clientID] : [];\n    const updated = yPresence === void 0 ? [] : [this.doc.clientID];\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: {\n        ...yPresence || {},\n        ...state || {}\n      }\n    });\n    this.emit(\"update\", [{ added, updated, removed: [] }, \"local\"]);\n  }\n  setLocalStateField(field, value) {\n    const presence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    const update = { [field]: value };\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: { ...presence || {}, ...update }\n    });\n  }\n  // Translate liveblocks presence to yjs awareness\n  getStates() {\n    const others = this.room.getOthers();\n    const states = others.reduce((acc, otherUser) => {\n      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];\n      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY];\n      if (otherPresence !== void 0 && otherClientId !== void 0) {\n        acc.set(otherClientId, otherPresence || {});\n      }\n      return acc;\n    }, /* @__PURE__ */ new Map());\n    const localPresence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    if (localPresence !== void 0) {\n      states.set(this.doc.clientID, localPresence);\n    }\n    return states;\n  }\n};\n\n// src/doc.ts\n\n\nvar yDocHandler = class extends Observable {\n  constructor({\n    doc,\n    isRoot,\n    updateDoc,\n    fetchDoc\n  }) {\n    super();\n    this.unsubscribers = [];\n    this._synced = false;\n    this.handleServerUpdate = ({\n      update,\n      stateVector,\n      readOnly\n    }) => {\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate(this.doc, update, \"backend\");\n      if (stateVector) {\n        if (!readOnly) {\n          try {\n            const localUpdate = yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate(\n              this.doc,\n              js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.toUint8Array(stateVector)\n            );\n            this.updateRoomDoc(localUpdate);\n          } catch (e) {\n            console.warn(e);\n          }\n        }\n        this.synced = true;\n      }\n    };\n    this.syncDoc = () => {\n      this.synced = false;\n      const encodedVector = js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.fromUint8Array(yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateVector(this.doc));\n      this.fetchRoomDoc(encodedVector);\n    };\n    this.updateHandler = (update, origin) => {\n      if (origin !== \"backend\") {\n        this.updateRoomDoc(update);\n      }\n    };\n    this.doc = doc;\n    this.doc.on(\"update\", this.updateHandler);\n    this.updateRoomDoc = (update) => {\n      updateDoc(update, isRoot ? void 0 : this.doc.guid);\n    };\n    this.fetchRoomDoc = (vector) => {\n      fetchDoc(vector, isRoot ? void 0 : this.doc.guid);\n    };\n    this.syncDoc();\n  }\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this._synced;\n  }\n  set synced(state) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    }\n  }\n  destroy() {\n    this.doc.off(\"update\", this.updateHandler);\n    this.unsubscribers.forEach((unsub) => unsub());\n    this._observers = /* @__PURE__ */ new Map();\n    this.doc.destroy();\n  }\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/yjs\";\nvar PKG_VERSION = \"2.9.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/index.ts\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_2__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar LiveblocksYjsProvider = class extends Observable {\n  constructor(room, doc, options = {}) {\n    super();\n    this.unsubscribers = [];\n    this.subdocHandlers = /* @__PURE__ */ new Map();\n    this.pending = [];\n    this.handleSubdocs = ({\n      loaded,\n      removed,\n      added\n    }) => {\n      loaded.forEach(this.createSubdocHandler);\n      if (this.options.autoloadSubdocs) {\n        for (const subdoc of added) {\n          if (!this.subdocHandlers.has(subdoc.guid)) {\n            subdoc.load();\n          }\n        }\n      }\n      for (const subdoc of removed) {\n        if (this.subdocHandlers.has(subdoc.guid)) {\n          this.subdocHandlers.get(subdoc.guid)?.destroy();\n          this.subdocHandlers.delete(subdoc.guid);\n        }\n      }\n    };\n    this.getUniqueUpdateId = (update) => {\n      const clock = yjs__WEBPACK_IMPORTED_MODULE_0__.parseUpdateMeta(update).to.get(this.rootDoc.clientID) ?? \"-1\";\n      return this.rootDoc.clientID + \":\" + clock;\n    };\n    this.updateDoc = (update, guid) => {\n      const canWrite = this.room.getSelf()?.canWrite ?? true;\n      if (canWrite) {\n        const updateId = this.getUniqueUpdateId(update);\n        this.pending.push(updateId);\n        this.room.updateYDoc(js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.fromUint8Array(update), guid);\n        this.emit(\"status\", [this.getStatus()]);\n      }\n    };\n    this.fetchDoc = (vector, guid) => {\n      this.room.fetchYDoc(vector, guid);\n    };\n    this.createSubdocHandler = (subdoc) => {\n      if (this.subdocHandlers.has(subdoc.guid)) {\n        this.subdocHandlers.get(subdoc.guid)?.syncDoc();\n        return;\n      }\n      const handler = new yDocHandler({\n        doc: subdoc,\n        isRoot: false,\n        updateDoc: this.updateDoc,\n        fetchDoc: this.fetchDoc\n      });\n      this.subdocHandlers.set(subdoc.guid, handler);\n    };\n    // attempt to load a subdoc of a given guid\n    this.loadSubdoc = (guid) => {\n      for (const subdoc of this.rootDoc.subdocs) {\n        if (subdoc.guid === guid) {\n          subdoc.load();\n          return true;\n        }\n      }\n      return false;\n    };\n    this.syncDoc = () => {\n      this.rootDocHandler.syncDoc();\n      for (const [_, handler] of this.subdocHandlers) {\n        handler.syncDoc();\n      }\n    };\n    this.rootDoc = doc;\n    this.room = room;\n    this.options = options;\n    this.rootDocHandler = new yDocHandler({\n      doc,\n      isRoot: true,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc\n    });\n    room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_2__.kInternal].setProvider(this);\n    this.awareness = new Awareness(this.rootDoc, this.room);\n    this.unsubscribers.push(\n      this.room.events.status.subscribe((status) => {\n        if (status === \"connected\") {\n          this.rootDocHandler.syncDoc();\n        } else {\n          this.rootDocHandler.synced = false;\n        }\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n    this.unsubscribers.push(\n      this.room.events.ydoc.subscribe((message) => {\n        const { type } = message;\n        if (type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_2__.ClientMsgCode.UPDATE_YDOC) {\n          return;\n        }\n        const { stateVector, update: updateStr, guid } = message;\n        const canWrite = this.room.getSelf()?.canWrite ?? true;\n        const update = js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.toUint8Array(updateStr);\n        let foundPendingUpdate = false;\n        const updateId = this.getUniqueUpdateId(update);\n        this.pending = this.pending.filter((pendingUpdate) => {\n          if (pendingUpdate === updateId) {\n            foundPendingUpdate = true;\n            return false;\n          }\n          return true;\n        });\n        if (!foundPendingUpdate) {\n          if (guid !== void 0) {\n            this.subdocHandlers.get(guid)?.handleServerUpdate({\n              update,\n              stateVector,\n              readOnly: !canWrite\n            });\n          } else {\n            this.rootDocHandler.handleServerUpdate({\n              update,\n              stateVector,\n              readOnly: !canWrite\n            });\n          }\n        }\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n    this.rootDocHandler.on(\"synced\", () => {\n      const state = this.rootDocHandler.synced;\n      for (const [_, handler] of this.subdocHandlers) {\n        handler.syncDoc();\n      }\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n      this.emit(\"status\", [this.getStatus()]);\n    });\n    this.rootDoc.on(\"subdocs\", this.handleSubdocs);\n    this.syncDoc();\n  }\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this.rootDocHandler.synced;\n  }\n  getStatus() {\n    if (!this.synced) {\n      return \"loading\" /* Loading */;\n    }\n    return this.pending.length === 0 ? \"synchronized\" /* Synchronized */ : \"synchronizing\" /* Synchronizing */;\n  }\n  destroy() {\n    this.unsubscribers.forEach((unsub) => unsub());\n    this.awareness.destroy();\n    this.rootDocHandler.destroy();\n    this._observers = /* @__PURE__ */ new Map();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.destroy();\n    }\n    this.subdocHandlers.clear();\n    super.destroy();\n  }\n  // Some provider implementations expect to be able to call connect/disconnect, implement as noop\n  disconnect() {\n  }\n  connect() {\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MveWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUN5RTtBQUMzQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MveWpzL2Rpc3QvaW5kZXgubWpzP2NhZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBDbGllbnRNc2dDb2RlLCBkZXRlY3REdXBlcywga0ludGVybmFsIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IEJhc2U2NCBhcyBCYXNlNjQyIH0gZnJvbSBcImpzLWJhc2U2NFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9tYXAuanNcbnZhciBjcmVhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIHNldElmVW5kZWZpbmVkID0gKG1hcCwga2V5LCBjcmVhdGVUKSA9PiB7XG4gIGxldCBzZXQgPSBtYXAuZ2V0KGtleSk7XG4gIGlmIChzZXQgPT09IHZvaWQgMCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9zZXQuanNcbnZhciBjcmVhdGUyID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvYXJyYXkuanNcbnZhciBmcm9tID0gQXJyYXkuZnJvbTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qc1xudmFyIE9ic2VydmFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IGNyZWF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24obmFtZSwgZikge1xuICAgIHNldElmVW5kZWZpbmVkKHRoaXMuX29ic2VydmVycywgbmFtZSwgY3JlYXRlMikuYWRkKGYpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZShuYW1lLCBmKSB7XG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpO1xuICAgICAgZiguLi5hcmdzKTtcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgX2YpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb2ZmKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpO1xuICAgIGlmIChvYnNlcnZlcnMgIT09IHZvaWQgMCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKTtcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW1pdCBhIG5hbWVkIGV2ZW50LiBBbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW4gdG8gdGhlXG4gICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0b2RvIFRoaXMgc2hvdWxkIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtOfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIGVtaXQobmFtZSwgYXJncykge1xuICAgIHJldHVybiBmcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IGNyZWF0ZSgpKS52YWx1ZXMoKSkuZm9yRWFjaCgoZikgPT4gZiguLi5hcmdzKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBjcmVhdGUoKTtcbiAgfVxufTtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgKiBhcyBZMiBmcm9tIFwieWpzXCI7XG5cbi8vIHNyYy9hd2FyZW5lc3MudHNcbnZhciBZX1BSRVNFTkNFX0tFWSA9IFwiX195anNcIjtcbnZhciBZX1BSRVNFTkNFX0lEX0tFWSA9IFwiX195anNfY2xpZW50aWRcIjtcbnZhciBBd2FyZW5lc3MgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3Rvcihkb2MsIHJvb20pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvLyB1c2VkIHRvIG1hcCBsaXZlYmxvY2sncyBBY3RvcklkIHRvIFlqcyBDbGllbnRJRCwgYm90aCB1bmlxdWUgbnVtYmVycyByZXByZXNlbnRpbmcgYSBjbGllbnRcbiAgICB0aGlzLmFjdG9yVG9DbGllbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIE1ldGEgaXMgdXNlZCB0byBrZWVwIHRyYWNrIGFuZCB0aW1lb3V0IHVzZXJzIHdobyBkaXNjb25uZWN0LiBMaXZlYmxvY2tzIHByb3ZpZGVzIHRoaXMgZm9yIHVzLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gbWFuYWdlIGl0IGhlcmUuIFVuZm9ydHVuYXRlbHksIGl0J3MgZXhwZWN0ZWQgdG8gZXhpc3QgYnkgdmFyaW91cyBpbnRlZ3JhdGlvbnMsIHNvIGl0J3MgYW4gZW1wdHkgbWFwLlxuICAgIHRoaXMubWV0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLy8gX2NoZWNrSW50ZXJ2YWwgdGhpcyB3b3VsZCBob2xkIGEgdGltZXIgdG8gcmVtb3ZlIHVzZXJzLCBidXQgTGl2ZWJsb2NrJ3MgcHJlc2VuY2UgYWxyZWFkeSBoYW5kbGVzIHRoaXNcbiAgICAvLyB1bmZvcnR1bmF0ZWx5IGl0J3MgdHlwZWQgYnkgdmFyaW91cyBpbnRlZ3JhdGlvbnNcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gMDtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLnJvb20gPSByb29tO1xuICAgIHRoaXMucm9vbS51cGRhdGVQcmVzZW5jZSh7XG4gICAgICBbWV9QUkVTRU5DRV9JRF9LRVldOiB0aGlzLmRvYy5jbGllbnRJRFxuICAgIH0pO1xuICAgIHRoaXMub3RoZXJzVW5zdWIgPSB0aGlzLnJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICBsZXQgdXBkYXRlcztcbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImxlYXZlXCIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50SWQgPSB0aGlzLmFjdG9yVG9DbGllbnRNYXAuZ2V0KFxuICAgICAgICAgIGV2ZW50LnVzZXIuY29ubmVjdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0YXJnZXRDbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IHsgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW3RhcmdldENsaWVudElkXSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVidWlsZEFjdG9yVG9DbGllbnRNYXAoZXZlbnQub3RoZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImVudGVyXCIgfHwgZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICAgIGNvbnN0IHRhcmdldENsaWVudElkID0gdGhpcy5hY3RvclRvQ2xpZW50TWFwLmdldChcbiAgICAgICAgICBldmVudC51c2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICBpZiAodGFyZ2V0Q2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSB7XG4gICAgICAgICAgICBhZGRlZDogZXZlbnQudHlwZSA9PT0gXCJlbnRlclwiID8gW3RhcmdldENsaWVudElkXSA6IFtdLFxuICAgICAgICAgICAgdXBkYXRlZDogZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGVcIiA/IFt0YXJnZXRDbGllbnRJZF0gOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicmVzZXRcIikge1xuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBbdXBkYXRlcywgXCJwcmVzZW5jZVwiXSk7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbdXBkYXRlcywgXCJwcmVzZW5jZVwiXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZEFjdG9yVG9DbGllbnRNYXAob3RoZXJzKSB7XG4gICAgdGhpcy5hY3RvclRvQ2xpZW50TWFwLmNsZWFyKCk7XG4gICAgb3RoZXJzLmZvckVhY2goKHVzZXIpID0+IHtcbiAgICAgIGlmICh1c2VyLnByZXNlbmNlW1lfUFJFU0VOQ0VfSURfS0VZXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuYWN0b3JUb0NsaWVudE1hcC5zZXQoXG4gICAgICAgICAgdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgdXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0lEX0tFWV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIiwgW3RoaXNdKTtcbiAgICB0aGlzLm90aGVyc1Vuc3ViKCk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRMb2NhbFN0YXRlKCkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFByZXNlbmNlKCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByZXNlbmNlKS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHByZXNlbmNlW1lfUFJFU0VOQ0VfS0VZXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gIH1cbiAgc2V0TG9jYWxTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFNlbGYoKT8ucHJlc2VuY2U7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICBpZiAocHJlc2VuY2UgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2UoeyAuLi5wcmVzZW5jZSwgW1lfUFJFU0VOQ0VfS0VZXTogbnVsbCB9KTtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbXG4gICAgICAgIHsgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW3RoaXMuZG9jLmNsaWVudElEXSB9LFxuICAgICAgICBcImxvY2FsXCJcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5UHJlc2VuY2UgPSBwcmVzZW5jZT8uW1lfUFJFU0VOQ0VfS0VZXTtcbiAgICBjb25zdCBhZGRlZCA9IHlQcmVzZW5jZSA9PT0gdm9pZCAwID8gW3RoaXMuZG9jLmNsaWVudElEXSA6IFtdO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB5UHJlc2VuY2UgPT09IHZvaWQgMCA/IFtdIDogW3RoaXMuZG9jLmNsaWVudElEXTtcbiAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2Uoe1xuICAgICAgW1lfUFJFU0VOQ0VfS0VZXToge1xuICAgICAgICAuLi55UHJlc2VuY2UgfHwge30sXG4gICAgICAgIC4uLnN0YXRlIHx8IHt9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkOiBbXSB9LCBcImxvY2FsXCJdKTtcbiAgfVxuICBzZXRMb2NhbFN0YXRlRmllbGQoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgY29uc3QgdXBkYXRlID0geyBbZmllbGRdOiB2YWx1ZSB9O1xuICAgIHRoaXMucm9vbS51cGRhdGVQcmVzZW5jZSh7XG4gICAgICBbWV9QUkVTRU5DRV9LRVldOiB7IC4uLnByZXNlbmNlIHx8IHt9LCAuLi51cGRhdGUgfVxuICAgIH0pO1xuICB9XG4gIC8vIFRyYW5zbGF0ZSBsaXZlYmxvY2tzIHByZXNlbmNlIHRvIHlqcyBhd2FyZW5lc3NcbiAgZ2V0U3RhdGVzKCkge1xuICAgIGNvbnN0IG90aGVycyA9IHRoaXMucm9vbS5nZXRPdGhlcnMoKTtcbiAgICBjb25zdCBzdGF0ZXMgPSBvdGhlcnMucmVkdWNlKChhY2MsIG90aGVyVXNlcikgPT4ge1xuICAgICAgY29uc3Qgb3RoZXJQcmVzZW5jZSA9IG90aGVyVXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgICBjb25zdCBvdGhlckNsaWVudElkID0gb3RoZXJVc2VyLnByZXNlbmNlW1lfUFJFU0VOQ0VfSURfS0VZXTtcbiAgICAgIGlmIChvdGhlclByZXNlbmNlICE9PSB2b2lkIDAgJiYgb3RoZXJDbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFjYy5zZXQob3RoZXJDbGllbnRJZCwgb3RoZXJQcmVzZW5jZSB8fCB7fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGxvY2FsUHJlc2VuY2UgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgaWYgKGxvY2FsUHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgc3RhdGVzLnNldCh0aGlzLmRvYy5jbGllbnRJRCwgbG9jYWxQcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9kb2MudHNcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gXCJqcy1iYXNlNjRcIjtcbmltcG9ydCAqIGFzIFkgZnJvbSBcInlqc1wiO1xudmFyIHlEb2NIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvYyxcbiAgICBpc1Jvb3QsXG4gICAgdXBkYXRlRG9jLFxuICAgIGZldGNoRG9jXG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycyA9IFtdO1xuICAgIHRoaXMuX3N5bmNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaGFuZGxlU2VydmVyVXBkYXRlID0gKHtcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHN0YXRlVmVjdG9yLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KSA9PiB7XG4gICAgICBZLmFwcGx5VXBkYXRlKHRoaXMuZG9jLCB1cGRhdGUsIFwiYmFja2VuZFwiKTtcbiAgICAgIGlmIChzdGF0ZVZlY3Rvcikge1xuICAgICAgICBpZiAoIXJlYWRPbmx5KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVXBkYXRlID0gWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKFxuICAgICAgICAgICAgICB0aGlzLmRvYyxcbiAgICAgICAgICAgICAgQmFzZTY0LnRvVWludDhBcnJheShzdGF0ZVZlY3RvcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJvb21Eb2MobG9jYWxVcGRhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zeW5jRG9jID0gKCkgPT4ge1xuICAgICAgdGhpcy5zeW5jZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGVuY29kZWRWZWN0b3IgPSBCYXNlNjQuZnJvbVVpbnQ4QXJyYXkoWS5lbmNvZGVTdGF0ZVZlY3Rvcih0aGlzLmRvYykpO1xuICAgICAgdGhpcy5mZXRjaFJvb21Eb2MoZW5jb2RlZFZlY3Rvcik7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSAodXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgICAgIGlmIChvcmlnaW4gIT09IFwiYmFja2VuZFwiKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUm9vbURvYyh1cGRhdGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5kb2Mub24oXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGVIYW5kbGVyKTtcbiAgICB0aGlzLnVwZGF0ZVJvb21Eb2MgPSAodXBkYXRlKSA9PiB7XG4gICAgICB1cGRhdGVEb2ModXBkYXRlLCBpc1Jvb3QgPyB2b2lkIDAgOiB0aGlzLmRvYy5ndWlkKTtcbiAgICB9O1xuICAgIHRoaXMuZmV0Y2hSb29tRG9jID0gKHZlY3RvcikgPT4ge1xuICAgICAgZmV0Y2hEb2ModmVjdG9yLCBpc1Jvb3QgPyB2b2lkIDAgOiB0aGlzLmRvYy5ndWlkKTtcbiAgICB9O1xuICAgIHRoaXMuc3luY0RvYygpO1xuICB9XG4gIC8vIFRoZSBzeW5jJ2QgcHJvcGVydHkgaXMgcmVxdWlyZWQgYnkgc29tZSBwcm92aWRlciBpbXBsZW1lbnRhdGlvbnNcbiAgZ2V0IHN5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkO1xuICB9XG4gIHNldCBzeW5jZWQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3luY2VkICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5fc3luY2VkID0gc3RhdGU7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jZWRcIiwgW3N0YXRlXSk7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jXCIsIFtzdGF0ZV0pO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9jLm9mZihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZUhhbmRsZXIpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRvYy5kZXN0cm95KCk7XG4gIH1cbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3lqc1wiO1xudmFyIFBLR19WRVJTSU9OID0gXCIyLjkuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG52YXIgTGl2ZWJsb2Nrc1lqc1Byb3ZpZGVyID0gY2xhc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3Iocm9vbSwgZG9jLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycyA9IFtdO1xuICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgIHRoaXMuaGFuZGxlU3ViZG9jcyA9ICh7XG4gICAgICBsb2FkZWQsXG4gICAgICByZW1vdmVkLFxuICAgICAgYWRkZWRcbiAgICB9KSA9PiB7XG4gICAgICBsb2FkZWQuZm9yRWFjaCh0aGlzLmNyZWF0ZVN1YmRvY0hhbmRsZXIpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbG9hZFN1YmRvY3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgYWRkZWQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgICAgICAgc3ViZG9jLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHJlbW92ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuZ2V0KHN1YmRvYy5ndWlkKT8uZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuZGVsZXRlKHN1YmRvYy5ndWlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRVbmlxdWVVcGRhdGVJZCA9ICh1cGRhdGUpID0+IHtcbiAgICAgIGNvbnN0IGNsb2NrID0gWTIucGFyc2VVcGRhdGVNZXRhKHVwZGF0ZSkudG8uZ2V0KHRoaXMucm9vdERvYy5jbGllbnRJRCkgPz8gXCItMVwiO1xuICAgICAgcmV0dXJuIHRoaXMucm9vdERvYy5jbGllbnRJRCArIFwiOlwiICsgY2xvY2s7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZURvYyA9ICh1cGRhdGUsIGd1aWQpID0+IHtcbiAgICAgIGNvbnN0IGNhbldyaXRlID0gdGhpcy5yb29tLmdldFNlbGYoKT8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICAgIGlmIChjYW5Xcml0ZSkge1xuICAgICAgICBjb25zdCB1cGRhdGVJZCA9IHRoaXMuZ2V0VW5pcXVlVXBkYXRlSWQodXBkYXRlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnB1c2godXBkYXRlSWQpO1xuICAgICAgICB0aGlzLnJvb20udXBkYXRlWURvYyhCYXNlNjQyLmZyb21VaW50OEFycmF5KHVwZGF0ZSksIGd1aWQpO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgW3RoaXMuZ2V0U3RhdHVzKCldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZmV0Y2hEb2MgPSAodmVjdG9yLCBndWlkKSA9PiB7XG4gICAgICB0aGlzLnJvb20uZmV0Y2hZRG9jKHZlY3RvciwgZ3VpZCk7XG4gICAgfTtcbiAgICB0aGlzLmNyZWF0ZVN1YmRvY0hhbmRsZXIgPSAoc3ViZG9jKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdWJkb2NIYW5kbGVycy5oYXMoc3ViZG9jLmd1aWQpKSB7XG4gICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuZ2V0KHN1YmRvYy5ndWlkKT8uc3luY0RvYygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoYW5kbGVyID0gbmV3IHlEb2NIYW5kbGVyKHtcbiAgICAgICAgZG9jOiBzdWJkb2MsXG4gICAgICAgIGlzUm9vdDogZmFsc2UsXG4gICAgICAgIHVwZGF0ZURvYzogdGhpcy51cGRhdGVEb2MsXG4gICAgICAgIGZldGNoRG9jOiB0aGlzLmZldGNoRG9jXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuc2V0KHN1YmRvYy5ndWlkLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8vIGF0dGVtcHQgdG8gbG9hZCBhIHN1YmRvYyBvZiBhIGdpdmVuIGd1aWRcbiAgICB0aGlzLmxvYWRTdWJkb2MgPSAoZ3VpZCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgdGhpcy5yb290RG9jLnN1YmRvY3MpIHtcbiAgICAgICAgaWYgKHN1YmRvYy5ndWlkID09PSBndWlkKSB7XG4gICAgICAgICAgc3ViZG9jLmxvYWQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5zeW5jRG9jID0gKCkgPT4ge1xuICAgICAgdGhpcy5yb290RG9jSGFuZGxlci5zeW5jRG9jKCk7XG4gICAgICBmb3IgKGNvbnN0IFtfLCBoYW5kbGVyXSBvZiB0aGlzLnN1YmRvY0hhbmRsZXJzKSB7XG4gICAgICAgIGhhbmRsZXIuc3luY0RvYygpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yb290RG9jID0gZG9jO1xuICAgIHRoaXMucm9vbSA9IHJvb207XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyID0gbmV3IHlEb2NIYW5kbGVyKHtcbiAgICAgIGRvYyxcbiAgICAgIGlzUm9vdDogdHJ1ZSxcbiAgICAgIHVwZGF0ZURvYzogdGhpcy51cGRhdGVEb2MsXG4gICAgICBmZXRjaERvYzogdGhpcy5mZXRjaERvY1xuICAgIH0pO1xuICAgIHJvb21ba0ludGVybmFsXS5zZXRQcm92aWRlcih0aGlzKTtcbiAgICB0aGlzLmF3YXJlbmVzcyA9IG5ldyBBd2FyZW5lc3ModGhpcy5yb290RG9jLCB0aGlzLnJvb20pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgdGhpcy5yb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY0RvYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIFt0aGlzLmdldFN0YXR1cygpXSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy51bnN1YnNjcmliZXJzLnB1c2goXG4gICAgICB0aGlzLnJvb20uZXZlbnRzLnlkb2Muc3Vic2NyaWJlKChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IENsaWVudE1zZ0NvZGUuVVBEQVRFX1lET0MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0ZVZlY3RvciwgdXBkYXRlOiB1cGRhdGVTdHIsIGd1aWQgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gdGhpcy5yb29tLmdldFNlbGYoKT8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gQmFzZTY0Mi50b1VpbnQ4QXJyYXkodXBkYXRlU3RyKTtcbiAgICAgICAgbGV0IGZvdW5kUGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB1cGRhdGVJZCA9IHRoaXMuZ2V0VW5pcXVlVXBkYXRlSWQodXBkYXRlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmZpbHRlcigocGVuZGluZ1VwZGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChwZW5kaW5nVXBkYXRlID09PSB1cGRhdGVJZCkge1xuICAgICAgICAgICAgZm91bmRQZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZvdW5kUGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICAgIGlmIChndWlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuZ2V0KGd1aWQpPy5oYW5kbGVTZXJ2ZXJVcGRhdGUoe1xuICAgICAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgICAgIHN0YXRlVmVjdG9yLFxuICAgICAgICAgICAgICByZWFkT25seTogIWNhbldyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290RG9jSGFuZGxlci5oYW5kbGVTZXJ2ZXJVcGRhdGUoe1xuICAgICAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgICAgIHN0YXRlVmVjdG9yLFxuICAgICAgICAgICAgICByZWFkT25seTogIWNhbldyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIFt0aGlzLmdldFN0YXR1cygpXSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5yb290RG9jSGFuZGxlci5vbihcInN5bmNlZFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMucm9vdERvY0hhbmRsZXIuc3luY2VkO1xuICAgICAgZm9yIChjb25zdCBbXywgaGFuZGxlcl0gb2YgdGhpcy5zdWJkb2NIYW5kbGVycykge1xuICAgICAgICBoYW5kbGVyLnN5bmNEb2MoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcInN5bmNlZFwiLCBbc3RhdGVdKTtcbiAgICAgIHRoaXMuZW1pdChcInN5bmNcIiwgW3N0YXRlXSk7XG4gICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgW3RoaXMuZ2V0U3RhdHVzKCldKTtcbiAgICB9KTtcbiAgICB0aGlzLnJvb3REb2Mub24oXCJzdWJkb2NzXCIsIHRoaXMuaGFuZGxlU3ViZG9jcyk7XG4gICAgdGhpcy5zeW5jRG9jKCk7XG4gIH1cbiAgLy8gVGhlIHN5bmMnZCBwcm9wZXJ0eSBpcyByZXF1aXJlZCBieSBzb21lIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uc1xuICBnZXQgc3luY2VkKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZDtcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgaWYgKCF0aGlzLnN5bmNlZCkge1xuICAgICAgcmV0dXJuIFwibG9hZGluZ1wiIC8qIExvYWRpbmcgKi87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwID8gXCJzeW5jaHJvbml6ZWRcIiAvKiBTeW5jaHJvbml6ZWQgKi8gOiBcInN5bmNocm9uaXppbmdcIiAvKiBTeW5jaHJvbml6aW5nICovO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB0aGlzLmF3YXJlbmVzcy5kZXN0cm95KCk7XG4gICAgdGhpcy5yb290RG9jSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtfLCBoYW5kbGVyXSBvZiB0aGlzLnN1YmRvY0hhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJkb2NIYW5kbGVycy5jbGVhcigpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICAvLyBTb21lIHByb3ZpZGVyIGltcGxlbWVudGF0aW9ucyBleHBlY3QgdG8gYmUgYWJsZSB0byBjYWxsIGNvbm5lY3QvZGlzY29ubmVjdCwgaW1wbGVtZW50IGFzIG5vb3BcbiAgZGlzY29ubmVjdCgpIHtcbiAgfVxuICBjb25uZWN0KCkge1xuICB9XG59O1xuZXhwb3J0IHtcbiAgTGl2ZWJsb2Nrc1lqc1Byb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/yjs/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   StopRetrying: () => (/* binding */ StopRetrying2),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.9.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function _forceClear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    _forceClear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options.size ?? DEFAULT_SIZE;\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch) {\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let notifyImmediately = true;\n  let dirty = false;\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const oldState = state;\n    const newState = callback(oldState);\n    if (newState !== oldState) {\n      state = newState;\n      dirty = true;\n    }\n    if (notifyImmediately) {\n      notify();\n    }\n  }\n  function notify() {\n    if (!dirty) {\n      return;\n    }\n    dirty = false;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function batch(cb) {\n    if (notifyImmediately === false) {\n      return cb();\n    }\n    notifyImmediately = false;\n    try {\n      cb();\n    } finally {\n      notifyImmediately = true;\n      notify();\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    batch,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/http-client.ts\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  );\n}\n\n// src/notifications.ts\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"Expected a /v2/c/* endpoint\");\n    }\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url2 = urljoin(baseUrl, endpoint, params);\n    const response = await fetcher(url2.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await fetchJson(url`/v2/c/inbox-notifications`, void 0, {\n      cursor: options?.cursor,\n      limit: PAGE_SIZE\n    });\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(since) {\n    const json = await fetchJson(url`/v2/c/inbox-notifications/delta`, void 0, {\n      since: since.toISOString()\n    });\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(url`/v2/c/inbox-notifications/count`);\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(url`/v2/c/inbox-notifications/read`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(url`/v2/c/inbox-notifications/read`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await fetchJson(url`/v2/c/inbox-notifications`, {\n      method: \"DELETE\"\n    });\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await fetchJson(url`/v2/c/inbox-notifications/${inboxNotificationId}`, {\n      method: \"DELETE\"\n    });\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await fetchJson(url`/v2/c/threads`, void 0, {\n      cursor: options.cursor,\n      query,\n      limit: PAGE_SIZE\n    });\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await fetchJson(url`/v2/c/threads`, void 0, {\n      since: options.since.toISOString()\n    });\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  return {\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/autoRetry.ts\nasync function autoRetry(promiseFn, maxTries, backoff, throwError) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    const promise = promiseFn();\n    try {\n      return await promise;\n    } catch (err) {\n      if (throwError?.(err) || err instanceof StopRetrying2) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\nvar StopRetrying2 = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar GET_ATTACHMENT_URLS_BATCH_DELAY = 50;\nvar ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\nvar ATTACHMENT_PART_BATCH_SIZE = 5;\nvar RETRY_ATTEMPTS = 10;\nvar RETRY_DELAYS = [\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3\n];\nfunction splitFileIntoParts(file) {\n  const parts = [];\n  let start = 0;\n  while (start < file.size) {\n    const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n    parts.push({\n      partNumber: parts.length + 1,\n      part: file.slice(start, end)\n    });\n    start = end;\n  }\n  return parts;\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Y.js\n    provider: void 0,\n    onProviderUpdate: makeEventSource(),\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(endpoint, authValue, options2, params) {\n    if (!endpoint.startsWith(\"/v2/c/rooms/\")) {\n      raise(\"Expected a /v2/c/rooms/* endpoint\");\n    }\n    const url2 = urljoin(config.baseUrl, endpoint, params);\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url2, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(url`/v2/c/rooms/${roomId}/storage`, authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      endpoint === \"/send-message\" ? url`/v2/c/rooms/${config.roomId}/send-message` : url`/v2/c/rooms/${config.roomId}/text-metadata`,\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n      }\n    );\n  }\n  async function createTextMention(userId, mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/text-mentions`,\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          userId,\n          mentionId\n        })\n      }\n    );\n  }\n  async function deleteTextMention(mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`,\n      managedSocket.authValue,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/text-metadata`,\n      authValue,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ type, rootKey })\n      }\n    );\n  }\n  async function listTextVersions() {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/versions`,\n      authValue,\n      {\n        method: \"GET\"\n      }\n    );\n  }\n  async function getTextVersion(versionId) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`,\n      authValue,\n      { method: \"GET\" }\n    );\n  }\n  async function createTextVersion() {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(\n      url`/v2/c/rooms/${config.roomId}/version`,\n      authValue,\n      { method: \"POST\" }\n    );\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  async function fetchCommentsApi(endpoint, params, options2) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(endpoint, authValue, options2, params);\n  }\n  async function fetchCommentsJson(endpoint, options2, params) {\n    const response = await fetchCommentsApi(endpoint, params, options2);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreadsSince(options2) {\n    const response = await fetchCommentsApi(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      { since: options2?.since?.toISOString() },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: {\n          updated: json.data.map(convertToThreadData),\n          deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n        },\n        inboxNotifications: {\n          updated: json.inboxNotifications.map(convertToInboxNotificationData),\n          deleted: json.deletedInboxNotifications.map(\n            convertToInboxNotificationDeleteInfo\n          )\n        },\n        requestedAt: new Date(json.meta.requestedAt)\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: {\n          updated: [],\n          deleted: []\n        },\n        inboxNotifications: {\n          updated: [],\n          deleted: []\n        },\n        requestedAt: /* @__PURE__ */ new Date()\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThreads(options2) {\n    let query;\n    if (options2?.query) {\n      query = objectToQuery(options2.query);\n    }\n    const PAGE_SIZE = 50;\n    const response = await fetchCommentsApi(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      {\n        cursor: options2?.cursor,\n        query,\n        limit: PAGE_SIZE\n      },\n      { headers: { \"Content-Type\": \"application/json\" } }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map(convertToThreadData),\n        inboxNotifications: json.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: json.meta.nextCursor,\n        requestedAt: new Date(json.meta.requestedAt)\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        nextCursor: null,\n        requestedAt: /* @__PURE__ */ new Date()\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread(threadId) {\n    const response = await fetchCommentsApi(\n      url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId = createCommentId(),\n    threadId = createThreadId(),\n    attachmentIds\n  }) {\n    const thread = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body,\n            attachmentIds\n          },\n          metadata\n        })\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(threadId) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}`,\n      { method: \"DELETE\" }\n    );\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function markThreadAsResolved(threadId) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`,\n      { method: \"POST\" }\n    );\n  }\n  async function markThreadAsUnresolved(threadId) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`,\n      { method: \"POST\" }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId = createCommentId(),\n    body,\n    attachmentIds\n  }) {\n    const comment = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body,\n          attachmentIds\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body,\n    attachmentIds\n  }) {\n    const comment = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body,\n          attachmentIds\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\n      { method: \"DELETE\" }\n    );\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`,\n      { method: \"DELETE\" }\n    );\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    const abortSignal = options2.signal;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof CommentsApiError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        () => fetchCommentsJson(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          {\n            method: \"PUT\",\n            body: attachment.file,\n            signal: abortSignal\n          },\n          {\n            fileSize: attachment.size\n          }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        () => fetchCommentsJson(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          {\n            method: \"POST\",\n            signal: abortSignal\n          },\n          {\n            fileSize: attachment.size\n          }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, ATTACHMENT_PART_BATCH_SIZE);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                () => fetchCommentsJson(\n                  url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  {\n                    method: \"PUT\",\n                    body: part,\n                    signal: abortSignal\n                  }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return fetchCommentsJson(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({ parts: sortedUploadedParts }),\n            signal: abortSignal\n          }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await fetchCommentsApi(\n              url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              void 0,\n              {\n                method: \"DELETE\"\n              }\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  async function getAttachmentUrls(attachmentIds) {\n    const { urls } = await fetchCommentsJson(\n      url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ attachmentIds })\n      }\n    );\n    return urls;\n  }\n  const batchedGetAttachmentUrls = new Batch(\n    async (batchedAttachmentIds) => {\n      const attachmentIds = batchedAttachmentIds.flat();\n      const attachmentUrls = await getAttachmentUrls(attachmentIds);\n      return attachmentUrls.map(\n        (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n      );\n    },\n    { delay: GET_ATTACHMENT_URLS_BATCH_DELAY }\n  );\n  const attachmentUrlsStore = createBatchStore(batchedGetAttachmentUrls);\n  function getAttachmentUrl(attachmentId) {\n    return batchedGetAttachmentUrls.get(attachmentId);\n  }\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(endpoint, authValue, options2);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getNotificationSettings() {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`\n    );\n  }\n  function updateNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ inboxNotificationIds })\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        getProvider() {\n          return context.provider;\n        },\n        setProvider(provider) {\n          context.provider = provider;\n          context.onProviderUpdate.notify();\n        },\n        onProviderUpdate: context.onProviderUpdate.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current,\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const fetcher = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  fetch;\n  const httpClientLike = createNotificationsApi({\n    baseUrl,\n    fetcher,\n    authManager,\n    currentUserIdStore\n  });\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  return Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      ...httpClientLike,\n      // Internal\n      [kInternal]: {\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        // \"All\" threads (= \"user\" threads)\n        getUserThreads_experimental: httpClientLike.getUserThreads_experimental,\n        getUserThreadsSince_experimental: httpClientLike.getUserThreadsSince_experimental\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback, interval) {\n  let context = { state: \"stopped\" };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule();\n    }\n    void callback();\n  }\n  function schedule() {\n    context = {\n      state: \"running\",\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval)\n    };\n  }\n  function start() {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule();\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = { state: \"stopped\" };\n  }\n  function enable(condition) {\n    if (condition) {\n      start();\n    } else {\n      stop();\n    }\n  }\n  return {\n    enable\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUIsR0FBRyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0EscUdBQXFHLGtCQUFrQjtBQUN2SDtBQUNBO0FBQ0EsV0FBVyxTQUFTLEVBQUUsVUFBVTtBQUNoQyxXQUFXLFNBQVMsRUFBRSxjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix3QkFBd0I7QUFDM0c7QUFDQTtBQUNBLGFBQWEsVUFBVSxRQUFRLFlBQVk7QUFDM0MsYUFBYSxTQUFTLFFBQVEsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLHFCQUFxQixXQUFXLGdCQUFnQix1QkFBdUIsZ0JBQWdCO0FBQ3ZIO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBb0I7QUFDOUQ7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLLFFBQVEsU0FBUyxVQUFVLGNBQWM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLEdBQUcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0EsZ0JBQWdCLHdEQUF3RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0R0FBNEcsYUFBYSxZQUFZLGVBQWU7QUFDcEo7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLDZCQUE2QjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCLElBQUk7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxhQUFhLE1BQXFDO0FBQ2xEO0FBQ0EsRUFBRSxDQUFRO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVUsWUFBWSxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsZ0NBQWdDLE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksR0FBRywwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxHQUFHLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUMsK0JBQStCLENBQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7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QTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUSxvQkFBb0IsdUJBQXVCLE1BQU0sSUFBSSxRQUFRLFFBQVEscUJBQXFCLHNCQUFzQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUssRUFHTjtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQW9FRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz85NzBiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi45LjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL2R1cGUtZGV0ZWN0aW9uLnRzXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge307XG52YXIgY3Jvc3NMaW5rZWREb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvY3Jvc3MtbGlua2VkXCI7XG52YXIgZHVwZXNEb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvZHVwZXNcIjtcbnZhciBTUEFDRSA9IFwiIFwiO1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVjdER1cGVzKHBrZ05hbWUsIHBrZ1ZlcnNpb24sIHBrZ0Zvcm1hdCkge1xuICBjb25zdCBwa2dJZCA9IFN5bWJvbC5mb3IocGtnTmFtZSk7XG4gIGNvbnN0IHBrZ0J1aWxkSW5mbyA9IHBrZ0Zvcm1hdCA/IGAke3BrZ1ZlcnNpb24gfHwgXCJkZXZcIn0gKCR7cGtnRm9ybWF0fSlgIDogcGtnVmVyc2lvbiB8fCBcImRldlwiO1xuICBpZiAoIWdbcGtnSWRdKSB7XG4gICAgZ1twa2dJZF0gPSBwa2dCdWlsZEluZm87XG4gIH0gZWxzZSBpZiAoZ1twa2dJZF0gPT09IHBrZ0J1aWxkSW5mbykge1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBNdWx0aXBsZSBjb3BpZXMgb2YgTGl2ZWJsb2NrcyBhcmUgYmVpbmcgbG9hZGVkIGluIHlvdXIgcHJvamVjdC4gVGhpcyB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7ZHVwZXNEb2NzICsgU1BBQ0V9YCxcbiAgICAgIFwiXCIsXG4gICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtnW3BrZ0lkXX0gKGFscmVhZHkgbG9hZGVkKWAsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7cGtnQnVpbGRJbmZvfSAodHJ5aW5nIHRvIGxvYWQgdGhpcyBub3cpYFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBlcnJvcihtc2cpO1xuICB9XG4gIGlmIChwa2dWZXJzaW9uICYmIFBLR19WRVJTSU9OICYmIHBrZ1ZlcnNpb24gIT09IFBLR19WRVJTSU9OKSB7XG4gICAgZXJyb3IoXG4gICAgICBbXG4gICAgICAgIGBDcm9zcy1saW5rZWQgdmVyc2lvbnMgb2YgTGl2ZWJsb2NrcyBmb3VuZCwgd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2Nyb3NzTGlua2VkRG9jcyArIFNQQUNFfWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgICBgLSAke1BLR19OQU1FfSBpcyBhdCAke1BLR19WRVJTSU9OfWAsXG4gICAgICAgIGAtICR7cGtnTmFtZX0gaXMgYXQgJHtwa2dWZXJzaW9ufWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQWx3YXlzIHVwZ3JhZGUgYWxsIExpdmVibG9ja3MgcGFja2FnZXMgdG8gdGhlIHNhbWUgdmVyc2lvbiBudW1iZXIuXCJcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdO1xufVxuZnVuY3Rpb24gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCkge1xuICBjb25zdCBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vbmV0aW1lT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29uZXRpbWVPYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIF9mb3JjZUNsZWFyKCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb25ldGltZU9ic2VydmVycy5zaXplICsgX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIF9mb3JjZUNsZWFyLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBwYXVzZSxcbiAgICB1bnBhdXNlLFxuICAgIC8vIFB1YmxpY2x5IGV4cG9zYWJsZSBzdWJzY3JpcHRpb24gQVBJXG4gICAgb2JzZXJ2YWJsZToge1xuICAgICAgc3Vic2NyaWJlLFxuICAgICAgc3Vic2NyaWJlT25jZSxcbiAgICAgIHdhaXRVbnRpbFxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mYW5jeS1jb25zb2xlLnRzXG52YXIgZmFuY3lfY29uc29sZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYW5jeV9jb25zb2xlX2V4cG9ydHMsIHtcbiAgZXJyb3I6ICgpID0+IGVycm9yMixcbiAgZXJyb3JXaXRoVGl0bGU6ICgpID0+IGVycm9yV2l0aFRpdGxlLFxuICB3YXJuOiAoKSA9PiB3YXJuLFxuICB3YXJuV2l0aFRpdGxlOiAoKSA9PiB3YXJuV2l0aFRpdGxlXG59KTtcbnZhciBiYWRnZSA9IFwiYmFja2dyb3VuZDojMGUwZDEyO2JvcmRlci1yYWRpdXM6OTk5OXB4O2NvbG9yOiNmZmY7cGFkZGluZzozcHggN3B4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NjAwO1wiO1xudmFyIGJvbGQgPSBcImZvbnQtd2VpZ2h0OjYwMFwiO1xuZnVuY3Rpb24gd3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcIiVjTGl2ZWJsb2Nrc1wiLCBiYWRnZSwgbWVzc2FnZSwgLi4uYXJncylcbiAgKTtcbn1cbnZhciB3YXJuID0gd3JhcChcIndhcm5cIik7XG52YXIgZXJyb3IyID0gd3JhcChcImVycm9yXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhUaXRsZShtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKHRpdGxlLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXG4gICAgICBgJWNMaXZlYmxvY2tzJWMgJHt0aXRsZX1gLFxuICAgICAgYmFkZ2UsXG4gICAgICBib2xkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApXG4gICk7XG59XG52YXIgd2FybldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJ3YXJuXCIpO1xudmFyIGVycm9yV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcImVycm9yXCIpO1xuXG4vLyBzcmMvbGliL2ZzbS50c1xuZnVuY3Rpb24gZGlzdGFuY2Uoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgaWYgKHN0YXRlMSA9PT0gc3RhdGUyKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBjb25zdCBjaHVua3MxID0gc3RhdGUxLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgY2h1bmtzMiA9IHN0YXRlMi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG1pbkxlbiA9IE1hdGgubWluKGNodW5rczEubGVuZ3RoLCBjaHVua3MyLmxlbmd0aCk7XG4gIGxldCBzaGFyZWQgPSAwO1xuICBmb3IgKDsgc2hhcmVkIDwgbWluTGVuOyBzaGFyZWQrKykge1xuICAgIGlmIChjaHVua3MxW3NoYXJlZF0gIT09IGNodW5rczJbc2hhcmVkXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwID0gY2h1bmtzMS5sZW5ndGggLSBzaGFyZWQ7XG4gIGNvbnN0IGRvd24gPSBjaHVua3MyLmxlbmd0aCAtIHNoYXJlZDtcbiAgcmV0dXJuIFt1cCwgZG93bl07XG59XG5mdW5jdGlvbiBwYXR0ZXJucyh0YXJnZXRTdGF0ZSwgbGV2ZWxzKSB7XG4gIGNvbnN0IHBhcnRzID0gdGFyZ2V0U3RhdGUuc3BsaXQoXCIuXCIpO1xuICBpZiAobGV2ZWxzIDwgMSB8fCBsZXZlbHMgPiBwYXJ0cy5sZW5ndGggKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgbGV2ZWxzXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobGV2ZWxzID4gcGFydHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goXCIqXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSBsZXZlbHMgKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbGljZSA9IHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5qb2luKFwiLlwiKSArIFwiLipcIik7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKHRhcmdldFN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBTYWZlQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmN1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcGF0Y2hpbmcgb2YgdGhlIGNvbnRleHQsIGJ5XG4gICAqIGNhbGxpbmcgYGNvbnRleHQucGF0Y2goKWAuIFBhdGNoaW5nIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoaXMgd2luZG93LlxuICAgKi9cbiAgYWxsb3dQYXRjaGluZyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXRjaGFibGVDb250ZXh0ID0ge1xuICAgICAgLi4udGhpcy5jdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLmN1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLmN1cnIsIHBhdGNoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMocGF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm8gbG9uZ2VyIHBhdGNoIHN0YWxlIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgbmV4dElkID0gMTtcbnZhciBGU00gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RhdGVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0ZXMgZGVmaW5lZCB5ZXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIG1hY2hpbmUgYnkgZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgdGhpcy5lbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAxIC8qIFNUQVJURUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdG9wIGEgc3RhdGUgbWFjaGluZSB0aGF0IGhhc24ndCBzdGFydGVkIHlldFwiKTtcbiAgICB9XG4gICAgdGhpcy5leGl0KG51bGwpO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQrKztcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLmtub3duRXZlbnRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuZXZlbnRIdWIgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbFRyYW5zaXRpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRFbnRlclN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbiBleHBsaWNpdCBmaW5pdGUgc3RhdGUgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAqL1xuICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX09LXCIsIGRhdGEgfSwgb25PSyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBPbiBFcnJvclxuICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuIFRoZSBzdGF0ZSBuYW1lLCBvciBzdGF0ZSBncm91cCBwYXR0ZXJuIG5hbWUuXG4gICAqIEBwYXJhbSBhZnRlciAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGlzIHRha2VuLCB0aGUgdGltZXIgd2lsbCBnZXQgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIG1hcEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFpclsxXTtcbiAgICByZXN1bHRba2V5XSA9IG1hcEZuKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gd2FpdChtaWxsaXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtaWxsaXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9uU3VjY2VzcyhmYWN0b3J5Rm4pIHtcbiAgbGV0IGNhY2hlZCA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgY2FjaGVkID0gZmFjdG9yeUZuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYWNoZWQgPSBudWxsO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL1NlcnZlck1zZy50c1xudmFyIFNlcnZlck1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNc2dDb2RlMikgPT4ge1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfSk9JTkVEXCJdID0gMTAxXSA9IFwiVVNFUl9KT0lORURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0xFRlRcIl0gPSAxMDJdID0gXCJVU0VSX0xFRlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJCUk9BRENBU1RFRF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVEVEX0VWRU5UXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUk9PTV9TVEFURVwiXSA9IDEwNF0gPSBcIlJPT01fU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIl0gPSAyMDBdID0gXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUkVKRUNUX1NUT1JBR0VfT1BcIl0gPSAyOTldID0gXCJSRUpFQ1RfU1RPUkFHRV9PUFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAwXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfQ1JFQVRFRFwiXSA9IDQwMF0gPSBcIlRIUkVBRF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0RFTEVURURcIl0gPSA0MDddID0gXCJUSFJFQURfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCJdID0gNDAxXSA9IFwiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfVVBEQVRFRFwiXSA9IDQwOF0gPSBcIlRIUkVBRF9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9DUkVBVEVEXCJdID0gNDAyXSA9IFwiQ09NTUVOVF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9FRElURURcIl0gPSA0MDNdID0gXCJDT01NRU5UX0VESVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfREVMRVRFRFwiXSA9IDQwNF0gPSBcIkNPTU1FTlRfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIl0gPSA0MDVdID0gXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCJdID0gNDA2XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCI7XG4gIHJldHVybiBTZXJ2ZXJNc2dDb2RlMjtcbn0pKFNlcnZlck1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvSVdlYlNvY2tldC50c1xudmFyIFdlYnNvY2tldENsb3NlQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChXZWJzb2NrZXRDbG9zZUNvZGVzMikgPT4ge1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX05PUk1BTFwiXSA9IDFlM10gPSBcIkNMT1NFX05PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX0FCTk9STUFMXCJdID0gMTAwNl0gPSBcIkNMT1NFX0FCTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVU5FWFBFQ1RFRF9DT05ESVRJT05cIl0gPSAxMDExXSA9IFwiVU5FWFBFQ1RFRF9DT05ESVRJT05cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUUllfQUdBSU5fTEFURVJcIl0gPSAxMDEzXSA9IFwiVFJZX0FHQUlOX0xBVEVSXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiXSA9IDRlM10gPSBcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJOT1RfQUxMT1dFRFwiXSA9IDQwMDFdID0gXCJOT1RfQUxMT1dFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIl0gPSA0MDAyXSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiXSA9IDQwMDNdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiXSA9IDQwMDRdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiXSA9IDQwMDVdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJST09NX0lEX1VQREFURURcIl0gPSA0MDA2XSA9IFwiUk9PTV9JRF9VUERBVEVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiS0lDS0VEXCJdID0gNDEwMF0gPSBcIktJQ0tFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRPS0VOX0VYUElSRURcIl0gPSA0MTA5XSA9IFwiVE9LRU5fRVhQSVJFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX1dJVEhPVVRfUkVUUllcIl0gPSA0OTk5XSA9IFwiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiO1xuICByZXR1cm4gV2Vic29ja2V0Q2xvc2VDb2RlczI7XG59KShXZWJzb2NrZXRDbG9zZUNvZGVzIHx8IHt9KTtcbmZ1bmN0aW9uIHNob3VsZERpc2Nvbm5lY3QoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gNDk5OSAvKiBDTE9TRV9XSVRIT1VUX1JFVFJZICovIHx8IGNvZGUgPj0gNGUzICYmIGNvZGUgPCA0MTAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNDEwMCAmJiBjb2RlIDwgNDIwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDEzIC8qIFRSWV9BR0FJTl9MQVRFUiAqLyB8fCBjb2RlID49IDQyMDAgJiYgY29kZSA8IDQzMDA7XG59XG5cbi8vIHNyYy9jb25uZWN0aW9uLnRzXG5mdW5jdGlvbiBpc0lkbGUoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXR1cyA9PT0gXCJkaXNjb25uZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXRlID0gbWFjaGluZS5jdXJyZW50U3RhdGU7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiQG9rLmNvbm5lY3RlZFwiOlxuICAgIGNhc2UgXCJAb2suYXdhaXRpbmctcG9uZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gICAgY2FzZSBcIkBpZGxlLmluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICBjYXNlIFwiQGF1dGguYnVzeVwiOlxuICAgIGNhc2UgXCJAYXV0aC5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiOlxuICAgIGNhc2UgXCJAaWRsZS56b21iaWVcIjpcbiAgICAgIHJldHVybiBtYWNoaW5lLmNvbnRleHQuc3VjY2Vzc0NvdW50ID4gMCA/IFwicmVjb25uZWN0aW5nXCIgOiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiQGlkbGUuZmFpbGVkXCI6XG4gICAgICByZXR1cm4gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICBjb25zdCBkZXRhaWxzID0gW2Bjb2RlOiAke2V2ZW50LmNvZGV9YF07XG4gIGlmIChldmVudC5yZWFzb24pIHtcbiAgICBkZXRhaWxzLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gIH1cbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoJHtkZXRhaWxzLmpvaW4oXCIsIFwiKX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgb25NZXNzYWdlLnBhdXNlKCk7XG4gIGNvbnN0IG9uTGl2ZWJsb2Nrc0Vycm9yID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGZpcmVFcnJvckV2ZW50KGVycm1zZywgZXJyY29kZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKGVycm1zZywgZXJyY29kZSk7XG4gICAgICBvbkxpdmVibG9ja3NFcnJvci5ub3RpZnkoZXJyKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0ge1xuICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICBhdXRoVmFsdWU6IG51bGwsXG4gICAgc29ja2V0OiBudWxsLFxuICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgfTtcbiAgY29uc3QgbWFjaGluZSA9IG5ldyBGU00oaW5pdGlhbENvbnRleHQpLmFkZFN0YXRlKFwiQGlkbGUuaW5pdGlhbFwiKS5hZGRTdGF0ZShcIkBpZGxlLmZhaWxlZFwiKS5hZGRTdGF0ZShcIkBpZGxlLnpvbWJpZVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJ1c3lcIikuYWRkU3RhdGUoXCJAYXV0aC5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYnVzeVwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAb2suY29ubmVjdGVkXCIpLmFkZFN0YXRlKFwiQG9rLmF3YWl0aW5nLXBvbmdcIik7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCIqXCIsIHtcbiAgICBSRUNPTk5FQ1Q6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgcmVzZXRTdWNjZXNzQ291bnRdXG4gICAgfSxcbiAgICBESVNDT05ORUNUOiBcIkBpZGxlLmluaXRpYWxcIlxuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQGlkbGUuKlwiLCByZXNldFN1Y2Nlc3NDb3VudCkuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS4qXCIsIHtcbiAgICBDT05ORUNUOiAoXywgY3R4KSA9PiAoXG4gICAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlIGEga25vd24gYXV0aFZhbHVlLCB0cnkgdG8gcmVjb25uZWN0IHRvIHRoZSBzb2NrZXQgZGlyZWN0bHksXG4gICAgICAvLyBvdGhlcndpc2UsIHRyeSB0byBvYnRhaW4gYSBuZXcgYXV0aFZhbHVlXG4gICAgICBjdHguYXV0aFZhbHVlICE9PSBudWxsID8gXCJAY29ubmVjdGluZy5idXN5XCIgOiBcIkBhdXRoLmJ1c3lcIlxuICAgIClcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAYXV0aC5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBhdXRoLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBhdXRoLmJ1c3lcIixcbiAgICAoKSA9PiB3aXRoVGltZW91dChcbiAgICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKSxcbiAgICAgIEFVVEhfVElNRU9VVCxcbiAgICAgIFwiVGltZWQgb3V0IGR1cmluZyBhdXRoXCJcbiAgICApLFxuICAgIC8vIE9uIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIGF1dGhWYWx1ZTogb2tFdmVudC5kYXRhXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIEF1dGggZmFpbGVkXG4gICAgKGZhaWxlZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheSxcbiAgICAgICAgICBsb2coXG4gICAgICAgICAgICAyIC8qIEVSUk9SICovLFxuICAgICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlIDogU3RyaW5nKGZhaWxlZEV2ZW50LnJlYXNvbil9YFxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IG9uU29ja2V0RXJyb3IgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0VSUk9SXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldENsb3NlID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRNZXNzYWdlID0gKGV2ZW50KSA9PiBldmVudC5kYXRhID09PSBcInBvbmdcIiA/IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUE9OR1wiIH0pIDogb25NZXNzYWdlLm5vdGlmeShldmVudCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duU29ja2V0KHNvY2tldCkge1xuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBjb25uZWN0aW5nLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vXG4gICAgLy8gVXNlIHRoZSBcImNyZWF0ZVNvY2tldFwiIGRlbGVnYXRlIGZ1bmN0aW9uIChwcm92aWRlZCB0byB0aGVcbiAgICAvLyBNYW5hZ2VkU29ja2V0KSB0byBjcmVhdGUgdGhlIGFjdHVhbCBXZWJTb2NrZXQgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICAvLyBUaGVuLCBzZXQgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLCBhbmQgd2FpdCBmb3IgdGhlXG4gICAgLy8gXCJvcGVuXCIgZXZlbnQgdG8gb2NjdXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBcIm9wZW5cIiBldmVudCBoYXBwZW5zLCB3ZSdyZSByZWFkeSB0byB0cmFuc2l0aW9uIHRvIHRoZVxuICAgIC8vIE9LIHN0YXRlLiBUaGlzIGlzIGRvbmUgYnkgcmVzb2x2aW5nIHRoZSBQcm9taXNlLlxuICAgIC8vXG4gICAgYXN5bmMgKGN0eCwgc2lnbmFsKSA9PiB7XG4gICAgICBsZXQgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IG51bGw7XG4gICAgICBsZXQgdW5jb25maXJtZWRTb2NrZXQgPSBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdCQgPSBuZXcgUHJvbWlzZShcbiAgICAgICAgKHJlc29sdmUsIHJlaikgPT4ge1xuICAgICAgICAgIGlmIChjdHguYXV0aFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIGF1dGhWYWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc29ja2V0ID0gZGVsZWdhdGVzLmNyZWF0ZVNvY2tldChjdHguYXV0aFZhbHVlKTtcbiAgICAgICAgICB1bmNvbmZpcm1lZFNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgICBmdW5jdGlvbiByZWplY3QoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgW2FjdG9yJCwgZGlkUmVjZWl2ZUFjdG9yXSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gd2FpdEZvckFjdG9ySWQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlck1zZyA9IHRyeVBhcnNlSnNvbihldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJNc2c/LnR5cGUgPT09IDEwNCAvKiBST09NX1NUQVRFICovKSB7XG4gICAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdm9pZCBhY3RvciQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoW3NvY2tldCwgdW5zdWJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHdpdGhUaW1lb3V0KFxuICAgICAgICBjb25uZWN0JCxcbiAgICAgICAgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCxcbiAgICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIHdlYnNvY2tldCBjb25uZWN0aW9uXCJcbiAgICAgICkudGhlbihcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFydCAzOlxuICAgICAgICAvLyBCeSBub3csIG91ciBcIm9wZW5cIiBldmVudCBoYXMgZmlyZWQsIGFuZCB0aGUgcHJvbWlzZSBoYXMgYmVlblxuICAgICAgICAvLyByZXNvbHZlZC4gVHdvIHBvc3NpYmxlIHNjZW5hcmlvczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gVGhlIGhhcHB5IHBhdGguIE1vc3QgbGlrZWx5LlxuICAgICAgICAvLyAyLiBVaC1vaC4gQSBwcmVtYXR1cmUgY2xvc2UvZXJyb3IgZXZlbnQgaGFzIGJlZW4gb2JzZXJ2ZWQuIExldCdzXG4gICAgICAgIC8vICAgIHJlamVjdCB0aGUgcHJvbWlzZSBhZnRlciBhbGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFueSBjbG9zZS9lcnJvciBldmVudCB0aGF0IHdpbGwgZ2V0IHNjaGVkdWxlZCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIG9ud2FyZHMsIHdpbGwgYmUgY2F1Z2h0IGluIHRoZSBPSyBzdGF0ZSwgYW5kIGRlYWx0IHdpdGhcbiAgICAgICAgLy8gYWNjb3JkaW5nbHkuXG4gICAgICAgIC8vXG4gICAgICAgIChbc29ja2V0LCB1bnN1Yl0pID0+IHtcbiAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJvcnRlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQpIHtcbiAgICAgICAgICAgIHRocm93IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQodW5jb25maXJtZWRTb2NrZXQpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBPbmx5IHRyYW5zaXRpb24gdG8gT0sgc3RhdGUgYWZ0ZXIgYSBzdWNjZXNzZnVsbHkgb3BlbmVkIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQG9rLmNvbm5lY3RlZFwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBzb2NrZXQ6IG9rRXZlbnQuZGF0YSxcbiAgICAgICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkXG4gICAgKGZhaWx1cmUpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGZhaWx1cmUucmVhc29uO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xvc2VFdmVudChlcnIpKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksXG4gICAgICAgICAgICAgIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycilcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5yZWFzb24pLFxuICAgICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIucmVhc29uLCBlcnIuY29kZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKV1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBzZW5kSGVhcnRiZWF0ID0ge1xuICAgIHRhcmdldDogXCJAb2suYXdhaXRpbmctcG9uZ1wiLFxuICAgIGVmZmVjdDogKGN0eCkgPT4ge1xuICAgICAgY3R4LnNvY2tldD8uc2VuZChcInBpbmdcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYXliZUhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCBjYW5ab21iaWUgPSBkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIiAmJiBkZWxlZ2F0ZXMuY2FuWm9tYmllKCk7XG4gICAgcmV0dXJuIGNhblpvbWJpZSA/IFwiQGlkbGUuem9tYmllXCIgOiBzZW5kSGVhcnRiZWF0O1xuICB9O1xuICBtYWNoaW5lLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5jb25uZWN0ZWRcIiwgSEVBUlRCRUFUX0lOVEVSVkFMLCBtYXliZUhlYXJ0YmVhdCkuYWRkVHJhbnNpdGlvbnMoXCJAb2suY29ubmVjdGVkXCIsIHtcbiAgICBOQVZJR0FUT1JfT0ZGTElORTogbWF5YmVIZWFydGJlYXQsXG4gICAgLy8gRG9uJ3QgdGFrZSB0aGUgYnJvd3NlcidzIHdvcmQgZm9yIGl0IHdoZW4gaXQgc2F5cyBpdCdzIG9mZmxpbmUuIERvIGEgcGluZy9wb25nIHRvIG1ha2Ugc3VyZS5cbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBzZW5kSGVhcnRiZWF0XG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuem9tYmllXCIsIHtcbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIlxuICAgIC8vIFdoZW4gaW4gem9tYmllIHN0YXRlLCB0aGUgY2xpZW50IHdpbGwgdHJ5IHRvIHdha2UgdXAgYXV0b21hdGljYWxseSB3aGVuIHRoZSB3aW5kb3cgcmVnYWlucyBmb2N1c1xuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQG9rLipcIiwgKGN0eCkgPT4ge1xuICAgIGN0eC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogY3R4LnN1Y2Nlc3NDb3VudCArIDEgfSk7XG4gICAgY29uc3QgdGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAvLyBPbiB0aGUgbmV4dCB0aWNrLCBzdGFydCBkZWxpdmVyaW5nIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYWxyZWFkeVxuICAgICAgLy8gYmVlbiByZWNlaXZlZCwgYW5kIGNvbnRpbnVlIHN5bmNocm9ub3VzIGRlbGl2ZXJ5IG9mIGFsbCBmdXR1cmVcbiAgICAgIC8vIGluY29taW5nIG1lc3NhZ2VzLlxuICAgICAgb25NZXNzYWdlLnVucGF1c2UsXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4gKGN0eDIpID0+IHtcbiAgICAgIHRlYXJkb3duU29ja2V0KGN0eDIuc29ja2V0KTtcbiAgICAgIGN0eDIucGF0Y2goeyBzb2NrZXQ6IG51bGwgfSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG4gICAgICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgICB9O1xuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5hd2FpdGluZy1wb25nXCIsIHsgUE9ORzogXCJAb2suY29ubmVjdGVkXCIgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgUE9OR19USU1FT1VULCB7XG4gICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvLyBMb2cgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzIGFuZCBkcm9wIHRoZSBjdXJyZW50IG9wZW4gc29ja2V0XG4gICAgZWZmZWN0OiBsb2coXG4gICAgICAxIC8qIFdBUk4gKi8sXG4gICAgICBcIlJlY2VpdmVkIG5vIHBvbmcgZnJvbSBzZXJ2ZXIsIGFzc3VtZSBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MuXCJcbiAgICApXG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLipcIiwge1xuICAgIC8vIFdoZW4gYSBzb2NrZXQgcmVjZWl2ZXMgYW4gZXJyb3IsIHRoaXMgY2FuIGNhdXNlIHRoZSBjbG9zaW5nIG9mIHRoZVxuICAgIC8vIHNvY2tldCwgb3Igbm90LiBTbyBhbHdheXMgY2hlY2sgdG8gc2VlIGlmIHRoZSBzb2NrZXQgaXMgc3RpbGwgT1BFTiBvclxuICAgIC8vIG5vdC4gV2hlbiBzdGlsbCBPUEVOLCBkb24ndCB0cmFuc2l0aW9uLlxuICAgIEVYUExJQ0lUX1NPQ0tFVF9FUlJPUjogKF8sIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChjb250ZXh0LnNvY2tldD8ucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogaW5jcmVhc2VCYWNrb2ZmRGVsYXlcbiAgICAgIH07XG4gICAgfSxcbiAgICBFWFBMSUNJVF9TT0NLRVRfQ0xPU0U6IChlKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nUGVybWFuZW50Q2xvc2UsXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlLmV2ZW50LnJlYXNvbiwgZS5ldmVudC5jb2RlKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICBpZiAoZS5ldmVudC5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICAgIGNvbnN0IHJvb3QgPSB3aW4gPz8gZG9jO1xuICAgIG1hY2hpbmUub25FbnRlcihcIipcIiwgKGN0eCkgPT4ge1xuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrT2ZmbGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT0ZGTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrQmFja09ubGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT05MSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIldJTkRPV19HT1RfRk9DVVNcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgIHJvb3Q/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByb290Py5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KGN0eC5zb2NrZXQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBjbGVhbnVwcyA9IFtdO1xuICBjb25zdCB7IHN0YXR1c0RpZENoYW5nZSwgZGlkQ29ubmVjdCwgZGlkRGlzY29ubmVjdCwgdW5zdWJzY3JpYmUgfSA9IGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKTtcbiAgY2xlYW51cHMucHVzaCh1bnN1YnNjcmliZSk7XG4gIGlmIChvcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZykge1xuICAgIGNsZWFudXBzLnB1c2goZW5hYmxlVHJhY2luZyhtYWNoaW5lKSk7XG4gIH1cbiAgbWFjaGluZS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIG1hY2hpbmUsXG4gICAgY2xlYW51cHMsXG4gICAgLy8gT2JzZXJ2YWJsZSBldmVudHMgdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhpcyBtYWNoaW5lXG4gICAgZXZlbnRzOiB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2UsXG4gICAgICBkaWRDb25uZWN0LFxuICAgICAgZGlkRGlzY29ubmVjdCxcbiAgICAgIG9uTWVzc2FnZTogb25NZXNzYWdlLm9ic2VydmFibGUsXG4gICAgICBvbkxpdmVibG9ja3NFcnJvcjogb25MaXZlYmxvY2tzRXJyb3Iub2JzZXJ2YWJsZVxuICAgIH1cbiAgfTtcbn1cbnZhciBNYW5hZ2VkU29ja2V0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy5tYWNoaW5lID0gbWFjaGluZTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmNsZWFudXBzID0gY2xlYW51cHM7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMubWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNoaW5lLmNvbnRleHQuYXV0aFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRyeSB0byBjb25uZWN0IHRvIGEgV2ViU29ja2V0LiBUaGlzIG9ubHkgaGFzIGFuIGVmZmVjdFxuICAgKiBpZiB0aGUgbWFjaGluZSBpcyBpZGxlIGF0IHRoZSBtb21lbnQsIG90aGVyd2lzZSB0aGlzIGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJESVNDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzdG9wIHRoZSBtYWNoaW5lIGFuZCBydW4gbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLiBBZnRlclxuICAgKiBjYWxsaW5nIGRlc3Ryb3koKSwgeW91IGNhbiBubyBsb25nZXIgdXNlIHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpcyBiZWZvcmVcbiAgICogbGV0dGluZyB0aGUgaW5zdGFuY2UgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy5jbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubWFjaGluZS5jb250ZXh0Py5zb2NrZXQ7XG4gICAgaWYgKHNvY2tldCA9PT0gbnVsbCkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBub3QgY29ubmVjdGVkIHlldFwiLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IFdlYlNvY2tldCBubyBsb25nZXIgb3BlblwiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOT1RFOiBVc2VkIGJ5IHRoZSBFMkUgYXBwIG9ubHksIHRvIHNpbXVsYXRlIGV4cGxpY2l0IGV2ZW50cy5cbiAgICogTm90IGlkZWFsIHRvIGtlZXAgZXhwb3NlZCA6KFxuICAgKi9cbiAgX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0aW9uLmNhbGxiYWNrKG9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIiwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gyLCBlbmRwb2ludCwgYm9keSkge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaDIoZW5kcG9pbnQsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICB9KTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICBjb25zdCByZWFzb24gPSBgJHsoYXdhaXQgcmVzLnRleHQoKSkudHJpbSgpIHx8IFwicmVhc29uIG5vdCBwcm92aWRlZCBpbiBhdXRoIHJlc3BvbnNlXCJ9ICgke3Jlcy5zdGF0dXN9IHJldHVybmVkIGJ5IFBPU1QgJHtlbmRwb2ludH0pYDtcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxIHx8IHJlcy5zdGF0dXMgPT09IDQwMykge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhgVW5hdXRob3JpemVkOiAke3JlYXNvbn1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXV0aGVudGljYXRlOiAke3JlYXNvbn1gKTtcbiAgICB9XG4gIH1cbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIi4gJHtTdHJpbmcoXG4gICAgICAgIGVyXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSB8fCB0eXBlb2YgZGF0YS50b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugb2YgdGhlIGZvcm0gXFxgeyB0b2tlbjogXCIuLi5cIiB9XFxgIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGRhdGFcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgY29uc3QgeyB0b2tlbiB9ID0gZGF0YTtcbiAgcmV0dXJuIHsgdG9rZW4gfTtcbn1cblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxpdmVibG9ja3MuaW9cIjtcblxuLy8gc3JjL2ludGVybmFsLnRzXG52YXIga0ludGVybmFsID0gU3ltYm9sKCk7XG5cbi8vIHNyYy9kZXZ0b29scy9icmlkZ2UudHNcbnZhciBfYnJpZGdlQWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBhY3RpdmF0ZUJyaWRnZShhbGxvd2VkKSB7XG4gIF9icmlkZ2VBY3RpdmUgPSBhbGxvd2VkO1xufVxuZnVuY3Rpb24gc2VuZFRvUGFuZWwobWVzc2FnZSwgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZnVsbE1zZyA9IHtcbiAgICAuLi5tZXNzYWdlLFxuICAgIHNvdXJjZTogXCJsaXZlYmxvY2tzLWRldnRvb2xzLWNsaWVudFwiXG4gIH07XG4gIGlmICghKG9wdGlvbnM/LmZvcmNlIHx8IF9icmlkZ2VBY3RpdmUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5wb3N0TWVzc2FnZShmdWxsTXNnLCBcIipcIik7XG59XG52YXIgZXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2ZW50LmRhdGE/LnNvdXJjZSA9PT0gXCJsaXZlYmxvY2tzLWRldnRvb2xzLXBhbmVsXCIpIHtcbiAgICAgIGV2ZW50U291cmNlLm5vdGlmeShldmVudC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgIH1cbiAgfSk7XG59XG52YXIgb25NZXNzYWdlRnJvbVBhbmVsID0gZXZlbnRTb3VyY2Uub2JzZXJ2YWJsZTtcblxuLy8gc3JjL2RldnRvb2xzL2luZGV4LnRzXG52YXIgVkVSU0lPTiA9IFBLR19WRVJTSU9OIHx8IFwiZGV2XCI7XG52YXIgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwRGV2VG9vbHMoZ2V0QWxsUm9vbXMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChfZGV2dG9vbHNTZXR1cEhhc1J1bikge1xuICAgIHJldHVybjtcbiAgfVxuICBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IHRydWU7XG4gIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgY2FzZSBcImNvbm5lY3RcIjoge1xuICAgICAgICBhY3RpdmF0ZUJyaWRnZSh0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCByb29tSWQgb2YgZ2V0QWxsUm9vbXMoKSkge1xuICAgICAgICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgICAgICAgIG1zZzogXCJyb29tOjphdmFpbGFibGVcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IFZFUlNJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJ3YWtlLXVwLWRldnRvb2xzXCIgfSwgeyBmb3JjZTogdHJ1ZSB9KTtcbn1cbnZhciB1bnN1YnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wU3luY1N0cmVhbShyb29tSWQpIHtcbiAgY29uc3QgdW5zdWJzID0gdW5zdWJzQnlSb29tSWQuZ2V0KHJvb21JZCkgPz8gW107XG4gIHVuc3Vic0J5Um9vbUlkLmRlbGV0ZShyb29tSWQpO1xuICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgIHVuc3ViKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0U3luY1N0cmVhbShyb29tKSB7XG4gIHN0b3BTeW5jU3RyZWFtKHJvb20uaWQpO1xuICBmdWxsU3luYyhyb29tKTtcbiAgdW5zdWJzQnlSb29tSWQuc2V0KHJvb20uaWQsIFtcbiAgICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkpLFxuICAgIC8vIFdoZW4gc3RvcmFnZSBpbml0aWFsaXplcywgc2VuZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHN0b3JhZ2UgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHN0b3JhZ2Ugcm9vdFxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBcIm1lXCIgb3IgXCJvdGhlcnNcIiB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgdmFsdWVzIGFjY29yZGluZ2x5XG4gICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNNZShyb29tKSksXG4gICAgcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY090aGVycyhyb29tKSksXG4gICAgLy8gQW55IHRpbWUgeWRvYyBpcyB1cGRhdGVkLCBmb3J3YXJkIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgodXBkYXRlKSA9PiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpKSxcbiAgICAvLyBBbnkgdGltZSBhIGN1c3RvbSByb29tIGV2ZW50IGlzIHJlY2VpdmVkLCBmb3J3YXJkIGl0XG4gICAgcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50RGF0YSkgPT4gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSlcbiAgICApXG4gIF0pO1xufVxuZnVuY3Rpb24gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6eWRvY1wiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICB1cGRhdGVcbiAgfSk7XG59XG52YXIgbG9hZGVkQXQgPSBEYXRlLm5vdygpO1xudmFyIGV2ZW50Q291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGBldmVudC0ke2xvYWRlZEF0fS0ke2V2ZW50Q291bnRlcisrfWA7XG59XG5mdW5jdGlvbiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6ZXZlbnRzOjpjdXN0b20tZXZlbnRcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXZlbnRcIixcbiAgICAgIGlkOiBuZXh0RXZlbnRJZCgpLFxuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBjb25uZWN0aW9uSWQ6IGV2ZW50RGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICBwYXlsb2FkOiBldmVudERhdGEuZXZlbnRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBpZiAocm9vdCkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBzdG9yYWdlOiByb290LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNNZShyb29tKSB7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG1lKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG1lXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pIHtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICBpZiAob3RoZXJzKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG90aGVyc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmdWxsU3luYyhyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgcm9vbS5mZXRjaFlEb2MoXCJcIik7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6ZnVsbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKCksXG4gICAgc3RvcmFnZTogcm9vdD8udG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZCA/PyBudWxsLFxuICAgIG1lLFxuICAgIG90aGVyc1xuICB9KTtcbn1cbnZhciByb29tQ2hhbm5lbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSByb29tQ2hhbm5lbExpc3RlbmVycy5nZXQocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZGVsZXRlKHJvb21JZCk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmtEZXZUb29scyhyb29tSWQsIHJvb20pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLCByb29tSWQsIGNsaWVudFZlcnNpb246IFZFUlNJT04gfSk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLnNldChcbiAgICByb29tSWQsXG4gICAgLy8gUmV0dXJucyB0aGUgdW5zdWJzY3JpYmUgY2FsbGJhY2ssIHRoYXQgd2Ugc3RvcmUgaW4gdGhlXG4gICAgLy8gcm9vbUNoYW5uZWxMaXN0ZW5lcnMgcmVnaXN0cnlcbiAgICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgICBjYXNlIFwicm9vbTo6c3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdGFydFN5bmNTdHJlYW0ocm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyb29tOjp1bnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdW5saW5rRGV2VG9vbHMocm9vbUlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnVuYXZhaWxhYmxlXCIsXG4gICAgcm9vbUlkXG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncyk7XG4gIH1cbiAgY29uc3Qgc29ydGVkT2JqZWN0ID0gT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCkucmVkdWNlKFxuICAgIChzb3J0ZWRPYmplY3QyLCBrZXkpID0+IHtcbiAgICAgIHNvcnRlZE9iamVjdDJba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIHNvcnRlZE9iamVjdDI7XG4gICAgfSxcbiAgICB7fVxuICApO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc29ydGVkT2JqZWN0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL2xpYi9iYXRjaC50c1xudmFyIERFRkFVTFRfU0laRSA9IDUwO1xudmFyIEJhdGNoQ2FsbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IFByb21pc2Vfd2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgfVxufTtcbnZhciBCYXRjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemUgPz8gREVGQVVMVF9TSVpFO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG4gIGNsZWFyRGVsYXlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLmRlbGF5VGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNjaGVkdWxlKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gdGhpcy5zaXplKSB7XG4gICAgICB2b2lkIHRoaXMuZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmNsZWFyRGVsYXlUaW1lb3V0KCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuZmx1c2goKSwgdGhpcy5kZWxheSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWxscyA9IHRoaXMucXVldWUuc3BsaWNlKDApO1xuICAgIGNvbnN0IGlucHV0cyA9IGNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5pbnB1dCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmNhbGxiYWNrKGlucHV0cyk7XG4gICAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzPy5baW5kZXhdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChuZXcgRXJyb3IoXCJDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheS5cIikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGxzLmxlbmd0aCAhPT0gcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIHByb3ZpZGVkIGl0ZW1zLiBFeHBlY3RlZCAke2NhbGxzLmxlbmd0aH0sIGJ1dCBnb3QgJHtyZXN1bHRzLmxlbmd0aH0uYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGwucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSB0cnVlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgICAgICBjYWxsLnJlamVjdChlcnJvcjMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldChpbnB1dCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2FsbCA9IHRoaXMucXVldWUuZmluZChcbiAgICAgIChjYWxsMikgPT4gc3RyaW5naWZ5KGNhbGwyLmlucHV0KSA9PT0gc3RyaW5naWZ5KGlucHV0KVxuICAgICk7XG4gICAgaWYgKGV4aXN0aW5nQ2FsbCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FsbC5wcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBjYWxsID0gbmV3IEJhdGNoQ2FsbChpbnB1dCk7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGNhbGwpO1xuICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICByZXR1cm4gY2FsbC5wcm9taXNlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZW91dCgpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaCkge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV2ZW50U291cmNlMiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRDYWNoZUtleShhcmdzKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHN0YXRlKTtcbiAgICBldmVudFNvdXJjZTIubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0KGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoLmdldChpbnB1dCk7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiByZXN1bHQgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMi5vYnNlcnZhYmxlLFxuICAgIGdldCxcbiAgICBnZXRTdGF0ZVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2NyZWF0ZS1zdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gIGxldCBub3RpZnlJbW1lZGlhdGVseSA9IHRydWU7XG4gIGxldCBkaXJ0eSA9IGZhbHNlO1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHN0YXRlO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY2FsbGJhY2sob2xkU3RhdGUpO1xuICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBkaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChub3RpZnlJbW1lZGlhdGVseSkge1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBpZiAoIWRpcnR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2IpIHtcbiAgICBpZiAobm90aWZ5SW1tZWRpYXRlbHkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG4gICAgbm90aWZ5SW1tZWRpYXRlbHkgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbm90aWZ5SW1tZWRpYXRlbHkgPSB0cnVlO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgYmF0Y2gsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgdXBkYXRlZEF0ID0gZGF0YS51cGRhdGVkQXQgPyBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgY29tbWVudHMgPSBkYXRhLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdCxcbiAgICB1cGRhdGVkQXQsXG4gICAgY29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24oZGF0YSkge1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShkYXRhKSB7XG4gIGNvbnN0IG5vdGlmaWVkQXQgPSBuZXcgRGF0ZShkYXRhLm5vdGlmaWVkQXQpO1xuICBjb25zdCByZWFkQXQgPSBkYXRhLnJlYWRBdCA/IG5ldyBEYXRlKGRhdGEucmVhZEF0KSA6IG51bGw7XG4gIGlmIChcImFjdGl2aXRpZXNcIiBpbiBkYXRhKSB7XG4gICAgY29uc3QgYWN0aXZpdGllcyA9IGRhdGEuYWN0aXZpdGllcy5tYXAoKGFjdGl2aXR5KSA9PiAoe1xuICAgICAgLi4uYWN0aXZpdHksXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGFjdGl2aXR5LmNyZWF0ZWRBdClcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBub3RpZmllZEF0LFxuICAgICAgcmVhZEF0LFxuICAgICAgYWN0aXZpdGllc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIG5vdGlmaWVkQXQsXG4gICAgcmVhZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cblxuLy8gc3JjL2h0dHAtY2xpZW50LnRzXG5mdW5jdGlvbiBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG5cbi8vIHNyYy9saWIvdXJsLnRzXG5mdW5jdGlvbiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVybGpvaW4oYmFzZVVybCwgcGF0aCwgcGFyYW1zKSB7XG4gIGNvbnN0IHVybDIgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwyLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwyLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBzdHJpbmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBzdHIsIGkpID0+IHJlc3VsdCArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaSAtIDFdID8/IFwiXCIpICsgc3RyXG4gICk7XG59XG5cbi8vIHNyYy9ub3RpZmljYXRpb25zLnRzXG5mdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25zQXBpKHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGN1cnJlbnRVc2VySWRTdG9yZSxcbiAgZmV0Y2hlclxufSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGlmICghZW5kcG9pbnQuc3RhcnRzV2l0aChcIi92Mi9jL1wiKSkge1xuICAgICAgcmFpc2UoXCJFeHBlY3RlZCBhIC92Mi9jLyogZW5kcG9pbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCJcbiAgICB9KTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIgJiYgYXV0aFZhbHVlLnRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgY29uc3QgdXNlcklkID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZC51aWQ7XG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuc2V0KCgpID0+IHVzZXJJZCk7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKGJhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hlcih1cmwyLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gLFxuICAgICAgICBcIlgtTEItQ2xpZW50XCI6IFBLR19WRVJTSU9OIHx8IFwiZGV2XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9uc2AsIHZvaWQgMCwge1xuICAgICAgY3Vyc29yOiBvcHRpb25zPy5jdXJzb3IsXG4gICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGFcbiAgICAgICksXG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgbmV4dEN1cnNvcjoganNvbi5tZXRhLm5leHRDdXJzb3IsXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2Uoc2luY2UpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hKc29uKHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2RlbHRhYCwgdm9pZCAwLCB7XG4gICAgICBzaW5jZTogc2luY2UudG9JU09TdHJpbmcoKVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB0aHJlYWRzOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KCkge1xuICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9jb3VudGApO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICAgIGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzOiBcImFsbFwiIH0pXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24odXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnNgLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zLyR7aW5ib3hOb3RpZmljYXRpb25JZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbih1cmxgL3YyL2MvdGhyZWFkc2AsIHZvaWQgMCwge1xuICAgICAgY3Vyc29yOiBvcHRpb25zLmN1cnNvcixcbiAgICAgIHF1ZXJ5LFxuICAgICAgbGltaXQ6IFBBR0VfU0laRVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hKc29uKHVybGAvdjIvYy90aHJlYWRzYCwgdm9pZCAwLCB7XG4gICAgICBzaW5jZTogb3B0aW9ucy5zaW5jZS50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2UsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uLFxuICAgIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICBnZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3Bvc2l0aW9uLnRzXG52YXIgTUlOX0NPREUgPSAzMjtcbnZhciBNQVhfQ09ERSA9IDEyNjtcbnZhciBOVU1fRElHSVRTID0gTUFYX0NPREUgLSBNSU5fQ09ERSArIDE7XG52YXIgWkVSTyA9IG50aERpZ2l0KDApO1xudmFyIE9ORSA9IG50aERpZ2l0KDEpO1xudmFyIFpFUk9fTklORSA9IFpFUk8gKyBudGhEaWdpdCgtMSk7XG5mdW5jdGlvbiBudGhEaWdpdChuKSB7XG4gIGNvbnN0IGNvZGUgPSBNSU5fQ09ERSArIChuIDwgMCA/IE5VTV9ESUdJVFMgKyBuIDogbik7XG4gIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG4gdmFsdWU6ICR7bn1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQb3NpdGlvbih4LCB5KSB7XG4gIGlmICh4ICE9PSB2b2lkIDAgJiYgeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJldHdlZW4oeCwgeSk7XG4gIH0gZWxzZSBpZiAoeCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGFmdGVyKHgpO1xuICB9IGVsc2UgaWYgKHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZWZvcmUoeSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9ORTtcbiAgfVxufVxuZnVuY3Rpb24gYmVmb3JlKHBvcykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwb3MubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPD0gTUlOX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICBpZiAoY29kZSA9PT0gTUlOX0NPREUgKyAxKSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgWkVST19OSU5FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT05FO1xufVxuZnVuY3Rpb24gYWZ0ZXIocG9zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gTUFYX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDEpO1xuICB9XG4gIHJldHVybiBwb3MgKyBPTkU7XG59XG5mdW5jdGlvbiBiZXR3ZWVuKGxvLCBoaSkge1xuICBpZiAobG8gPCBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihsbywgaGkpO1xuICB9IGVsc2UgaWYgKGxvID4gaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4oaGksIGxvKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB2YWx1ZSBiZXR3ZWVuIHR3byBlcXVhbCBwb3NpdGlvbnNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9iZXR3ZWVuKGxvLCBoaSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsb0xlbiA9IGxvLmxlbmd0aDtcbiAgY29uc3QgaGlMZW4gPSBoaS5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbG9Db2RlID0gaW5kZXggPCBsb0xlbiA/IGxvLmNoYXJDb2RlQXQoaW5kZXgpIDogTUlOX0NPREU7XG4gICAgY29uc3QgaGlDb2RlID0gaW5kZXggPCBoaUxlbiA/IGhpLmNoYXJDb2RlQXQoaW5kZXgpIDogTUFYX0NPREU7XG4gICAgaWYgKGxvQ29kZSA9PT0gaGlDb2RlKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoaUNvZGUgLSBsb0NvZGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpbmRleCArIDE7XG4gICAgICBsZXQgcHJlZml4ID0gbG8uc3Vic3RyaW5nKDAsIHNpemUpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHByZWZpeCArPSBaRVJPLnJlcGVhdChzaXplIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBsby5zdWJzdHJpbmcoc2l6ZSk7XG4gICAgICBjb25zdCBuaW5lcyA9IFwiXCI7XG4gICAgICByZXR1cm4gcHJlZml4ICsgX2JldHdlZW4oc3VmZml4LCBuaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWtlTihsbywgaW5kZXgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShoaUNvZGUgKyBsb0NvZGUgPj4gMSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0YWtlTihwb3MsIG4pIHtcbiAgcmV0dXJuIG4gPCBwb3MubGVuZ3RoID8gcG9zLnN1YnN0cmluZygwLCBuKSA6IHBvcyArIFpFUk8ucmVwZWF0KG4gLSBwb3MubGVuZ3RoKTtcbn1cbnZhciBNSU5fTk9OX1pFUk9fQ09ERSA9IE1JTl9DT0RFICsgMTtcbmZ1bmN0aW9uIGlzUG9zKHN0cikge1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RJZHggPSBzdHIubGVuZ3RoIC0gMTtcbiAgY29uc3QgbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJZHgpO1xuICBpZiAobGFzdCA8IE1JTl9OT05fWkVST19DT0RFIHx8IGxhc3QgPiBNQVhfQ09ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1BvcyhzdHIpIHtcbiAgY29uc3QgY29kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZXMucHVzaChjb2RlIDwgTUlOX0NPREUgPyBNSU5fQ09ERSA6IGNvZGUgPiBNQVhfQ09ERSA/IE1BWF9DT0RFIDogY29kZSk7XG4gIH1cbiAgd2hpbGUgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPT09IE1JTl9DT0RFKSB7XG4gICAgY29kZXMubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIGNvZGVzLmxlbmd0aCA+IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvZGVzKSA6IChcbiAgICAvLyBFZGdlIGNhc2U6IHRoZSBzdHIgd2FzIGEgMC1vbmx5IHN0cmluZywgd2hpY2ggaXMgaW52YWxpZC4gRGVmYXVsdCBiYWNrIHRvIC4xXG4gICAgT05FXG4gICk7XG59XG5mdW5jdGlvbiBhc1BvcyhzdHIpIHtcbiAgcmV0dXJuIGlzUG9zKHN0cikgPyBzdHIgOiBjb252ZXJ0VG9Qb3Moc3RyKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL09wLnRzXG52YXIgT3BDb2RlID0gLyogQF9fUFVSRV9fICovICgoT3BDb2RlMikgPT4ge1xuICBPcENvZGUyW09wQ29kZTJbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiU0VUX1BBUkVOVF9LRVlcIl0gPSAxXSA9IFwiU0VUX1BBUkVOVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX0xJU1RcIl0gPSAyXSA9IFwiQ1JFQVRFX0xJU1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiVVBEQVRFX09CSkVDVFwiXSA9IDNdID0gXCJVUERBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9PQkpFQ1RcIl0gPSA0XSA9IFwiQ1JFQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfQ1JEVFwiXSA9IDVdID0gXCJERUxFVEVfQ1JEVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfT0JKRUNUX0tFWVwiXSA9IDZdID0gXCJERUxFVEVfT0JKRUNUX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTUFQXCJdID0gN10gPSBcIkNSRUFURV9NQVBcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX1JFR0lTVEVSXCJdID0gOF0gPSBcIkNSRUFURV9SRUdJU1RFUlwiO1xuICByZXR1cm4gT3BDb2RlMjtcbn0pKE9wQ29kZSB8fCB7fSk7XG5mdW5jdGlvbiBhY2tPcChvcElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICBpZDogXCJBQ0tcIixcbiAgICAvLyAoSClBQ0tcbiAgICBvcElkXG4gIH07XG59XG5mdW5jdGlvbiBpc0Fja09wKG9wKSB7XG4gIHJldHVybiBvcC50eXBlID09PSA1IC8qIERFTEVURV9DUkRUICovICYmIG9wLmlkID09PSBcIkFDS1wiO1xufVxuXG4vLyBzcmMvY3JkdHMvQWJzdHJhY3RDcmR0LnRzXG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sID8gdGhpcy5fX3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9faWQgfHwgdGhpcy5fX3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy5fX2lkID0gaWQ7XG4gICAgdGhpcy5fX3Bvb2wgPSBwb29sO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBpZiAodGhpcy5fX3Bvb2wgJiYgdGhpcy5fX2lkKSB7XG4gICAgICB0aGlzLl9fcG9vbC5kZWxldGVOb2RlKHRoaXMuX19pZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX19wb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQ2xlYXIgdGhlIEltbXV0YWJsZSBjYWNoZSwgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHRvIGAudG9JbW11dGFibGUoKWAgd2lsbFxuICAgKiByZWNvbXB1dGUgdGhlIGVxdWl2YWxlbnQgSW1tdXRhYmxlIHZhbHVlIGFnYWluLiAgQ2FsbCB0aGlzIGFmdGVyIGV2ZXJ5XG4gICAqIG11dGF0aW9uIHRvIHRoZSBMaXZlIG5vZGUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgIT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybiBhbiBzbmFwc2hvdCBvZiB0aGlzIExpdmUgdHJlZSBmb3IgdXNlIGluIERldlRvb2xzLlxuICAgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVHJlZU5vZGUgPT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSA9IGtleTtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdGhpcy5fdG9UcmVlTm9kZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbW11dGFibGUgc25hcHNob3Qgb2YgdGhpcyBMaXZlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdGhpcy5fdG9JbW11dGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEltbXV0YWJsZTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1NlcmlhbGl6ZWRDcmR0LnRzXG52YXIgQ3JkdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDcmR0VHlwZTIpID0+IHtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk9CSkVDVFwiXSA9IDBdID0gXCJPQkpFQ1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIkxJU1RcIl0gPSAxXSA9IFwiTElTVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTUFQXCJdID0gMl0gPSBcIk1BUFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiUkVHSVNURVJcIl0gPSAzXSA9IFwiUkVHSVNURVJcIjtcbiAgcmV0dXJuIENyZHRUeXBlMjtcbn0pKENyZHRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzUm9vdENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLyAmJiAhaXNDaGlsZENyZHQoY3JkdCk7XG59XG5mdW5jdGlvbiBpc0NoaWxkQ3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnBhcmVudElkICE9PSB2b2lkIDAgJiYgY3JkdC5wYXJlbnRLZXkgIT09IHZvaWQgMDtcbn1cblxuLy8gc3JjL2xpYi9uYW5vaWQudHNcbnZhciBuYW5vaWQgPSAodCA9IDIxKSA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHQpKS5yZWR1Y2UoXG4gICh0MiwgZSkgPT4gdDIgKz0gKGUgJj0gNjMpIDwgMzYgPyBlLnRvU3RyaW5nKDM2KSA6IGUgPCA2MiA/IChlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpIDogZSA8IDYzID8gXCJfXCIgOiBcIi1cIixcbiAgXCJcIlxuKTtcblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLl9pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdChbXSk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0Ll9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IEpTT04uc3RyaW5naWZ5KGNyZHQuZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvYXV0b1JldHJ5LnRzXG5hc3luYyBmdW5jdGlvbiBhdXRvUmV0cnkocHJvbWlzZUZuLCBtYXhUcmllcywgYmFja29mZiwgdGhyb3dFcnJvcikge1xuICBjb25zdCBmYWxsYmFja0JhY2tvZmYgPSBiYWNrb2ZmLmxlbmd0aCA+IDAgPyBiYWNrb2ZmW2JhY2tvZmYubGVuZ3RoIC0gMV0gOiAwO1xuICBsZXQgYXR0ZW1wdCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYXR0ZW1wdCsrO1xuICAgIGNvbnN0IHByb21pc2UgPSBwcm9taXNlRm4oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhyb3dFcnJvcj8uKGVycikgfHwgZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nMikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ZW1wdCA+PSBtYXhUcmllcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCBhZnRlciAke21heFRyaWVzfSBhdHRlbXB0czogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBiYWNrb2ZmW2F0dGVtcHQgLSAxXSA/PyBmYWxsYmFja0JhY2tvZmY7XG4gICAgd2FybihcbiAgICAgIGBBdHRlbXB0ICR7YXR0ZW1wdH0gd2FzIHVuc3VjY2Vzc2Z1bC4gUmV0cnlpbmcgaW4gJHtkZWxheX0gbWlsbGlzZWNvbmRzLmBcbiAgICApO1xuICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICB9XG59XG52YXIgU3RvcFJldHJ5aW5nMiA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2NodW5rLnRzXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8vIHNyYy9saWIvY3JlYXRlSWRzLnRzXG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBDT01NRU5UX0FUVEFDSE1FTlRfSURfUFJFRklYID0gXCJhdFwiO1xudmFyIElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVggPSBcImluXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvbGliL2RlYnVnLnRzXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShtc2csIHRyYWNlUm9vdCkge1xuICBjb25zdCBlcnJvckxpa2UgPSB7IG5hbWU6IG1zZyB9O1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yTGlrZSwgdHJhY2VSb290KTtcbiAgcmV0dXJuIGVycm9yTGlrZS5zdGFjaztcbn1cblxuLy8gc3JjL2xpYi9Kc29uLnRzXG5mdW5jdGlvbiBpc0pzb25TY2FsYXIoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0pzb25BcnJheShkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuICFpc0pzb25TY2FsYXIoZGF0YSkgJiYgIWlzSnNvbkFycmF5KGRhdGEpO1xufVxuXG4vLyBzcmMvbGliL29iamVjdFRvUXVlcnkudHNcbnZhciBpZGVudGlmaWVyUmVnZXggPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmZ1bmN0aW9uIG9iamVjdFRvUXVlcnkob2JqKSB7XG4gIGxldCBmaWx0ZXJMaXN0ID0gW107XG4gIGNvbnN0IGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IFtdO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gIGNvbnN0IGluZGV4ZWRLZXlzID0gW107XG4gIGVudHJpZXMyLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghaWRlbnRpZmllclJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IG11c3Qgb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIF9cIik7XG4gICAgfVxuICAgIGlmIChpc1NpbXBsZVZhbHVlKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbHVlV2l0aE9wZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIShcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSkpIHtcbiAgICAgIGluZGV4ZWRLZXlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gIH0pO1xuICBmaWx0ZXJMaXN0ID0gW1xuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhrZXlWYWx1ZVBhaXJzKSxcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3Ioa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgXTtcbiAgaW5kZXhlZEtleXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmVzdGVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlycyA9IFtdO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gICAgbmVzdGVkRW50cmllcy5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChpc1N0cmluZ0VtcHR5KG5lc3RlZEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NpbXBsZVZhbHVlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlycy5wdXNoKFtmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLCBuZXN0ZWRWYWx1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlV2l0aE9wZXJhdG9yKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtcbiAgICAgICAgICBmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLFxuICAgICAgICAgIG5lc3RlZFZhbHVlXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZpbHRlckxpc3QgPSBbXG4gICAgICAuLi5maWx0ZXJMaXN0LFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzKG5LZXlWYWx1ZVBhaXJzKSxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcihuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgICBdO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlckxpc3QubWFwKFxuICAgICh7IGtleSwgb3BlcmF0b3IsIHZhbHVlIH0pID0+IGZvcm1hdEZpbHRlcihrZXksIG9wZXJhdG9yLCBmb3JtYXRGaWx0ZXJWYWx1ZSh2YWx1ZSkpXG4gICkuam9pbihcIiBBTkQgXCIpO1xufVxudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyA9IChrZXlWYWx1ZVBhaXJzKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlycy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAga2V5LFxuICAgICAgb3BlcmF0b3I6IFwiOlwiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJzO1xufTtcbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSAoa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcikgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKFwic3RhcnRzV2l0aFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdGFydHNXaXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIG9wZXJhdG9yOiBcIl5cIixcbiAgICAgICAgdmFsdWU6IHZhbHVlLnN0YXJ0c1dpdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJzO1xufTtcbnZhciBpc1NpbXBsZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzVmFsdWVXaXRoT3BlcmF0b3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgZm9ybWF0RmlsdGVyID0gKGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gIHJldHVybiBgJHtrZXl9JHtvcGVyYXRvcn0ke3ZhbHVlfWA7XG59O1xudmFyIGZvcm1hdEZpbHRlcktleSA9IChrZXksIG5lc3RlZEtleSkgPT4ge1xuICBpZiAobmVzdGVkS2V5KSB7XG4gICAgcmV0dXJuIGAke2tleX1bJHtKU09OLnN0cmluZ2lmeShuZXN0ZWRLZXkpfV1gO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xudmFyIGZvcm1hdEZpbHRlclZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNTdHJpbmdFbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn07XG52YXIgaXNTdHJpbmdFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSBcIlwiO1xufTtcblxuLy8gc3JjL3Byb3RvY29sL0NsaWVudE1zZy50c1xudmFyIENsaWVudE1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChDbGllbnRNc2dDb2RlMikgPT4ge1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkJST0FEQ0FTVF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVF9FVkVOVFwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1NUT1JBR0VcIl0gPSAyMDBdID0gXCJGRVRDSF9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1lET0NcIl0gPSAzMDBdID0gXCJGRVRDSF9ZRE9DXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDFdID0gXCJVUERBVEVfWURPQ1wiO1xuICByZXR1cm4gQ2xpZW50TXNnQ29kZTI7XG59KShDbGllbnRNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3JlZnMvSW1tdXRhYmxlUmVmLnRzXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGNvbnN0IG5ld1ZhbHVlID0geyAuLi50YXJnZXQgfTtcbiAgT2JqZWN0LmtleXMocGF0Y2gpLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGNvbnN0IHZhbCA9IHBhdGNoW2tleV07XG4gICAgaWYgKG5ld1ZhbHVlW2tleV0gIT09IHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdWYWx1ZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWVba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1cGRhdGVkID8gbmV3VmFsdWUgOiB0YXJnZXQ7XG59XG52YXIgSW1tdXRhYmxlUmVmID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ldiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICB9XG4gIGdldCBkaWRJbnZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9ldi5vYnNlcnZhYmxlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fZXYubm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZSA/PyAodGhpcy5fY2FjaGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpKTtcbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvT3RoZXJzUmVmLnRzXG5mdW5jdGlvbiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSkge1xuICBjb25zdCB7IGNvbm5lY3Rpb25JZCwgaWQsIGluZm8gfSA9IGNvbm47XG4gIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGNvbm4uc2NvcGVzKTtcbiAgcmV0dXJuIGZyZWV6ZShcbiAgICBjb21wYWN0T2JqZWN0KHtcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGlkLFxuICAgICAgaW5mbyxcbiAgICAgIGNhbldyaXRlLFxuICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChjb25uLnNjb3BlcyksXG4gICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGUsXG4gICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICBwcmVzZW5jZVxuICAgIH0pXG4gICk7XG59XG52YXIgT3RoZXJzUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgdXNlcnMgPSBjb21wYWN0KFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9wcmVzZW5jZXMua2V5cygpKS5tYXAoXG4gICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB1c2VycztcbiAgfVxuICBjbGVhck90aGVycygpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbm4gIT09IHZvaWQgMCAmJiBwcmVzZW5jZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY2FjaGVkVXNlciA9IHRoaXMuX3VzZXJzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjYWNoZWRVc2VyKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVXNlcjtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRVc2VyID0gdGhpcy5fZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuX3VzZXJzLnNldChjb25uZWN0aW9uSWQsIGNvbXB1dGVkVXNlcik7XG4gICAgICByZXR1cm4gY29tcHV0ZWRVc2VyO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGlmICh0aGlzLl91c2Vycy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5fdXNlcnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGZyZWV6ZSh7XG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgaWQ6IG1ldGFVc2VySWQsXG4gICAgICAgIGluZm86IG1ldGFVc2VySW5mbyxcbiAgICAgICAgc2NvcGVzXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMuX3ByZXNlbmNlcy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX3ByZXNlbmNlcy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZXMgYSBuZXcgdXNlciBmcm9tIGEgZnVsbCBwcmVzZW5jZSB1cGRhdGUuIElmIHRoZSB1c2VyIGFscmVhZHkgZXhpc3RzLFxuICAgKiBpdHMga25vd24gcHJlc2VuY2UgZGF0YSBpcyBvdmVyd3JpdHRlbi5cbiAgICovXG4gIHNldE90aGVyKGNvbm5lY3Rpb25JZCwgcHJlc2VuY2UpIHtcbiAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKGNvbXBhY3RPYmplY3QocHJlc2VuY2UpKSk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25zLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIGNvbnN0IG9sZFByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChvbGRQcmVzZW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ByZXNlbmNlID0gbWVyZ2Uob2xkUHJlc2VuY2UsIHBhdGNoKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgIT09IG5ld1ByZXNlbmNlKSB7XG4gICAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvUGF0Y2hhYmxlUmVmLnRzXG52YXIgUGF0Y2hhYmxlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZnJlZXplKGNvbXBhY3RPYmplY3QoZGF0YSkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICovXG4gIHBhdGNoKHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgbmV3RGF0YSA9IG1lcmdlKG9sZERhdGEsIHBhdGNoKTtcbiAgICBpZiAob2xkRGF0YSAhPT0gbmV3RGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShuZXdEYXRhKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvVmFsdWVSZWYudHNcbnZhciBWYWx1ZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShpbml0aWFsVmFsdWUpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShuZXdWYWx1ZSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbn07XG52YXIgRGVyaXZlZFJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtRm4gPSBhcmdzLnBvcCgpO1xuICAgIGNvbnN0IG90aGVyUmVmcyA9IGFyZ3M7XG4gICAgdGhpcy5fcmVmcyA9IG90aGVyUmVmcztcbiAgICB0aGlzLl9yZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgcmVmLmRpZEludmFsaWRhdGUuc3Vic2NyaWJlKCgpID0+IHRoaXMuaW52YWxpZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1GbjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKFxuICAgICAgLi4udGhpcy5fcmVmcy5tYXAoKHJlZikgPT4gcmVmLmN1cnJlbnQpXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3Jvb20udHNcbnZhciBNQVhfU09DS0VUX01FU1NBR0VfU0laRSA9IDEwMjQgKiAxMDI0IC0gMTAyNDtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxudmFyIEdFVF9BVFRBQ0hNRU5UX1VSTFNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBBVFRBQ0hNRU5UX1BBUlRfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcbnZhciBBVFRBQ0hNRU5UX1BBUlRfQkFUQ0hfU0laRSA9IDU7XG52YXIgUkVUUllfQVRURU1QVFMgPSAxMDtcbnZhciBSRVRSWV9ERUxBWVMgPSBbXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlM1xuXTtcbmZ1bmN0aW9uIHNwbGl0RmlsZUludG9QYXJ0cyhmaWxlKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGxldCBzdGFydCA9IDA7XG4gIHdoaWxlIChzdGFydCA8IGZpbGUuc2l6ZSkge1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgQVRUQUNITUVOVF9QQVJUX1NJWkUsIGZpbGUuc2l6ZSk7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICBwYXJ0TnVtYmVyOiBwYXJ0cy5sZW5ndGggKyAxLFxuICAgICAgcGFydDogZmlsZS5zbGljZShzdGFydCwgZW5kKVxuICAgIH0pO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbnZhciBDb21tZW50c0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJvb20ob3B0aW9ucywgY29uZmlnKSB7XG4gIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlO1xuICBjb25zdCBpbml0aWFsU3RvcmFnZSA9IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2U7XG4gIGNvbnN0IFtpbkJhY2tncm91bmRTaW5jZSwgdW5pbnN0YWxsQmdUYWJTcHldID0gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKTtcbiAgY29uc3QgZGVsZWdhdGVzID0ge1xuICAgIC4uLmNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgLy8gQSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gZ28gaW50byBcInpvbWJpZSBzdGF0ZVwiIG9ubHkgaWYgYWxsIG9mIHRoZVxuICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zIGFwcGx5OlxuICAgIC8vXG4gICAgLy8gLSBUaGUgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBjbGllbnQgb3B0aW9uIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyAtIFRoZSBicm93c2VyIHdpbmRvdyBoYXMgYmVlbiBpbiB0aGUgYmFja2dyb3VuZCBmb3IgYXQgbGVhc3RcbiAgICAvLyAgIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgLy8gLSBUaGVyZSBhcmUgbm8gcGVuZGluZyBjaGFuZ2VzXG4gICAgLy9cbiAgICBjYW5ab21iaWUoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICE9PSB2b2lkIDAgJiYgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCAhPT0gbnVsbCAmJiBEYXRlLm5vdygpID4gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCArIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAmJiBnZXRTdG9yYWdlU3RhdHVzKCkgIT09IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGRlbGVnYXRlcyxcbiAgICBjb25maWcuZW5hYmxlRGVidWdMb2dnaW5nXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgYnVmZmVyOiB7XG4gICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgIGxhc3RGbHVzaGVkQXQ6IDAsXG4gICAgICBwcmVzZW5jZVVwZGF0ZXM6IChcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGluaXRpYWwgcHJlc2VuY2UgbWVzc2FnZSBhcyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICBkYXRhOiBpbml0aWFsUHJlc2VuY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXVxuICAgIH0sXG4gICAgc3RhdGljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBteVByZXNlbmNlOiBuZXcgUGF0Y2hhYmxlUmVmKGluaXRpYWxQcmVzZW5jZSksXG4gICAgb3RoZXJzOiBuZXcgT3RoZXJzUmVmKCksXG4gICAgaW5pdGlhbFN0b3JhZ2UsXG4gICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIC8vIFkuanNcbiAgICBwcm92aWRlcjogdm9pZCAwLFxuICAgIG9uUHJvdmlkZXJVcGRhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgY29uc3QgZG9Ob3RCYXRjaFVwZGF0ZXMgPSAoY2IpID0+IGNiKCk7XG4gIGNvbnN0IGJhdGNoVXBkYXRlcyA9IGNvbmZpZy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/PyBkb05vdEJhdGNoVXBkYXRlcztcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VCYXRjaDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENsaWVudEFwaShlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKFwiL3YyL2Mvcm9vbXMvXCIpKSB7XG4gICAgICByYWlzZShcIkV4cGVjdGVkIGEgL3YyL2Mvcm9vbXMvKiBlbmRwb2ludFwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IHVybGpvaW4oY29uZmlnLmJhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIGNvbnN0IGZldGNoZXIgPSBjb25maWcucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaGVyKHVybDIsIHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zMj8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEJlYXJlclRva2VuRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWAsXG4gICAgICAgIFwiWC1MQi1DbGllbnRcIjogUEtHX1ZFUlNJT04gfHwgXCJkZXZcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhWYWx1ZSwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vc3RvcmFnZWAsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGh0dHBQb3N0VG9Sb29tKGVuZHBvaW50LCBib2R5KSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIGVuZHBvaW50ID09PSBcIi9zZW5kLW1lc3NhZ2VcIiA/IHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3NlbmQtbWVzc2FnZWAgOiB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRNZW50aW9uKHVzZXJJZCwgbWVudGlvbklkKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RleHQtbWVudGlvbnNgLFxuICAgICAgbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIG1lbnRpb25JZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24obWVudGlvbklkKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RleHQtbWVudGlvbnMvJHttZW50aW9uSWR9YCxcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydFRleHRFZGl0b3IodHlwZSwgcm9vdEtleSkge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKTtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHJvb3RLZXkgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMoKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3ZlcnNpb25zYCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0veS12ZXJzaW9uLyR7dmVyc2lvbklkfWAsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7IG1ldGhvZDogXCJHRVRcIiB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0VmVyc2lvbigpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdmVyc2lvbmAsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7IG1ldGhvZDogXCJQT1NUXCIgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlcyk7XG4gICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5ub25jZTtcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQICYmIG5vbmNlKSB7XG4gICAgICBjb25zdCBzaXplID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRQYXlsb2FkKS5sZW5ndGg7XG4gICAgICBpZiAoc2l6ZSA+IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICAgIHZvaWQgaHR0cFBvc3RUb1Jvb20oXCIvc2VuZC1tZXNzYWdlXCIsIHsgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oXG4gICAgICAgICAgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcC5vayAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWVzc2FnZSB3YXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzIGFuZCBzZW50IG92ZXIgSFRUUCBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYW5hZ2VkU29ja2V0LnNlbmQoc2VyaWFsaXplZFBheWxvYWQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQubXlQcmVzZW5jZSxcbiAgICAoc3RhdGljU2Vzc2lvbiwgZHluYW1pY1Nlc3Npb24sIG15UHJlc2VuY2UpID0+IHtcbiAgICAgIGlmIChzdGF0aWNTZXNzaW9uID09PSBudWxsIHx8IGR5bmFtaWNTZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoZHluYW1pY1Nlc3Npb24uc2NvcGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGR5bmFtaWNTZXNzaW9uLmFjdG9yLFxuICAgICAgICAgIGlkOiBzdGF0aWNTZXNzaW9uLnVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBzdGF0aWNTZXNzaW9uLnVzZXJJbmZvLFxuICAgICAgICAgIHByZXNlbmNlOiBteVByZXNlbmNlLFxuICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoZHluYW1pY1Nlc3Npb24uc2NvcGVzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgbGV0IF9sYXN0U2VsZjtcbiAgZnVuY3Rpb24gbm90aWZ5U2VsZkNoYW5nZWQoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3QgY3VyclNlbGYgPSBzZWxmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJTZWxmICE9PSBudWxsICYmIGN1cnJTZWxmICE9PSBfbGFzdFNlbGYpIHtcbiAgICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICAgIGV2ZW50SHViLnNlbGYubm90aWZ5KGN1cnJTZWxmKTtcbiAgICAgIH0pO1xuICAgICAgX2xhc3RTZWxmID0gY3VyclNlbGY7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGZBc1RyZWVOb2RlID0gbmV3IERlcml2ZWRSZWYoXG4gICAgc2VsZixcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gdXNlclRvVHJlZU5vZGUoXCJNZVwiLCBtZSkgOiBudWxsXG4gICk7XG4gIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChtZXNzYWdlLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBsb2FkIHN0b3JhZ2Ugd2l0aG91dCBpdGVtc1wiKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICB1cGRhdGVSb290KG1lc3NhZ2UuaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucm9vdCA9IExpdmVPYmplY3QuX2Zyb21JdGVtcyhtZXNzYWdlLml0ZW1zLCBwb29sKTtcbiAgICB9XG4gICAgY29uc3QgY2FuV3JpdGUgPSBzZWxmLmN1cnJlbnQ/LmNhbldyaXRlID8/IHRydWU7XG4gICAgY29uc3Qgc3RhY2tTaXplQmVmb3JlID0gY29udGV4dC51bmRvU3RhY2subGVuZ3RoO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHQuaW5pdGlhbFN0b3JhZ2UpIHtcbiAgICAgIGlmIChjb250ZXh0LnJvb3QuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY2FuV3JpdGUpIHtcbiAgICAgICAgICBjb250ZXh0LnJvb3Quc2V0KGtleSwgY2xvbmVMc29uKGNvbnRleHQuaW5pdGlhbFN0b3JhZ2Vba2V5XSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHBvcHVsYXRlIG1pc3Npbmcgc3RvcmFnZSBrZXkgJyR7a2V5fScsIGJ1dCBjdXJyZW50IHVzZXIgaGFzIG5vIHdyaXRlIGFjY2Vzc2BcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IHN0YWNrU2l6ZUJlZm9yZTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb290KGl0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2YgY29udGV4dC5ub2Rlcykge1xuICAgICAgY3VycmVudEl0ZW1zLnNldChpZCwgbm9kZS5fc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3IE1hcChpdGVtcykpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgZmFsc2UpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5LnVuc2hpZnQoLi4uaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gdXBkYXRlcy5zdG9yYWdlVXBkYXRlcztcbiAgICBjb25zdCBvdGhlcnNVcGRhdGVzID0gdXBkYXRlcy5vdGhlcnM7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICAgIGV2ZW50SHViLm90aGVycy5ub3RpZnkoeyAuLi5ldmVudCwgb3RoZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcy5wcmVzZW5jZSA/PyBmYWxzZSkge1xuICAgICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGV2ZW50SHViLm15UHJlc2VuY2Uubm90aWZ5KGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yYWdlVXBkYXRlcyAhPT0gdm9pZCAwICYmIHN0b3JhZ2VVcGRhdGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICAgIGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5ub3RpZnkodXBkYXRlczIpO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudDtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uYWN0b3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW50ZXJuYWwuIFRyaWVkIHRvIGdldCBjb25uZWN0aW9uIGlkIGJ1dCBjb25uZWN0aW9uIHdhcyBuZXZlciBvcGVuXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3BzKHJhd09wcywgaXNMb2NhbCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZWROb2RlSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBvcHMgPSByYXdPcHMubWFwKChvcCkgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIiAmJiAhb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4geyAuLi5vcCwgb3BJZDogcG9vbC5nZW5lcmF0ZU9wSWQoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICByZXZlcnNlLmRhdGFba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKG9wLmRhdGEpO1xuICAgICAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0geyB0eXBlOiBcInBhcnRpYWxcIiwgZGF0YTogb3AuZGF0YSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvcC5kYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIHNvdXJjZSA9IGRlbGV0ZWQgPyAyIC8qIEFDSyAqLyA6IDEgLyogUkVNT1RFICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5T3BSZXN1bHQgPSBhcHBseU9wKG9wLCBzb3VyY2UpO1xuICAgICAgICBpZiAoYXBwbHlPcFJlc3VsdC5tb2RpZmllZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQ7XG4gICAgICAgICAgaWYgKCEobm9kZUlkICYmIGNyZWF0ZWROb2RlSWRzLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgbm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLmdldChubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSksXG4gICAgICAgICAgICAgICAgYXBwbHlPcFJlc3VsdC5tb2RpZmllZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdCguLi5hcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IG91dHB1dC5yZXZlcnNlLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5fYXBwbHkob3AsIHNvdXJjZSA9PT0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi8pO1xuICAgICAgfVxuICAgICAgY2FzZSAxIC8qIFNFVF9QQVJFTlRfS0VZICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiBpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Lm5vZGUuX3NldENoaWxkS2V5KFxuICAgICAgICAgICAgYXNQb3Mob3AucGFyZW50S2V5KSxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86IHtcbiAgICAgICAgaWYgKG9wLnBhcmVudElkID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgIH1cbiAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gocGF0Y2gpO1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnJldmVyc2VPcHMudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IG9sZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5wcmVzZW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKFxuICAgICAgICAgICAgW3sgdHlwZTogXCJwcmVzZW5jZVwiLCBkYXRhOiBvbGRWYWx1ZXMgfV0sXG4gICAgICAgICAgICBkb05vdEJhdGNoVXBkYXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KHsgcHJlc2VuY2U6IHRydWUgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50YXJnZXRBY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBvbGRVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSk7XG4gICAgICBjb25zdCBuZXdVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGlmIChvbGRVc2VyID09PSB2b2lkIDAgJiYgbmV3VXNlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlcjogbmV3VXNlciB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5wYXRjaE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSksIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICB1cGRhdGVzOiBtZXNzYWdlLmRhdGEsXG4gICAgICAgIHVzZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibGVhdmVcIiwgdXNlciB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgIGFjdG9yOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICBzY29wZXM6IG1lc3NhZ2Uuc2NvcGVzXG4gICAgfSk7XG4gICAgY29udGV4dC5pZEZhY3RvcnkgPSBtYWtlSWRGYWN0b3J5KG1lc3NhZ2UuYWN0b3IpO1xuICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSWQgb2YgY29udGV4dC5vdGhlcnMuY29ubmVjdGlvbklkcygpKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1tjb25uZWN0aW9uSWRdO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2UudXNlcnMpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIoa2V5KTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5pbmZvLFxuICAgICAgICB1c2VyLnNjb3Blc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZXNldFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICByZXR1cm4gY29udGV4dC51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBjYW5SZWRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuaGlzdG9yeS5ub3RpZnkoeyBjYW5VbmRvOiBjYW5VbmRvKCksIGNhblJlZG86IGNhblJlZG8oKSB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgbWVzc2FnZS5hY3RvcixcbiAgICAgIG1lc3NhZ2UuaWQsXG4gICAgICBtZXNzYWdlLmluZm8sXG4gICAgICBtZXNzYWdlLnNjb3Blc1xuICAgICk7XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgZGF0YTogY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvclxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgcmV0dXJuIHVzZXIgPyB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlciB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2VzKHRleHQpIHtcbiAgICBjb25zdCBkYXRhID0gdHJ5UGFyc2VKc29uKHRleHQpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNKc29uQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBjb21wYWN0KGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZVNlcnZlck1lc3NhZ2UoaXRlbSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoW3BhcnNlU2VydmVyTWVzc2FnZShkYXRhKV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBseUFuZFNlbmRPcHMob2ZmbGluZU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IG9wcyA9IEFycmF5LmZyb20ob2ZmbGluZU9wcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCB0cnVlKTtcbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgIG9wczogcmVzdWx0Lm9wc1xuICAgIH0pO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNlcnZlck1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBwYXJzZVNlcnZlck1lc3NhZ2VzKGV2ZW50LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlcyA9PT0gbnVsbCB8fCBtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb3RoZXJzOiBbXVxuICAgIH07XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgICBjb25zdCB1c2VySm9pbmVkVXBkYXRlID0gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh1c2VySm9pbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnNQcmVzZW5jZVVwZGF0ZSA9IG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob3RoZXJzUHJlc2VuY2VVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAzIC8qIEJST0FEQ0FTVEVEX0VWRU5UICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICAgICAgZXZlbnRIdWIuY3VzdG9tRXZlbnQubm90aWZ5KHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLmFjdG9yIDwgMCA/IG51bGwgOiBvdGhlcnMuZmluZCgodSkgPT4gdS5jb25uZWN0aW9uSWQgPT09IG1lc3NhZ2UuYWN0b3IpID8/IG51bGwsXG4gICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Mikge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzMDAgLyogVVBEQVRFX1lET0MgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTA0IC8qIFJPT01fU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovOiB7XG4gICAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5UmVzdWx0ID0gYXBwbHlPcHMobWVzc2FnZS5vcHMsIGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFwcGx5UmVzdWx0LnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXModXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyOTkgLyogUkVKRUNUX1NUT1JBR0VfT1AgKi86IHtcbiAgICAgICAgICAgIGVycm9yV2l0aFRpdGxlKFxuICAgICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCB0cmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wSWQgb2YgbWVzc2FnZS5vcElkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gY29udGV4dC5vcFN0YWNrVHJhY2VzPy5nZXQob3BJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgICB0cmFjZXMuYWRkKHRyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRyYWNlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHdhcm5XaXRoVGl0bGUoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gY2FsbHMgY2F1c2VkIHRoZSByZWplY3RlZCBzdG9yYWdlIG11dGF0aW9uczpcIixcbiAgICAgICAgICAgICAgICAgIGBcblxuJHtBcnJheS5mcm9tKHRyYWNlcykuam9pbihcIlxcblxcblwiKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFN0b3JhZ2UgbXV0YXRpb25zIHJlamVjdGVkIGJ5IHNlcnZlcjogJHttZXNzYWdlLnJlYXNvbn1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0MDAgLyogVEhSRUFEX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDcgLyogVEhSRUFEX0RFTEVURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDggLyogVEhSRUFEX1VQREFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDUgLyogQ09NTUVOVF9SRUFDVElPTl9BRERFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgICAgY2FzZSA0MDIgLyogQ09NTUVOVF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAzIC8qIENPTU1FTlRfRURJVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIuY29tbWVudHMubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3RpZnkodXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoTm93T3JTb29uKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VPcHMgPSBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucztcbiAgICBpZiAoc3RvcmFnZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIHN0b3JhZ2VPcHMpIHtcbiAgICAgICAgY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zZXQobm4ob3Aub3BJZCksIG9wKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdyAtIGNvbnRleHQuYnVmZmVyLmxhc3RGbHVzaGVkQXQ7XG4gICAgaWYgKGVsYXBzZWRNaWxsaXMgPj0gY29uZmlnLnRocm90dGxlRGVsYXkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9GbHVzaCA9IHNlcmlhbGl6ZUJ1ZmZlcigpO1xuICAgICAgaWYgKG1lc3NhZ2VzVG9GbHVzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzVG9GbHVzaCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlciA9IHtcbiAgICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICAgIGxhc3RGbHVzaGVkQXQ6IG5vdyxcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIHByZXNlbmNlVXBkYXRlczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgICBmbHVzaE5vd09yU29vbixcbiAgICAgICAgY29uZmlnLnRocm90dGxlRGVsYXkgLSBlbGFwc2VkTWlsbGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXJpYWxpemVCdWZmZXIoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMudHlwZSA9PT0gXCJmdWxsXCIgPyB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICAvLyBQb3B1bGF0aW5nIHRoZSBgdGFyZ2V0QWN0b3JgIGZpZWxkIHR1cm5zIHRoaXMgbWVzc2FnZSBpbnRvXG4gICAgICAgICAgLy8gYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZSBtZXNzYWdlIChub3QgYSBwYXRjaCksIHdoaWNoIHdpbGwgZ2V0XG4gICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYnkgb3RoZXIgY2xpZW50cyBhcyBzdWNoLlxuICAgICAgICAgIHRhcmdldEFjdG9yOiAtMSxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgICBvcHM6IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVlEb2ModXBkYXRlLCBndWlkKSB7XG4gICAgY29uc3QgY2xpZW50TXNnID0ge1xuICAgICAgdHlwZTogMzAxIC8qIFVQREFURV9ZRE9DICovLFxuICAgICAgdXBkYXRlLFxuICAgICAgZ3VpZFxuICAgIH07XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaChjbGllbnRNc2cpO1xuICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KGNsaWVudE1zZyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBicm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIgPSB7XG4gICAgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIiAmJiAhb3B0aW9uczIuc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDMgLyogQlJPQURDQVNUX0VWRU5UICovLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoT3BzKG9wcykge1xuICAgIGNvbnN0IHsgc3RvcmFnZU9wZXJhdGlvbnMgfSA9IGNvbnRleHQuYnVmZmVyO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBzdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBsZXQgX2dldFN0b3JhZ2UkID0gbnVsbDtcbiAgbGV0IF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BzID0gbmV3IE1hcChjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJlYW1GZXRjaChtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSwgY29uZmlnLnJvb21JZCk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZDtcbiAgICB9KSkge1xuICAgICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDMwMCAvKiBGRVRDSF9ZRE9DICovLFxuICAgICAgICB2ZWN0b3IsXG4gICAgICAgIGd1aWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gMDtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSB7XG4gICAgICAgIG9wczogW10sXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3BzOiBbXVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaFVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzUHJlc2VuY2VSZWFkeSgpIHtcbiAgICByZXR1cm4gc2VsZi5jdXJyZW50ICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1ByZXNlbmNlUmVhZHkoKSkge1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGNvbnN0IHVuc3ViMSA9IGV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBjb25zdCB1bnN1YjIgPSBldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgdW5zdWIxKCk7XG4gICAgICB1bnN1YjIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlUmVhZHkoKSB7XG4gICAgcmV0dXJuIGdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzU3RvcmFnZVJlYWR5KCkpIHtcbiAgICAgIGF3YWl0IGdldFN0b3JhZ2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5vdGhlcnMsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICBlcnJvcjogZXZlbnRIdWIuZXJyb3Iub2JzZXJ2YWJsZSxcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlQmF0Y2gub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlQmF0Y2g6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlXG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29tbWVudHNBcGkoZW5kcG9pbnQsIHBhcmFtcywgb3B0aW9uczIpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMyLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29tbWVudHNKc29uKGVuZHBvaW50LCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMyKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1NpbmNlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICB7IHNpbmNlOiBvcHRpb25zMj8uc2luY2U/LnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICB1cGRhdGVkOiBqc29uLmRhdGEubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICAgIH0sXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICB1cGRhdGVkOiBbXSxcbiAgICAgICAgICBkZWxldGVkOiBbXVxuICAgICAgICB9LFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICB1cGRhdGVkOiBbXSxcbiAgICAgICAgICBkZWxldGVkOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZHMuXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zMj8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zMi5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAge1xuICAgICAgICBjdXJzb3I6IG9wdGlvbnMyPy5jdXJzb3IsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgICB9LFxuICAgICAgeyBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczoganNvbi5kYXRhLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICAgICksXG4gICAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBbXSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgZGVsZXRlZFRocmVhZHM6IFtdLFxuICAgICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgbmV4dEN1cnNvcjogbnVsbCxcbiAgICAgICAgcmVxdWVzdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWRzLlwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHRocmVhZElkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkLXdpdGgtbm90aWZpY2F0aW9uLyR7dGhyZWFkSWR9YFxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiBjb252ZXJ0VG9UaHJlYWREYXRhKGpzb24udGhyZWFkKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IGpzb24uaW5ib3hOb3RpZmljYXRpb24gPyBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoanNvbi5pbmJveE5vdGlmaWNhdGlvbikgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiB2b2lkIDAsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkICR7dGhyZWFkSWR9LmApO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQoe1xuICAgIG1ldGFkYXRhLFxuICAgIGJvZHksXG4gICAgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCksXG4gICAgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpLFxuICAgIGF0dGFjaG1lbnRJZHNcbiAgfSkge1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgYXR0YWNobWVudElkc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGhyZWFkKHRocmVhZElkKSB7XG4gICAgYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCxcbiAgICAgIHsgbWV0aG9kOiBcIkRFTEVURVwiIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YSh7XG4gICAgbWV0YWRhdGEsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIHJldHVybiBhd2FpdCBmZXRjaENvbW1lbnRzSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNSZXNvbHZlZCh0aHJlYWRJZCkge1xuICAgIGF3YWl0IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tYXJrLWFzLXJlc29sdmVkYCxcbiAgICAgIHsgbWV0aG9kOiBcIlBPU1RcIiB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNVbnJlc29sdmVkKHRocmVhZElkKSB7XG4gICAgYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21hcmstYXMtdW5yZXNvbHZlZGAsXG4gICAgICB7IG1ldGhvZDogXCJQT1NUXCIgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCksXG4gICAgYm9keSxcbiAgICBhdHRhY2htZW50SWRzXG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgYXR0YWNobWVudElkc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keSxcbiAgICBhdHRhY2htZW50SWRzXG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBhdHRhY2htZW50SWRzXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaENvbW1lbnRzSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9YCxcbiAgICAgIHsgbWV0aG9kOiBcIkRFTEVURVwiIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfS9yZWFjdGlvbnNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbW9qaSB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH0vcmVhY3Rpb25zLyR7ZW1vaml9YCxcbiAgICAgIHsgbWV0aG9kOiBcIkRFTEVURVwiIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVBdHRhY2htZW50KGZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsb2NhbEF0dGFjaG1lbnRcIixcbiAgICAgIHN0YXR1czogXCJpZGxlXCIsXG4gICAgICBpZDogY3JlYXRlQ29tbWVudEF0dGFjaG1lbnRJZCgpLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGZpbGVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0aW9uczIgPSB7fSkge1xuICAgIGNvbnN0IGFib3J0U2lnbmFsID0gb3B0aW9uczIuc2lnbmFsO1xuICAgIGNvbnN0IGFib3J0RXJyb3IgPSBhYm9ydFNpZ25hbCA/IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBgVXBsb2FkIG9mIGF0dGFjaG1lbnQgJHthdHRhY2htZW50LmlkfSB3YXMgYWJvcnRlZC5gLFxuICAgICAgXCJBYm9ydEVycm9yXCJcbiAgICApIDogdm9pZCAwO1xuICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlUmV0cnlFcnJvciA9IChlcnIpID0+IHtcbiAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChhdHRhY2htZW50LnNpemUgPD0gQVRUQUNITUVOVF9QQVJUX1NJWkUpIHtcbiAgICAgIHJldHVybiBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vdXBsb2FkLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQubmFtZSl9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2htZW50LmZpbGUsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdXBsb2FkSWQ7XG4gICAgICBjb25zdCB1cGxvYWRlZFBhcnRzID0gW107XG4gICAgICBjb25zdCBjcmVhdGVNdWx0aVBhcnRVcGxvYWQgPSBhd2FpdCBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQubmFtZSl9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsZVNpemU6IGF0dGFjaG1lbnQuc2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVwbG9hZElkID0gY3JlYXRlTXVsdGlQYXJ0VXBsb2FkLnVwbG9hZElkO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHNwbGl0RmlsZUludG9QYXJ0cyhhdHRhY2htZW50LmZpbGUpO1xuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSBjaHVuayhwYXJ0cywgQVRUQUNITUVOVF9QQVJUX0JBVENIX1NJWkUpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRzMiBvZiBiYXRjaGVzKSB7XG4gICAgICAgICAgY29uc3QgdXBsb2FkZWRQYXJ0c1Byb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCB7IHBhcnQsIHBhcnROdW1iZXIgfSBvZiBwYXJ0czIpIHtcbiAgICAgICAgICAgIHVwbG9hZGVkUGFydHNQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBhdXRvUmV0cnkoXG4gICAgICAgICAgICAgICAgKCkgPT4gZmV0Y2hDb21tZW50c0pzb24oXG4gICAgICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke2NyZWF0ZU11bHRpUGFydFVwbG9hZC51cGxvYWRJZH0vJHtTdHJpbmcocGFydE51bWJlcil9YCxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJ0LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgICAgICAgICBSRVRSWV9ERUxBWVMsXG4gICAgICAgICAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGxvYWRlZFBhcnRzLnB1c2goLi4uYXdhaXQgUHJvbWlzZS5hbGwodXBsb2FkZWRQYXJ0c1Byb21pc2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3J0ZWRVcGxvYWRlZFBhcnRzID0gdXBsb2FkZWRQYXJ0cy5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBhLnBhcnROdW1iZXIgLSBiLnBhcnROdW1iZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZldGNoQ29tbWVudHNKc29uKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9L2NvbXBsZXRlYCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGFydHM6IHNvcnRlZFVwbG9hZGVkUGFydHMgfSksXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICAgIGlmICh1cGxvYWRJZCAmJiBlcnJvcjM/Lm5hbWUgJiYgKGVycm9yMy5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvcjMubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIikpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHt1cGxvYWRJZH1gLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjQpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJscyhhdHRhY2htZW50SWRzKSB7XG4gICAgY29uc3QgeyB1cmxzIH0gPSBhd2FpdCBmZXRjaENvbW1lbnRzSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzL3ByZXNpZ25lZC11cmxzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYXR0YWNobWVudElkcyB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZEdldEF0dGFjaG1lbnRVcmxzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkQXR0YWNobWVudElkcykgPT4ge1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGJhdGNoZWRBdHRhY2htZW50SWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRVcmxzID0gYXdhaXQgZ2V0QXR0YWNobWVudFVybHMoYXR0YWNobWVudElkcyk7XG4gICAgICByZXR1cm4gYXR0YWNobWVudFVybHMubWFwKFxuICAgICAgICAodXJsMikgPT4gdXJsMiA/PyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGlzIGF0dGFjaG1lbnQncyBVUkxcIilcbiAgICAgICk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBHRVRfQVRUQUNITUVOVF9VUkxTX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgY29uc3QgYXR0YWNobWVudFVybHNTdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZEdldEF0dGFjaG1lbnRVcmxzKTtcbiAgZnVuY3Rpb24gZ2V0QXR0YWNobWVudFVybChhdHRhY2htZW50SWQpIHtcbiAgICByZXR1cm4gYmF0Y2hlZEdldEF0dGFjaG1lbnRVcmxzLmdldChhdHRhY2htZW50SWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoTm90aWZpY2F0aW9uc0pzb24oZW5kcG9pbnQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDbGllbnRBcGkoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9uczIpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAge1xuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgZ2V0IHByZXNlbmNlQnVmZmVyKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzPy5kYXRhID8/IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IHVuZG9TdGFjaygpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQudW5kb1N0YWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCBub2RlQ291bnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQubm9kZXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldFByb3ZpZGVyKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LnByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICBjb250ZXh0Lm9uUHJvdmlkZXJVcGRhdGUubm90aWZ5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvdmlkZXJVcGRhdGU6IGNvbnRleHQub25Qcm92aWRlclVwZGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgICAvLyBzZW5kIG1ldGFkYXRhIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBkZWxldGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBsaXN0IHZlcnNpb25zIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zLFxuICAgICAgICAvLyBnZXQgYSBzcGVjaWZpYyB2ZXJzaW9uXG4gICAgICAgIGdldFRleHRWZXJzaW9uLFxuICAgICAgICAvLyBjcmVhdGUgYSB2ZXJzaW9uXG4gICAgICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5jdXJyZW50LFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5jdXJyZW50LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNobWVudFVybHNTdG9yZVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cyksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaCxcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgaXNQcmVzZW5jZVJlYWR5LFxuICAgICAgaXNTdG9yYWdlUmVhZHksXG4gICAgICB3YWl0VW50aWxQcmVzZW5jZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFByZXNlbmNlUmVhZHkpLFxuICAgICAgd2FpdFVudGlsU3RvcmFnZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSksXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmN1cnJlbnQsXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgZ2V0T3RoZXJzOiAoKSA9PiBjb250ZXh0Lm90aGVycy5jdXJyZW50LFxuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIGdldFRocmVhZHMsXG4gICAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgICBnZXRUaHJlYWQsXG4gICAgICBjcmVhdGVUaHJlYWQsXG4gICAgICBkZWxldGVUaHJlYWQsXG4gICAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICAgIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgICBjcmVhdGVDb21tZW50LFxuICAgICAgZWRpdENvbW1lbnQsXG4gICAgICBkZWxldGVDb21tZW50LFxuICAgICAgYWRkUmVhY3Rpb24sXG4gICAgICByZW1vdmVSZWFjdGlvbixcbiAgICAgIHByZXBhcmVBdHRhY2htZW50LFxuICAgICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgICBnZXROb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkXG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgaW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5lcnJvci5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29tbWVudHNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGBcIiR7U3RyaW5nKGZpcnN0KX1cIiBpcyBub3QgYSB2YWxpZCBldmVudCBuYW1lYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCB8fCB0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IGZpcnN0O1xuICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgbGlzdGVuZXIgY2FsbGJhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xpdmVOb2RlKGZpcnN0KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGZpcnN0O1xuICAgICAgaWYgKG9wdGlvbnM/LmlzRGVlcCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGVDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBub2RlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtTdHJpbmcoZmlyc3QpfSBpcyBub3QgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdWJzY3JpYmVkIHRvLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBzdWJzY3JpYmU7XG59XG5mdW5jdGlvbiBpc1Jvb21FdmVudE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm15LXByZXNlbmNlXCIgfHwgdmFsdWUgPT09IFwib3RoZXJzXCIgfHwgdmFsdWUgPT09IFwiZXZlbnRcIiB8fCB2YWx1ZSA9PT0gXCJlcnJvclwiIHx8IHZhbHVlID09PSBcImhpc3RvcnlcIiB8fCB2YWx1ZSA9PT0gXCJzdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJzdG9yYWdlLXN0YXR1c1wiIHx8IHZhbHVlID09PSBcImxvc3QtY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb21tZW50c1wiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgdXJsMi5wcm90b2NvbCA9IHVybDIucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsMi5wYXRobmFtZSA9IFwiL3Y3XCI7XG4gICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicHVia2V5XCIsIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoYXV0aFZhbHVlLCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICAgIH1cbiAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsMi50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbnZhciBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZID0gNTA7XG52YXIgUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBnZXRUaHJvdHRsZShjbGllbnRPcHRpb25zLnRocm90dGxlID8/IERFRkFVTFRfVEhST1RUTEUpO1xuICBjb25zdCBsb3N0Q29ubmVjdGlvblRpbWVvdXQgPSBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5sb3N0Q29ubmVjdGlvblRpbWVvdXQgPz8gREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xuICBjb25zdCBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCA9IGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcbiAgKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoY2xpZW50T3B0aW9ucy5iYXNlVXJsKTtcbiAgY29uc3QgYXV0aE1hbmFnZXIgPSBjcmVhdGVBdXRoTWFuYWdlcihvcHRpb25zKTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Sb29tKHJvb20pIHtcbiAgICB1bmxpbmtEZXZUb29scyhyb29tLmlkKTtcbiAgICByb29tc0J5SWQuZGVsZXRlKHJvb20uaWQpO1xuICAgIHJvb20uZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxlYXNlUm9vbShkZXRhaWxzKSB7XG4gICAgY29uc3QgbGVhdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gbGVhdmU7XG4gICAgICBpZiAoIWRldGFpbHMudW5zdWJzLmRlbGV0ZShzZWxmKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhpcyBsZWF2ZSBmdW5jdGlvbiB3YXMgYWxyZWFkeSBjYWxsZWQuIENhbGxpbmcgaXQgbW9yZSB0aGFuIG9uY2UgaGFzIG5vIGVmZmVjdC5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRldGFpbHMudW5zdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0ZWFyZG93blJvb20oZGV0YWlscy5yb29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZGV0YWlscy51bnN1YnMuYWRkKGxlYXZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogZGV0YWlscy5yb29tLFxuICAgICAgbGVhdmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyUm9vbShyb29tSWQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlYXNlUm9vbShleGlzdGluZyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMyID0gYXJnc1swXSA/PyB7fTtcbiAgICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlKHJvb21JZCkgOiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UpID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gKHR5cGVvZiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlKSA/PyB7fTtcbiAgICBjb25zdCBuZXdSb29tID0gY3JlYXRlUm9vbShcbiAgICAgIHsgaW5pdGlhbFByZXNlbmNlLCBpbml0aWFsU3RvcmFnZSB9LFxuICAgICAge1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocm90dGxlRGVsYXksXG4gICAgICAgIGxvc3RDb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgICAgIHBvbHlmaWxsczogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMsXG4gICAgICAgIGRlbGVnYXRlczogY2xpZW50T3B0aW9ucy5tb2NrZWREZWxlZ2F0ZXMgPz8ge1xuICAgICAgICAgIGNyZWF0ZVNvY2tldDogbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uV2ViU29ja2V0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhdXRoZW50aWNhdGU6IG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZURlYnVnTG9nZ2luZzogY2xpZW50T3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcsXG4gICAgICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBvcHRpb25zMj8udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIHVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAsXG4gICAgICAgIHVuc3RhYmxlX3N0cmVhbURhdGE6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9zdHJlYW1EYXRhXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBuZXdSb29tRGV0YWlscyA9IHtcbiAgICAgIHJvb206IG5ld1Jvb20sXG4gICAgICB1bnN1YnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHJvb21zQnlJZC5zZXQocm9vbUlkLCBuZXdSb29tRGV0YWlscyk7XG4gICAgc2V0dXBEZXZUb29scygoKSA9PiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpKTtcbiAgICBsaW5rRGV2VG9vbHMocm9vbUlkLCBuZXdSb29tKTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gb3B0aW9uczIuYXV0b0Nvbm5lY3QgPz8gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uYXRvYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJZb3UgbmVlZCB0byBwb2x5ZmlsbCBhdG9iIHRvIHVzZSB0aGUgY2xpZW50IGluIHlvdXIgZW52aXJvbm1lbnQuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYXRvYi1wb2x5ZmlsbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuYXRvYiA9IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLmF0b2I7XG4gICAgICB9XG4gICAgICBuZXdSb29tLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXNlUm9vbShuZXdSb29tRGV0YWlscyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy5yb29tO1xuICAgIHJldHVybiByb29tID8gcm9vbSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgIGF1dGhNYW5hZ2VyLnJlc2V0KCk7XG4gICAgZm9yIChjb25zdCB7IHJvb20gfSBvZiByb29tc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgIGlmICghaXNJZGxlKHJvb20uZ2V0U3RhdHVzKCkpKSB7XG4gICAgICAgIHJvb20ucmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGN1cnJlbnRVc2VySWRTdG9yZSA9IGNyZWF0ZVN0b3JlKG51bGwpO1xuICBjb25zdCBmZXRjaGVyID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZldGNoO1xuICBjb25zdCBodHRwQ2xpZW50TGlrZSA9IGNyZWF0ZU5vdGlmaWNhdGlvbnNBcGkoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hlcixcbiAgICBhdXRoTWFuYWdlcixcbiAgICBjdXJyZW50VXNlcklkU3RvcmVcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVVzZXJzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoZWRSZXNvbHZlVXNlcnMpO1xuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8gPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVSb29tc0luZm8sXG4gICAgXCJTZXQgdGhlIHJlc29sdmVSb29tc0luZm8gb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHJvb20gaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZFJlc29sdmVSb29tc0luZm8pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAuLi5odHRwQ2xpZW50TGlrZSxcbiAgICAgIC8vIEludGVybmFsXG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBjdXJyZW50VXNlcklkU3RvcmUsXG4gICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IGNsaWVudE9wdGlvbnMucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgICAgICAgdXNlcnNTdG9yZSxcbiAgICAgICAgcm9vbXNJbmZvU3RvcmUsXG4gICAgICAgIGdldFJvb21JZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFwiQWxsXCIgdGhyZWFkcyAoPSBcInVzZXJcIiB0aHJlYWRzKVxuICAgICAgICBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWw6IGh0dHBDbGllbnRMaWtlLmdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICAgICAgZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWw6IGh0dHBDbGllbnRMaWtlLmdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsXG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG59XG52YXIgTm90aWZpY2F0aW9uc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBnZXRUaHJvdHRsZSh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXCJ0aHJvdHRsZVwiLCB2YWx1ZSwgTUlOX1RIUk9UVExFLCBNQVhfVEhST1RUTEUpO1xufVxuZnVuY3Rpb24gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImxvc3RDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG4gIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1dhcm5lZCAmJiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gY29uZGl0aW9uKCkgOiBjb25kaXRpb24pKSB7XG4gICAgICAgIHdhcm4oLi4uYXJncyk7XG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1lbnRzL2NvbW1lbnQtYm9keS50c1xuZnVuY3Rpb24gaXNDb21tZW50Qm9keVBhcmFncmFwaChlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gZWxlbWVudCkgJiYgXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMgPSB7XG4gIHBhcmFncmFwaDogaXNDb21tZW50Qm9keVBhcmFncmFwaCxcbiAgdGV4dDogaXNDb21tZW50Qm9keVRleHQsXG4gIGxpbms6IGlzQ29tbWVudEJvZHlMaW5rLFxuICBtZW50aW9uOiBpc0NvbW1lbnRCb2R5TWVudGlvblxufTtcbnZhciBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMgPSB7XG4gIHBhcmFncmFwaDogXCJibG9ja1wiLFxuICB0ZXh0OiBcImlubGluZVwiLFxuICBsaW5rOiBcImlubGluZVwiLFxuICBtZW50aW9uOiBcImlubGluZVwiXG59O1xuZnVuY3Rpb24gdHJhdmVyc2VDb21tZW50Qm9keShib2R5LCBlbGVtZW50T3JWaXNpdG9yLCBwb3NzaWJseVZpc2l0b3IpIHtcbiAgaWYgKCFib2R5IHx8ICFib2R5Py5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnRPclZpc2l0b3IgOiB2b2lkIDA7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c1R5cGVzW2VsZW1lbnRdIDogXCJhbGxcIjtcbiAgY29uc3QgZ3VhcmQgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c0d1YXJkc1tlbGVtZW50XSA6ICgpID0+IHRydWU7XG4gIGNvbnN0IHZpc2l0b3IgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudE9yVmlzaXRvciA6IHBvc3NpYmx5VmlzaXRvcjtcbiAgZm9yIChjb25zdCBibG9jayBvZiBib2R5LmNvbnRlbnQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGlmIChndWFyZChibG9jaykpIHtcbiAgICAgICAgdmlzaXRvcj8uKGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgZm9yIChjb25zdCBpbmxpbmUgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGd1YXJkKGlubGluZSkpIHtcbiAgICAgICAgICB2aXNpdG9yPy4oaW5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpIHtcbiAgY29uc3QgbWVudGlvbmVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJhdmVyc2VDb21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIFwibWVudGlvblwiLFxuICAgIChtZW50aW9uKSA9PiBtZW50aW9uZWRJZHMuYWRkKG1lbnRpb24uaWQpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1lbnRpb25lZElkcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2Vycykge1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFyZXNvbHZlVXNlcnMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRVc2VycztcbiAgfVxuICBjb25zdCB1c2VySWRzID0gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycyh7XG4gICAgdXNlcklkc1xuICB9KTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB1c2VyID0gdXNlcnM/LltpbmRleF07XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJlc29sdmVkVXNlcnMuc2V0KHVzZXJJZCwgdXNlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNvbHZlZFVzZXJzO1xufVxudmFyIGh0bWxFc2NhcGFibGVzID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbnZhciBodG1sRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMoaHRtbEVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGh0bWxTYWZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1N0cmluZyh2YWx1ZSldLCBbXSk7XG59XG5mdW5jdGlvbiBqb2luSHRtbChzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSHRtbFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbkh0bWwodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBodG1sRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IGh0bWxFc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBIdG1sU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVIdG1sKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbnZhciBtYXJrZG93bkVzY2FwYWJsZXMgPSB7XG4gIF86IFwiXFxcXF9cIixcbiAgXCIqXCI6IFwiXFxcXCpcIixcbiAgXCIjXCI6IFwiXFxcXCNcIixcbiAgXCJgXCI6IFwiXFxcXGBcIixcbiAgXCJ+XCI6IFwiXFxcXH5cIixcbiAgXCIhXCI6IFwiXFxcXCFcIixcbiAgXCJ8XCI6IFwiXFxcXHxcIixcbiAgXCIoXCI6IFwiXFxcXChcIixcbiAgXCIpXCI6IFwiXFxcXClcIixcbiAgXCJ7XCI6IFwiXFxcXHtcIixcbiAgXCJ9XCI6IFwiXFxcXH1cIixcbiAgXCJbXCI6IFwiXFxcXFtcIixcbiAgXCJdXCI6IFwiXFxcXF1cIlxufTtcbnZhciBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKG1hcmtkb3duRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gam9pbk1hcmtkb3duKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVNYXJrZG93bih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXJrZG93blNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbk1hcmtkb3duKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gbWFya2Rvd25Fc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBNYXJrZG93blNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlTWFya2Rvd24obm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFya2Rvd24oc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybDIpIHtcbiAgaWYgKHVybDIuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdXJsMi5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICByZXR1cm4gdXJsMjtcbiAgfSBlbHNlIGlmICh1cmwyLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9cIiArIHVybDI7XG4gIH1cbiAgcmV0dXJuO1xufVxudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiBjaGlsZHJlbixcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQsXG4gIGxpbms6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsLFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyBodG1sYDxwPiR7aHRtbFNhZmUoY2hpbGRyZW4pfTwvcD5gIDogY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGVtPiR7Y2hpbGRyZW59PC9lbT5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHM+JHtjaGlsZHJlbn08L3M+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPGEgaHJlZj1cIiR7aHJlZn1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+JHtlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmx9PC9hPmA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxzcGFuIGRhdGEtbWVudGlvbj5AJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9PC9zcGFuPmA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gKioke2NoaWxkcmVufSoqYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYF8ke2NoaWxkcmVufV9gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYH5+JHtjaGlsZHJlbn1+fmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXFxgJHtjaGlsZHJlbn1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBbJHtlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmx9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnRCb2R5KGJvZHksIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ID8/IFwicGxhaW5cIjtcbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucz8uc2VwYXJhdG9yID8/IChmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IFwiXFxuXFxuXCIgOiBcIlxcblwiKTtcbiAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgLi4uZm9ybWF0ID09PSBcImh0bWxcIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIDogZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgOiBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMsXG4gICAgLi4ub3B0aW9ucz8uZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IGF3YWl0IHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBvcHRpb25zPy5yZXNvbHZlVXNlcnNcbiAgKTtcbiAgY29uc3QgYmxvY2tzID0gYm9keS5jb250ZW50LmZsYXRNYXAoKGJsb2NrLCBibG9ja0luZGV4KSA9PiB7XG4gICAgc3dpdGNoIChibG9jay50eXBlKSB7XG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGJsb2NrLmNoaWxkcmVuLmZsYXRNYXAoKGlubGluZSwgaW5saW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubWVudGlvbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiByZXNvbHZlZFVzZXJzLmdldChpbmxpbmUuaWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5saW5rKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIGhyZWY6IHRvQWJzb2x1dGVVcmwoaW5saW5lLnVybCkgPz8gaW5saW5lLnVybFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlUZXh0KGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMudGV4dCh7IGVsZW1lbnQ6IGlubGluZSB9LCBpbmxpbmVJbmRleCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGVsZW1lbnRzLnBhcmFncmFwaChcbiAgICAgICAgICAgIHsgZWxlbWVudDogYmxvY2ssIGNoaWxkcmVuOiBpbmxpbmVzLmpvaW4oXCJcIikgfSxcbiAgICAgICAgICAgIGJsb2NrSW5kZXhcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcy5qb2luKHNlcGFyYXRvcik7XG59XG5cbi8vIHNyYy9jcmR0cy91dGlscy50c1xuZnVuY3Rpb24gdG9QbGFpbkxzb24obHNvbikge1xuICBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhsc29uLnRvT2JqZWN0KCkpLmZsYXRNYXAoXG4gICAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IFtba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldXSA6IFtdXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgWy4uLmxzb25dLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBkYXRhOiBbLi4ubHNvbl0ubWFwKChpdGVtKSA9PiB0b1BsYWluTHNvbihpdGVtKSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsc29uO1xuICB9XG59XG5cbi8vIHNyYy9pbW11dGFibGUudHNcbmZ1bmN0aW9uIGxzb25PYmplY3RUb0pzb24ob2JqKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbGl2ZU9iamVjdFRvSnNvbihsaXZlT2JqZWN0KSB7XG4gIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QudG9PYmplY3QoKSk7XG59XG5mdW5jdGlvbiBsaXZlTWFwVG9Kc29uKG1hcCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxzb25MaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAobHNvblRvSnNvbik7XG59XG5mdW5jdGlvbiBsaXZlTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUudG9BcnJheSgpKTtcbn1cbmZ1bmN0aW9uIGxzb25Ub0pzb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiBsaXZlT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIGxpdmVMaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4gbGl2ZU1hcFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBMaXZlaWZ5KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3QodmFsdWUubWFwKGRlZXBMaXZlaWZ5KSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBjb25zdCBpbml0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlW2tleV07XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbml0W2tleV0gPSBkZWVwTGl2ZWlmeSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdmVPYmplY3QoaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVMaXN0KGxpdmVMaXN0LCBwcmV2LCBuZXh0KSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IHByZXZFbmQgPSBwcmV2Lmxlbmd0aCAtIDE7XG4gIGxldCBuZXh0RW5kID0gbmV4dC5sZW5ndGggLSAxO1xuICBsZXQgcHJldk5vZGUgPSBwcmV2WzBdO1xuICBsZXQgbmV4dE5vZGUgPSBuZXh0WzBdO1xuICBvdXRlcjoge1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgICsraTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICB9XG4gICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICBwcmV2RW5kLS07XG4gICAgICBuZXh0RW5kLS07XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgfVxuICB9XG4gIGlmIChpID4gcHJldkVuZCkge1xuICAgIGlmIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpID4gbmV4dEVuZCkge1xuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpIDw9IHByZXZFbmQgJiYgaSA8PSBuZXh0RW5kKSB7XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgICBjb25zdCBsaXZlTGlzdE5vZGUgPSBsaXZlTGlzdC5nZXQoaSk7XG4gICAgICBpZiAoaXNMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChuZXh0Tm9kZSkpIHtcbiAgICAgICAgcGF0Y2hMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSwgcHJldk5vZGUsIG5leHROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpdmVMaXN0LnNldChpLCBkZWVwTGl2ZWlmeShuZXh0Tm9kZSkpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0S2V5KGxpdmVPYmplY3QsIGtleSwgcHJldiwgbmV4dCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmV4dCk7XG4gICAgaWYgKG5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICBlcnJvcjIoXG4gICAgICAgIGBOZXcgc3RhdGUgcGF0aDogJyR7bm9uU2VyaWFsaXphYmxlVmFsdWUucGF0aH0nIHZhbHVlOiAnJHtTdHJpbmcoXG4gICAgICAgICAgbm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWVcbiAgICAgICAgKX0nIGlzIG5vdCBzZXJpYWxpemFibGUuXG5Pbmx5IHNlcmlhbGl6YWJsZSB2YWx1ZSBjYW4gYmUgc3luY2VkIHdpdGggTGl2ZWJsb2Nrcy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCB2YWx1ZSA9IGxpdmVPYmplY3QuZ2V0KGtleSk7XG4gIGlmIChuZXh0ID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LmRlbGV0ZShrZXkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfSBlbHNlIGlmIChwcmV2ID09PSBuZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzTGl2ZUxpc3QodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocHJldikgJiYgQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIHBhdGNoTGl2ZUxpc3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2UgaWYgKGlzTGl2ZU9iamVjdCh2YWx1ZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2KSAmJiBpc1BsYWluT2JqZWN0KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0KHJvb3QsIHByZXYsIG5leHQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0S2V5KHJvb3QsIGtleSwgcHJldltrZXldLCBuZXh0W2tleV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICBpZiAobmV4dFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHJvb3QuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyh1cGRhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgcm9vdC51cGRhdGUodXBkYXRlcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmVudHNQYXRoKG5vZGUpIHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICB3aGlsZSAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIGlmIChpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQubm9kZS5faW5kZXhPZlBvc2l0aW9uKG5vZGUucGFyZW50LmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQua2V5KTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Lm5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3Qoc3RhdGUsIHVwZGF0ZXMpIHtcbiAgcmV0dXJuIHVwZGF0ZXMucmVkdWNlKFxuICAgIChzdGF0ZTIsIHVwZGF0ZSkgPT4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZTIsIHVwZGF0ZSksXG4gICAgc3RhdGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoID0gZ2V0UGFyZW50c1BhdGgodXBkYXRlLm5vZGUpO1xuICByZXR1cm4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoSXRlbSA9IHBhdGgucG9wKCk7XG4gIGlmIChwYXRoSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcIkxpdmVPYmplY3RcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU9iamVjdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVMaXN0XCI6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTGlzdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBhcnJheVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3U3RhdGUgPSBzdGF0ZS5tYXAoKHgpID0+IHgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RVcGRhdGUgb2YgdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLm1hcChcbiAgICAgICAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpbmRleCA9PT0gbGlzdFVwZGF0ZS5pbmRleCA/IGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSA6IGl0ZW1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLmluZGV4ID09PSBuZXdTdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUucHVzaChsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNwbGljZShsaXN0VXBkYXRlLmluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggPiBsaXN0VXBkYXRlLmluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4LCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUuaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTWFwXCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVNYXAgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbLi4uc3RhdGVdO1xuICAgIG5ld0FycmF5W3BhdGhJdGVtXSA9IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoXG4gICAgICBzdGF0ZVtwYXRoSXRlbV0sXG4gICAgICBwYXRoLFxuICAgICAgdXBkYXRlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0gZWxzZSBpZiAoaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZVtwYXRoSXRlbV07XG4gICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZUFzT2JqID0gc3RhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZUFzT2JqLFxuICAgICAgICBbcGF0aEl0ZW1dOiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKG5vZGUsIHBhdGgsIHVwZGF0ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2RlcHJlY2F0aW9uLnRzXG52YXIgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIV9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoa2V5KSkge1xuICAgICAgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgZXJyb3JXaXRoVGl0bGUoXCJEZXByZWNhdGlvbiB3YXJuaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBkZXByZWNhdGUobWVzc2FnZSwga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB1c2FnZUVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHVzYWdlRXJyb3IubmFtZSA9IFwiVXNhZ2UgZXJyb3JcIjtcbiAgICBlcnJvcldpdGhUaXRsZShcIlVzYWdlIGVycm9yXCIsIG1lc3NhZ2UpO1xuICAgIHRocm93IHVzYWdlRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySWYoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9saWIvUG9sbGVyLnRzXG5mdW5jdGlvbiBtYWtlUG9sbGVyKGNhbGxiYWNrLCBpbnRlcnZhbCkge1xuICBsZXQgY29udGV4dCA9IHsgc3RhdGU6IFwic3RvcHBlZFwiIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZSgpO1xuICAgIH1cbiAgICB2b2lkIGNhbGxiYWNrKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7IHN0YXRlOiBcInN0b3BwZWRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZShjb25kaXRpb24pIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBzdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5hYmxlXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iakEpIHx8ICFpc1BsYWluT2JqZWN0KG9iakIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgU3RvcFJldHJ5aW5nMiBhcyBTdG9wUmV0cnlpbmcsXG4gIFdlYnNvY2tldENsb3NlQ29kZXMsXG4gIGFja09wLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYXV0b1JldHJ5LFxuICBiNjRkZWNvZGUsXG4gIGNodW5rLFxuICBjbG9uZUxzb24sXG4gIGNvbXBhY3RPYmplY3QsXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRJZCxcbiAgY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCxcbiAgY3JlYXRlU3RvcmUsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGtJbnRlcm5hbCxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbWFwVmFsdWVzLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBuYW5vaWQsXG4gIG5uLFxuICBvYmplY3RUb1F1ZXJ5LFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHJhaXNlLFxuICBzaGFsbG93LFxuICBzdHJpbmdpZnksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5LFxuICB0aHJvd1VzYWdlRXJyb3IsXG4gIHRvUGxhaW5Mc29uLFxuICB0cnlQYXJzZUpzb24sXG4gIHVybCxcbiAgdXJsam9pbixcbiAgd2FpdCxcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/node/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/node/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Liveblocks: () => (/* binding */ Liveblocks),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   WebhookHandler: () => (/* binding */ WebhookHandler),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.getMentionedIdsFromCommentBody),\n/* harmony export */   stringifyCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.stringifyCommentBody)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/core */ \"(rsc)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stablelib/base64 */ \"(rsc)/./node_modules/@stablelib/base64/lib/base64.js\");\n/* harmony import */ var fast_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-sha256 */ \"(rsc)/./node_modules/fast-sha256/sha256.js\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/node\";\nvar PKG_VERSION = \"2.9.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/client.ts\n\n\n// src/Session.ts\n\n\n// src/utils.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nasync function fetchPolyfill() {\n  return typeof globalThis.fetch !== \"undefined\" ? globalThis.fetch : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/tr46\"), __webpack_require__.e(\"vendor-chunks/whatwg-url\"), __webpack_require__.e(\"vendor-chunks/webidl-conversions\"), __webpack_require__.e(\"vendor-chunks/node-fetch\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"))).default;\n}\nfunction isNonEmpty(value) {\n  return typeof value === \"string\" && value.length > 0;\n}\nfunction assertNonEmpty(value, field) {\n  if (!isNonEmpty(value)) {\n    throw new Error(\n      `Invalid value for field \"${field}\". Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`\n    );\n  }\n}\nfunction assertSecretKey(value, field) {\n  if (!isNonEmpty(value) || !value.startsWith(\"sk_\")) {\n    throw new Error(\n      `Invalid value for field \"${field}\". Secret keys must start with \"sk_\". Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n}\nfunction normalizeStatusCode(statusCode) {\n  if (statusCode >= 200 && statusCode < 300) {\n    return 200;\n  } else if (statusCode >= 500) {\n    return 503;\n  } else {\n    return 403;\n  }\n}\n\n// src/Session.ts\nvar ALL_PERMISSIONS = Object.freeze([\n  \"room:write\",\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:write\",\n  \"comments:read\"\n]);\nfunction isPermission(value) {\n  return ALL_PERMISSIONS.includes(value);\n}\nvar MAX_PERMS_PER_SET = 10;\nvar READ_ACCESS = Object.freeze([\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:read\"\n]);\nvar FULL_ACCESS = Object.freeze([\"room:write\", \"comments:write\"]);\nvar roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;\nvar Session = class {\n  /** @internal */\n  constructor(postFn, userId, userInfo) {\n    this.FULL_ACCESS = FULL_ACCESS;\n    this.READ_ACCESS = READ_ACCESS;\n    /** @internal */\n    this._sealed = false;\n    /** @internal */\n    this._permissions = /* @__PURE__ */ new Map();\n    assertNonEmpty(userId, \"userId\");\n    this._postFn = postFn;\n    this._userId = userId;\n    this._userInfo = userInfo;\n  }\n  /** @internal */\n  getOrCreate(roomId) {\n    if (this._sealed) {\n      throw new Error(\"You can no longer change these permissions.\");\n    }\n    let perms = this._permissions.get(roomId);\n    if (perms) {\n      return perms;\n    } else {\n      if (this._permissions.size >= MAX_PERMS_PER_SET) {\n        throw new Error(\n          \"You cannot add permissions for more than 10 rooms in a single token\"\n        );\n      }\n      perms = /* @__PURE__ */ new Set();\n      this._permissions.set(roomId, perms);\n      return perms;\n    }\n  }\n  allow(roomIdOrPattern, newPerms) {\n    if (typeof roomIdOrPattern !== \"string\") {\n      throw new Error(\"Room name or pattern must be a string\");\n    }\n    if (!roomPatternRegex.test(roomIdOrPattern)) {\n      throw new Error(\"Invalid room name or pattern\");\n    }\n    if (newPerms.length === 0) {\n      throw new Error(\"Permission list cannot be empty\");\n    }\n    const existingPerms = this.getOrCreate(roomIdOrPattern);\n    for (const perm of newPerms) {\n      if (!isPermission(perm)) {\n        throw new Error(`Not a valid permission: ${perm}`);\n      }\n      existingPerms.add(perm);\n    }\n    return this;\n  }\n  /** @internal - For unit tests only */\n  hasPermissions() {\n    return this._permissions.size > 0;\n  }\n  /** @internal - For unit tests only */\n  seal() {\n    if (this._sealed) {\n      throw new Error(\n        \"You cannot reuse Session instances. Please create a new session every time.\"\n      );\n    }\n    this._sealed = true;\n  }\n  /** @internal - For unit tests only */\n  serializePermissions() {\n    return Object.fromEntries(\n      Array.from(this._permissions.entries()).map(([pat, perms]) => [\n        pat,\n        Array.from(perms)\n      ])\n    );\n  }\n  /**\n   * Call this to authorize the session to access Liveblocks. Note that this\n   * will return a Liveblocks \"access token\". Anyone that obtains such access\n   * token will have access to the allowed resources.\n   */\n  async authorize() {\n    this.seal();\n    if (!this.hasPermissions()) {\n      console.warn(\n        \"Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n    try {\n      const resp = await this._postFn((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/authorize-user`, {\n        // Required\n        userId: this._userId,\n        permissions: this.serializePermissions(),\n        // Optional metadata\n        userInfo: this._userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: 'Call to /v2/authorize-user failed. See \"error\" for more information.',\n        error: er\n      };\n    }\n  }\n};\n\n// src/client.ts\nvar Liveblocks = class {\n  /**\n   * Interact with the Liveblocks API from your Node.js backend.\n   */\n  constructor(options) {\n    const options_ = options;\n    const secret = options_.secret;\n    assertSecretKey(secret, \"secret\");\n    this._secret = secret;\n    this._baseUrl = new URL(getBaseUrl(options.baseUrl));\n  }\n  /** @internal */\n  async post(path, json) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(json)\n    });\n    return res;\n  }\n  /** @internal */\n  async put(path, json) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url3, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(json)\n    });\n  }\n  /** @internal */\n  async putBinary(path, body, params) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this._baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/octet-stream\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url3, { method: \"PUT\", headers, body });\n  }\n  /** @internal */\n  async delete(path) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, { method: \"DELETE\", headers });\n    return res;\n  }\n  /** @internal */\n  async get(path, params) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this._baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, { method: \"GET\", headers });\n    return res;\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Authentication\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Prepares a new session to authorize a user to access Liveblocks.\n   *\n   * IMPORTANT:\n   * Always make sure that you trust the user making the request to your\n   * backend before calling .prepareSession()!\n   *\n   * @param userId Tell Liveblocks the user ID of the user to authorize. Must\n   * uniquely identify the user account in your system. The uniqueness of this\n   * value will determine how many MAUs will be counted/billed.\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   *\n   */\n  prepareSession(userId, ...rest) {\n    const options = rest[0];\n    return new Session(this.post.bind(this), userId, options?.userInfo);\n  }\n  /**\n   * Call this to authenticate the user as an actor you want to allow to use\n   * Liveblocks.\n   *\n   * You should use this method only if you want to manage your permissions\n   * through the Liveblocks Permissions API. This method is more complicated to\n   * set up, but allows for finer-grained specification of permissions.\n   *\n   * Calling `.identifyUser()` only lets you securely identify a user (and what\n   * groups they belong to). What permissions this user will end up having is\n   * determined by whatever permissions you assign the user/group in your\n   * Liveblocks account, through the Permissions API:\n   * https://liveblocks.io/docs/rooms/permissions\n   *\n   * IMPORTANT:\n   * Always verify that you trust the user making the request before calling\n   * .identifyUser()!\n   *\n   * @param identity Tell Liveblocks the user ID of the user to authenticate.\n   * Must uniquely identify the user account in your system. The uniqueness of\n   * this value will determine how many MAUs will be counted/billed.\n   *\n   * If you also want to assign which groups this user belongs to, use the\n   * object form and specify the `groupIds` property. Those `groupIds` should\n   * match the groupIds you assigned permissions to via the Liveblocks\n   * Permissions API, see\n   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   */\n  // These fields define the security identity of the user. Whatever you pass in here will define which\n  async identifyUser(identity, ...rest) {\n    const options = rest[0];\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/identify-user`;\n    const userId = typeof identity === \"string\" ? identity : identity.userId;\n    const groupIds = typeof identity === \"string\" ? void 0 : identity.groupIds;\n    assertNonEmpty(userId, \"userId\");\n    try {\n      const resp = await this.post(path, {\n        userId,\n        groupIds,\n        // Optional metadata\n        userInfo: options?.userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: `Call to ${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(\n          this._baseUrl,\n          path\n        )} failed. See \"error\" for more information.`,\n        error: er\n      };\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Room\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.\n   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param params.userId (optional) A filter on users accesses.\n   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.\n   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.\n   * @returns A list of rooms.\n   */\n  async getRooms(params = {}) {\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms`;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const queryParams = {\n      limit: params.limit,\n      startingAfter: params.startingAfter,\n      userId: params.userId,\n      groupIds: params.groupIds ? params.groupIds.join(\",\") : void 0,\n      // \"Flatten\" {metadata: {foo: \"bar\"}} to {\"metadata.foo\": \"bar\"}\n      ...Object.fromEntries(\n        Object.entries(params.metadata ?? {}).map(([key, val]) => [\n          `metadata.${key}`,\n          val\n        ])\n      ),\n      query\n    };\n    const res = await this.get(path, queryParams);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const rooms = data.data.map((room) => {\n      const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;\n      const createdAt = new Date(room.createdAt);\n      return {\n        ...room,\n        createdAt,\n        lastConnectionAt\n      };\n    });\n    return {\n      ...data,\n      data: rooms\n    };\n  }\n  /**\n   * Creates a new room with the given id.\n   * @param roomId The id of the room to create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @returns The created room.\n   */\n  async createRoom(roomId, params) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms`, {\n      id: roomId,\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Returns a room with the given id.\n   * @param roomId The id of the room to return.\n   * @returns The room with the given id.\n   */\n  async getRoom(roomId) {\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      createdAt,\n      lastConnectionAt\n    };\n  }\n  /**\n   * Updates specific properties of a room. It’s not necessary to provide the entire room’s information.\n   * Setting a property to `null` means to delete this property.\n   * @param roomId The id of the room to update.\n   * @param params.defaultAccesses (optional) The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @returns The updated room.\n   */\n  async updateRoom(roomId, params) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`, {\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param roomId The id of the room to delete.\n   */\n  async deleteRoom(roomId) {\n    const res = await this.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.\n   * @param roomId The id of the room to get the users from.\n   * @returns A list of users currently present in the requested room.\n   */\n  async getActiveUsers(roomId) {\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/active_users`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.\n   * @param roomId The id of the room to broadcast the event to.\n   * @param message The message to broadcast. It can be any JSON serializable value.\n   */\n  async broadcastEvent(roomId, message) {\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/broadcast_event`,\n      message\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  async getStorageDocument(roomId, format = \"plain-lson\") {\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`, { format });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Initializes a room’s Storage. The room must already exist and have an empty Storage.\n   * Calling this endpoint will disconnect all users from the room if there are any.\n   *\n   * @param roomId The id of the room to initialize the storage from.\n   * @param document The document to initialize the storage with.\n   * @returns The initialized storage document. It is of the same format as the one passed in.\n   */\n  async initializeStorageDocument(roomId, document) {\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`, document);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Deletes all of the room’s Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.\n   * @param roomId The id of the room to delete the storage from.\n   */\n  async deleteStorageDocument(roomId) {\n    const res = await this.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Yjs\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a JSON representation of the room’s Yjs document.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.format (optional) If true, YText will return formatting.\n   * @param params.key (optional) If provided, returns only a single key’s value, e.g. doc.get(key).toJSON().\n   * @param params.type (optional) Used with key to override the inferred type, i.e. \"ymap\" will return doc.get(key, Y.Map).\n   * @returns A JSON representation of the room’s Yjs document.\n   */\n  async getYjsDocument(roomId, params = {}) {\n    const { format, key, type } = params;\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`v2/rooms/${roomId}/ydoc`;\n    const res = await this.get(path, {\n      formatting: format ? \"true\" : void 0,\n      key,\n      type\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Send a Yjs binary update to the room’s Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the room’s Yjs document.\n   * @param roomId The id of the room to send the Yjs binary update to.\n   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.\n   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.\n   */\n  async sendYjsBinaryUpdate(roomId, update, params = {}) {\n    const res = await this.putBinary((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/ydoc`, update, {\n      guid: params.guid\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the room’s Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.\n   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.\n   * @returns The room’s Yjs document encoded as a single binary update.\n   */\n  async getYjsDocumentAsBinaryUpdate(roomId, params = {}) {\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/ydoc-binary`, {\n      guid: params.guid\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return res.arrayBuffer();\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Schema Validation\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Creates a new schema which can be referenced later to enforce a room’s Storage data structure.\n   * @param name The name used to reference the schema. Must be a non-empty string with less than 65 characters and only contain lowercase letters, numbers and dashes\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @returns The created schema.\n   */\n  async createSchema(name, body) {\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas`, {\n      name,\n      body\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Returns a schema by its id.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @returns The schema with the given id.\n   */\n  async getSchema(schemaId) {\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Updates the body for the schema. A schema can only be updated if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @returns The updated schema. The version of the schema will be incremented.\n   */\n  async updateSchema(schemaId, body) {\n    const res = await this.put((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`, {\n      body\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Deletes a schema by its id. A schema can only be deleted if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   */\n  async deleteSchema(schemaId) {\n    const res = await this.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the schema attached to a room.\n   * @param roomId The id of the room to get the schema from.\n   * @returns\n   */\n  async getSchemaByRoomId(roomId) {\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Attaches a schema to a room, and instantly enables runtime schema validation for the room.\n   * If the current contents of the room’s Storage do not match the schema, attaching will fail and the error message will give details on why the schema failed to attach.\n   * @param roomId The id of the room to attach the schema to.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @returns The schema id as JSON.\n   */\n  async attachSchemaToRoom(roomId, schemaId) {\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`, {\n      schema: schemaId\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Detaches a schema from a room, and disables runtime schema validation for the room.\n   * @param roomId The id of the room to detach the schema from.\n   */\n  async detachSchemaFromRoom(roomId) {\n    const res = await this.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Comments\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Gets all the threads in a room.\n   *\n   * @param params.roomId The room ID to get the threads from.\n   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.\n   * @returns A list of threads.\n   */\n  async getThreads(params) {\n    const { roomId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads`, {\n      query\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map((thread) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(thread))\n    };\n  }\n  /**\n   * Gets a thread.\n   *\n   * @param params.roomId The room ID to get the thread from.\n   * @param params.threadId The thread ID.\n   * @returns A thread.\n   */\n  async getThread(params) {\n    const { roomId, threadId } = params;\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Gets a thread's participants.\n   *\n   * Participants are users who have commented on the thread\n   * or users and groups that have been mentioned in a comment.\n   *\n   * @param params.roomId The room ID to get the thread participants from.\n   * @param params.threadId The thread ID to get the participants from.\n   * @returns An object containing an array of participant IDs.\n   */\n  async getThreadParticipants(params) {\n    const { roomId, threadId } = params;\n    const res = await this.get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/participants`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets a thread's comment.\n   *\n   * @param params.roomId The room ID to get the comment from.\n   * @param params.threadId The thread ID to get the comment from.\n   * @param params.commentId The comment ID.\n   * @returns A comment.\n   */\n  async getComment(params) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Creates a comment.\n   *\n   * @param params.roomId The room ID to create the comment in.\n   * @param params.threadId The thread ID to create the comment in.\n   * @param params.data.userId The user ID of the user who is set to create the comment.\n   * @param params.data.createdAt (optional) The date the comment is set to be created.\n   * @param params.data.body The body of the comment.\n   * @returns The created comment.\n   */\n  async createComment(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Edits a comment.\n   * @param params.roomId The room ID to edit the comment in.\n   * @param params.threadId The thread ID to edit the comment in.\n   * @param params.commentId The comment ID to edit.\n   * @param params.data.body The body of the comment.\n   * @param params.data.editedAt (optional) The date the comment was edited.\n   * @returns The edited comment.\n   */\n  async editComment(params) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        ...data,\n        editedAt: data.editedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.\n   * @param params.roomId The room ID to delete the comment in.\n   * @param params.threadId The thread ID to delete the comment in.\n   * @param params.commentId The comment ID to delete.\n   */\n  async deleteComment(params) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Creates a new thread. The thread will be created with the specified comment as its first comment.\n   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.\n   * @param params.roomId The room ID to create the thread in.\n   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number\n   * @param params.thread.comment.userId The user ID of the user who created the comment.\n   * @param params.thread.comment.createdAt (optional) The date the comment was created.\n   * @param params.thread.comment.body The body of the comment.\n   * @returns The created thread. The thread will be created with the specified comment as its first comment.\n   */\n  async createThread(params) {\n    const { roomId, data } = params;\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads`, {\n      ...data,\n      comment: {\n        ...data.comment,\n        createdAt: data.comment.createdAt?.toISOString()\n      }\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Deletes a thread and all of its comments.\n   * @param params.roomId The room ID to delete the thread in.\n   * @param params.threadId The thread ID to delete.\n   */\n  async deleteThread(params) {\n    const { roomId, threadId } = params;\n    const res = await this.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Mark a thread as resolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as resolved.\n   * @param params.data.userId The user ID of the user who marked the thread as resolved.\n   * @returns The thread marked as resolved.\n   */\n  async markThreadAsResolved(params) {\n    const { roomId, threadId } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,\n      {}\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Mark a thread as unresolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as unresolved.\n   * @param params.data.userId The user ID of the user who marked the thread as unresolved.\n   * @returns The thread marked as unresolved.\n   */\n  async markThreadAsUnresolved(params) {\n    const { roomId, threadId } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,\n      {}\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Updates the metadata of the specified thread in a room.\n   * @param params.roomId The room ID to update the thread in.\n   * @param params.threadId The thread ID to update.\n   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number\n   * @param params.data.userId The user ID of the user who updated the thread.\n   * @param params.data.updatedAt (optional) The date the thread is set to be updated.\n   * @returns The updated thread metadata.\n   */\n  async editThreadMetadata(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Adds a new comment reaction to a comment.\n   * @param params.roomId The room ID to add the comment reaction in.\n   * @param params.threadId The thread ID to add the comment reaction in.\n   * @param params.commentId The comment ID to add the reaction in.\n   * @param params.data.emoji The (emoji) reaction to add.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.createdAt (optional) The date the reaction is set to be created.\n   * @returns The created comment reaction.\n   */\n  async addCommentReaction(params) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const reaction = await res.json();\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentUserReaction)(reaction);\n  }\n  /**\n   * Removes a reaction from a comment.\n   * @param params.roomId The room ID to remove the comment reaction from.\n   * @param params.threadId The thread ID to remove the comment reaction from.\n   * @param params.commentId The comment ID to remove the reaction from.\n   * @param params.data.emoji The (emoji) reaction to remove.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.removedAt (optional) The date the reaction is set to be removed.\n   */\n  async removeCommentReaction(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,\n      {\n        ...data,\n        removedAt: data.removedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.inboxNotificationId The ID of the inbox notification to get.\n   */\n  async getInboxNotification(params) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)(\n      await res.json()\n    );\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.\n   */\n  async getInboxNotifications(params) {\n    const { userId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications`, {\n      query\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map(_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)\n    };\n  }\n  /**\n   * Gets the user's room notification settings.\n   * @param params.userId The user ID to get the room notifications from.\n   * @param params.roomId The room ID to get the room notification settings from.\n   */\n  async getRoomNotificationSettings(params) {\n    const { userId, roomId } = params;\n    const res = await this.get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the user's room notification settings.\n   * @param params.userId The user ID to update the room notification settings for.\n   * @param params.roomId The room ID to update the room notification settings for.\n   * @param params.data The new room notification settings for the user.\n   */\n  async updateRoomNotificationSettings(params) {\n    const { userId, roomId, data } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      data\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's room notification settings.\n   * @param params.userId The user ID to delete the room notification settings from.\n   * @param params.roomId The room ID to delete the room notification settings from.\n   */\n  async deleteRoomNotificationSettings(params) {\n    const { userId, roomId } = params;\n    const res = await this.delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Update a room ID.\n   * @param params.roomId The current ID of the room.\n   * @param params.newRoomId The new room ID.\n   */\n  async updateRoomId(params) {\n    const { currentRoomId, newRoomId } = params;\n    const res = await this.post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${currentRoomId}/update-room-id`,\n      {\n        newRoomId\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      lastConnectionAt: data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0\n    };\n  }\n  async triggerInboxNotification(params) {\n    const res = await this.post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/inbox-notifications/trigger`, params);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Deletes an inbox notification for a user.\n   * @param params.userId The user ID for which to delete the inbox notification.\n   * @param params.inboxNotificationId The ID of the inbox notification to delete.\n   */\n  async deleteInboxNotification(params) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Deletes all inbox notifications for a user.\n   * @param params.userId The user ID for which to delete all the inbox notifications.\n   */\n  async deleteAllInboxNotifications(params) {\n    const { userId } = params;\n    const res = await this.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n};\nvar LiveblocksError = class extends Error {\n  constructor(status, message = \"\") {\n    super(message);\n    this.name = \"LiveblocksError\";\n    this.status = status;\n  }\n};\n\n// src/webhooks.ts\n\n\nvar _WebhookHandler = class _WebhookHandler {\n  constructor(secret) {\n    if (!secret) throw new Error(\"Secret is required\");\n    if (typeof secret !== \"string\") throw new Error(\"Secret must be a string\");\n    if (secret.startsWith(_WebhookHandler.secretPrefix) === false)\n      throw new Error(\"Invalid secret, must start with whsec_\");\n    const secretKey = secret.slice(_WebhookHandler.secretPrefix.length);\n    this.secretBuffer = Buffer.from(secretKey, \"base64\");\n  }\n  /**\n   * Verifies a webhook request and returns the event\n   */\n  verifyRequest(request) {\n    const { headers, rawBody } = request;\n    const { webhookId, timestamp, rawSignatures } = this.verifyHeaders(headers);\n    if (typeof rawBody !== \"string\") {\n      throw new Error(\n        `Invalid rawBody field, must be a string, got \"${typeof rawBody}\" instead. It is likely that you need to JSON.stringify the body before passing it.`\n      );\n    }\n    this.verifyTimestamp(timestamp);\n    const signature = this.sign(`${webhookId}.${timestamp}.${rawBody}`);\n    const expectedSignatures = rawSignatures.split(\" \").map((rawSignature) => {\n      const [, parsedSignature] = rawSignature.split(\",\");\n      return parsedSignature;\n    }).filter(isNotUndefined);\n    if (expectedSignatures.includes(signature) === false)\n      throw new Error(\n        `Invalid signature, expected one of ${expectedSignatures.join(\n          \", \"\n        )}, got ${signature}`\n      );\n    const event = JSON.parse(rawBody);\n    this.verifyWebhookEventType(event);\n    return event;\n  }\n  /**\n   * Verifies the headers and returns the webhookId, timestamp and rawSignatures\n   */\n  verifyHeaders(headers) {\n    const usingNativeHeaders = typeof Headers !== \"undefined\" && headers instanceof Headers;\n    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;\n    const sanitizedHeaders = {};\n    Object.keys(normalizedHeaders).forEach((key) => {\n      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];\n    });\n    const webhookId = sanitizedHeaders[\"webhook-id\"];\n    if (typeof webhookId !== \"string\")\n      throw new Error(\"Invalid webhook-id header\");\n    const timestamp = sanitizedHeaders[\"webhook-timestamp\"];\n    if (typeof timestamp !== \"string\")\n      throw new Error(\"Invalid webhook-timestamp header\");\n    const rawSignatures = sanitizedHeaders[\"webhook-signature\"];\n    if (typeof rawSignatures !== \"string\")\n      throw new Error(\"Invalid webhook-signature header\");\n    return { webhookId, timestamp, rawSignatures };\n  }\n  /**\n   * Signs the content with the secret\n   * @param content\n   * @returns `string`\n   */\n  sign(content) {\n    const encoder = new TextEncoder();\n    const toSign = encoder.encode(content);\n    return _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__.encode(fast_sha256__WEBPACK_IMPORTED_MODULE_2__.hmac(this.secretBuffer, toSign));\n  }\n  /**\n   * Verifies that the timestamp is not too old or in the future\n   */\n  verifyTimestamp(timestampHeader) {\n    const now = Math.floor(Date.now() / 1e3);\n    const timestamp = parseInt(timestampHeader, 10);\n    if (isNaN(timestamp)) {\n      throw new Error(\"Invalid timestamp\");\n    }\n    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp too old\");\n    }\n    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp in the future\");\n    }\n  }\n  /**\n   * Ensures that the event is a known event type\n   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node\n   */\n  verifyWebhookEventType(event) {\n    if (event && event.type && [\n      \"storageUpdated\",\n      \"userEntered\",\n      \"userLeft\",\n      \"roomCreated\",\n      \"roomDeleted\",\n      \"commentCreated\",\n      \"commentEdited\",\n      \"commentDeleted\",\n      \"commentReactionAdded\",\n      \"commentReactionRemoved\",\n      \"threadMetadataUpdated\",\n      \"threadCreated\",\n      \"threadDeleted\",\n      \"ydocUpdated\",\n      \"notification\",\n      \"threadMarkedAsResolved\",\n      \"threadMarkedAsUnresolved\"\n    ].includes(event.type)) {\n      if (event.type === \"notification\") {\n        const notification = event;\n        if (notification.data.kind === \"thread\" || notification.data.kind === \"textMention\" || notification.data.kind.startsWith(\"$\")) {\n          return;\n        } else {\n          throw new Error(\n            `Unknown notification kind: ${notification.data.kind}`\n          );\n        }\n      }\n      return;\n    }\n    throw new Error(\n      \"Unknown event type, please upgrade to a higher version of @liveblocks/node\"\n    );\n  }\n};\n_WebhookHandler.secretPrefix = \"whsec_\";\nvar WebhookHandler = _WebhookHandler;\nvar WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;\nvar isNotUndefined = (value) => value !== void 0;\n\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQytDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQVMwQjs7QUFFMUI7QUFDdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsaVdBQW9CO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJMEI7QUFDMUIsNkRBQVc7QUFPVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4Lm1qcz8zYjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGV0ZWN0RHVwZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9ub2RlXCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjIuOS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9jbGllbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRUb0NvbW1lbnREYXRhLFxuICBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uLFxuICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEsXG4gIGNvbnZlcnRUb1RocmVhZERhdGEsXG4gIG9iamVjdFRvUXVlcnksXG4gIHVybCBhcyB1cmwyLFxuICB1cmxqb2luXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy9TZXNzaW9uLnRzXG5pbXBvcnQgeyB1cmwgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hQb2x5ZmlsbCgpIHtcbiAgcmV0dXJuIHR5cGVvZiBnbG9iYWxUaGlzLmZldGNoICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcy5mZXRjaCA6IChhd2FpdCBpbXBvcnQoXCJub2RlLWZldGNoXCIpKS5kZWZhdWx0O1xufVxuZnVuY3Rpb24gaXNOb25FbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBhc3NlcnROb25FbXB0eSh2YWx1ZSwgZmllbGQpIHtcbiAgaWYgKCFpc05vbkVtcHR5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBmaWVsZCBcIiR7ZmllbGR9XCIuIFBsZWFzZSBwcm92aWRlIGEgbm9uLWVtcHR5IHN0cmluZy4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1ub2RlI2F1dGhvcml6ZWBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRTZWNyZXRLZXkodmFsdWUsIGZpZWxkKSB7XG4gIGlmICghaXNOb25FbXB0eSh2YWx1ZSkgfHwgIXZhbHVlLnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgZmllbGQgXCIke2ZpZWxkfVwiLiBTZWNyZXQga2V5cyBtdXN0IHN0YXJ0IHdpdGggXCJza19cIi4gUGxlYXNlIHByb3ZpZGUgdGhlIHNlY3JldCBrZXkgZnJvbSB5b3VyIExpdmVibG9ja3MgZGFzaGJvYXJkIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kYXNoYm9hcmQvYXBpa2V5cy5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplU3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG4gIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgcmV0dXJuIDIwMDtcbiAgfSBlbHNlIGlmIChzdGF0dXNDb2RlID49IDUwMCkge1xuICAgIHJldHVybiA1MDM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDQwMztcbiAgfVxufVxuXG4vLyBzcmMvU2Vzc2lvbi50c1xudmFyIEFMTF9QRVJNSVNTSU9OUyA9IE9iamVjdC5mcmVlemUoW1xuICBcInJvb206d3JpdGVcIixcbiAgXCJyb29tOnJlYWRcIixcbiAgXCJyb29tOnByZXNlbmNlOndyaXRlXCIsXG4gIFwiY29tbWVudHM6d3JpdGVcIixcbiAgXCJjb21tZW50czpyZWFkXCJcbl0pO1xuZnVuY3Rpb24gaXNQZXJtaXNzaW9uKHZhbHVlKSB7XG4gIHJldHVybiBBTExfUEVSTUlTU0lPTlMuaW5jbHVkZXModmFsdWUpO1xufVxudmFyIE1BWF9QRVJNU19QRVJfU0VUID0gMTA7XG52YXIgUkVBRF9BQ0NFU1MgPSBPYmplY3QuZnJlZXplKFtcbiAgXCJyb29tOnJlYWRcIixcbiAgXCJyb29tOnByZXNlbmNlOndyaXRlXCIsXG4gIFwiY29tbWVudHM6cmVhZFwiXG5dKTtcbnZhciBGVUxMX0FDQ0VTUyA9IE9iamVjdC5mcmVlemUoW1wicm9vbTp3cml0ZVwiLCBcImNvbW1lbnRzOndyaXRlXCJdKTtcbnZhciByb29tUGF0dGVyblJlZ2V4ID0gL14oWypdfFteKl17MSwxMjh9WypdPykkLztcbnZhciBTZXNzaW9uID0gY2xhc3Mge1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHBvc3RGbiwgdXNlcklkLCB1c2VySW5mbykge1xuICAgIHRoaXMuRlVMTF9BQ0NFU1MgPSBGVUxMX0FDQ0VTUztcbiAgICB0aGlzLlJFQURfQUNDRVNTID0gUkVBRF9BQ0NFU1M7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3NlYWxlZCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wZXJtaXNzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgYXNzZXJ0Tm9uRW1wdHkodXNlcklkLCBcInVzZXJJZFwiKTtcbiAgICB0aGlzLl9wb3N0Rm4gPSBwb3N0Rm47XG4gICAgdGhpcy5fdXNlcklkID0gdXNlcklkO1xuICAgIHRoaXMuX3VzZXJJbmZvID0gdXNlckluZm87XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXRPckNyZWF0ZShyb29tSWQpIHtcbiAgICBpZiAodGhpcy5fc2VhbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuIG5vIGxvbmdlciBjaGFuZ2UgdGhlc2UgcGVybWlzc2lvbnMuXCIpO1xuICAgIH1cbiAgICBsZXQgcGVybXMgPSB0aGlzLl9wZXJtaXNzaW9ucy5nZXQocm9vbUlkKTtcbiAgICBpZiAocGVybXMpIHtcbiAgICAgIHJldHVybiBwZXJtcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3Blcm1pc3Npb25zLnNpemUgPj0gTUFYX1BFUk1TX1BFUl9TRVQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiWW91IGNhbm5vdCBhZGQgcGVybWlzc2lvbnMgZm9yIG1vcmUgdGhhbiAxMCByb29tcyBpbiBhIHNpbmdsZSB0b2tlblwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwZXJtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9wZXJtaXNzaW9ucy5zZXQocm9vbUlkLCBwZXJtcyk7XG4gICAgICByZXR1cm4gcGVybXM7XG4gICAgfVxuICB9XG4gIGFsbG93KHJvb21JZE9yUGF0dGVybiwgbmV3UGVybXMpIHtcbiAgICBpZiAodHlwZW9mIHJvb21JZE9yUGF0dGVybiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbSBuYW1lIG9yIHBhdHRlcm4gbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCFyb29tUGF0dGVyblJlZ2V4LnRlc3Qocm9vbUlkT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb29tIG5hbWUgb3IgcGF0dGVyblwiKTtcbiAgICB9XG4gICAgaWYgKG5ld1Blcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVybWlzc2lvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdQZXJtcyA9IHRoaXMuZ2V0T3JDcmVhdGUocm9vbUlkT3JQYXR0ZXJuKTtcbiAgICBmb3IgKGNvbnN0IHBlcm0gb2YgbmV3UGVybXMpIHtcbiAgICAgIGlmICghaXNQZXJtaXNzaW9uKHBlcm0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgcGVybWlzc2lvbjogJHtwZXJtfWApO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdQZXJtcy5hZGQocGVybSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgLSBGb3IgdW5pdCB0ZXN0cyBvbmx5ICovXG4gIGhhc1Blcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9wZXJtaXNzaW9ucy5zaXplID4gMDtcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBzZWFsKCkge1xuICAgIGlmICh0aGlzLl9zZWFsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHJldXNlIFNlc3Npb24gaW5zdGFuY2VzLiBQbGVhc2UgY3JlYXRlIGEgbmV3IHNlc3Npb24gZXZlcnkgdGltZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fc2VhbGVkID0gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBzZXJpYWxpemVQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9wZXJtaXNzaW9ucy5lbnRyaWVzKCkpLm1hcCgoW3BhdCwgcGVybXNdKSA9PiBbXG4gICAgICAgIHBhdCxcbiAgICAgICAgQXJyYXkuZnJvbShwZXJtcylcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGF1dGhvcml6ZSB0aGUgc2Vzc2lvbiB0byBhY2Nlc3MgTGl2ZWJsb2Nrcy4gTm90ZSB0aGF0IHRoaXNcbiAgICogd2lsbCByZXR1cm4gYSBMaXZlYmxvY2tzIFwiYWNjZXNzIHRva2VuXCIuIEFueW9uZSB0aGF0IG9idGFpbnMgc3VjaCBhY2Nlc3NcbiAgICogdG9rZW4gd2lsbCBoYXZlIGFjY2VzcyB0byB0aGUgYWxsb3dlZCByZXNvdXJjZXMuXG4gICAqL1xuICBhc3luYyBhdXRob3JpemUoKSB7XG4gICAgdGhpcy5zZWFsKCk7XG4gICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb25zKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJBY2Nlc3MgdG9rZW5zIHdpdGhvdXQgYW55IHBlcm1pc3Npb24gd2lsbCBub3QgYmUgc3VwcG9ydGVkIHNvb24sIHlvdSBzaG91bGQgdXNlIHdpbGRjYXJkcyB3aGVuIHRoZSBjbGllbnQgcmVxdWVzdHMgYSB0b2tlbiBmb3IgcmVzb3VyY2VzIG91dHNpZGUgYSByb29tLiBTZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2FjY2Vzcy10b2tlbnMtbm90LWVub3VnaC1wZXJtaXNzaW9uc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuX3Bvc3RGbih1cmxgL3YyL2F1dGhvcml6ZS11c2VyYCwge1xuICAgICAgICAvLyBSZXF1aXJlZFxuICAgICAgICB1c2VySWQ6IHRoaXMuX3VzZXJJZCxcbiAgICAgICAgcGVybWlzc2lvbnM6IHRoaXMuc2VyaWFsaXplUGVybWlzc2lvbnMoKSxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IHRoaXMuX3VzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogJ0NhbGwgdG8gL3YyL2F1dGhvcml6ZS11c2VyIGZhaWxlZC4gU2VlIFwiZXJyb3JcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICBlcnJvcjogZXJcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTGl2ZWJsb2NrcyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEludGVyYWN0IHdpdGggdGhlIExpdmVibG9ja3MgQVBJIGZyb20geW91ciBOb2RlLmpzIGJhY2tlbmQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc18gPSBvcHRpb25zO1xuICAgIGNvbnN0IHNlY3JldCA9IG9wdGlvbnNfLnNlY3JldDtcbiAgICBhc3NlcnRTZWNyZXRLZXkoc2VjcmV0LCBcInNlY3JldFwiKTtcbiAgICB0aGlzLl9zZWNyZXQgPSBzZWNyZXQ7XG4gICAgdGhpcy5fYmFzZVVybCA9IG5ldyBVUkwoZ2V0QmFzZVVybChvcHRpb25zLmJhc2VVcmwpKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIHBvc3QocGF0aCwganNvbikge1xuICAgIGNvbnN0IHVybDMgPSB1cmxqb2luKHRoaXMuX2Jhc2VVcmwsIHBhdGgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5fc2VjcmV0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsMywge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBwdXQocGF0aCwganNvbikge1xuICAgIGNvbnN0IHVybDMgPSB1cmxqb2luKHRoaXMuX2Jhc2VVcmwsIHBhdGgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5fc2VjcmV0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybDMsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgcHV0QmluYXJ5KHBhdGgsIGJvZHksIHBhcmFtcykge1xuICAgIGNvbnN0IHVybDMgPSB1cmxqb2luKHRoaXMuX2Jhc2VVcmwsIHBhdGgsIHBhcmFtcyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLl9zZWNyZXR9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwzLCB7IG1ldGhvZDogXCJQVVRcIiwgaGVhZGVycywgYm9keSB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIGRlbGV0ZShwYXRoKSB7XG4gICAgY29uc3QgdXJsMyA9IHVybGpvaW4odGhpcy5fYmFzZVVybCwgcGF0aCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLl9zZWNyZXR9YFxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsMywgeyBtZXRob2Q6IFwiREVMRVRFXCIsIGhlYWRlcnMgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIGdldChwYXRoLCBwYXJhbXMpIHtcbiAgICBjb25zdCB1cmwzID0gdXJsam9pbih0aGlzLl9iYXNlVXJsLCBwYXRoLCBwYXJhbXMpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5fc2VjcmV0fWBcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybDMsIHsgbWV0aG9kOiBcIkdFVFwiLCBoZWFkZXJzIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBBdXRoZW50aWNhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhIG5ldyBzZXNzaW9uIHRvIGF1dGhvcml6ZSBhIHVzZXIgdG8gYWNjZXNzIExpdmVibG9ja3MuXG4gICAqXG4gICAqIElNUE9SVEFOVDpcbiAgICogQWx3YXlzIG1ha2Ugc3VyZSB0aGF0IHlvdSB0cnVzdCB0aGUgdXNlciBtYWtpbmcgdGhlIHJlcXVlc3QgdG8geW91clxuICAgKiBiYWNrZW5kIGJlZm9yZSBjYWxsaW5nIC5wcmVwYXJlU2Vzc2lvbigpIVxuICAgKlxuICAgKiBAcGFyYW0gdXNlcklkIFRlbGwgTGl2ZWJsb2NrcyB0aGUgdXNlciBJRCBvZiB0aGUgdXNlciB0byBhdXRob3JpemUuIE11c3RcbiAgICogdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgYWNjb3VudCBpbiB5b3VyIHN5c3RlbS4gVGhlIHVuaXF1ZW5lc3Mgb2YgdGhpc1xuICAgKiB2YWx1ZSB3aWxsIGRldGVybWluZSBob3cgbWFueSBNQVVzIHdpbGwgYmUgY291bnRlZC9iaWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnVzZXJJbmZvIEN1c3RvbSBtZXRhZGF0YSB0byBhdHRhY2ggdG8gdGhpcyB1c2VyLiBEYXRhIHlvdVxuICAgKiBhZGQgaGVyZSB3aWxsIGJlIHZpc2libGUgdG8gYWxsIG90aGVyIGNsaWVudHMgaW4gdGhlIHJvb20sIHRocm91Z2ggdGhlXG4gICAqIGBvdGhlci5pbmZvYCBwcm9wZXJ0eS5cbiAgICpcbiAgICovXG4gIHByZXBhcmVTZXNzaW9uKHVzZXJJZCwgLi4ucmVzdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXN0WzBdO1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbih0aGlzLnBvc3QuYmluZCh0aGlzKSwgdXNlcklkLCBvcHRpb25zPy51c2VySW5mbyk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBhdXRoZW50aWNhdGUgdGhlIHVzZXIgYXMgYW4gYWN0b3IgeW91IHdhbnQgdG8gYWxsb3cgdG8gdXNlXG4gICAqIExpdmVibG9ja3MuXG4gICAqXG4gICAqIFlvdSBzaG91bGQgdXNlIHRoaXMgbWV0aG9kIG9ubHkgaWYgeW91IHdhbnQgdG8gbWFuYWdlIHlvdXIgcGVybWlzc2lvbnNcbiAgICogdGhyb3VnaCB0aGUgTGl2ZWJsb2NrcyBQZXJtaXNzaW9ucyBBUEkuIFRoaXMgbWV0aG9kIGlzIG1vcmUgY29tcGxpY2F0ZWQgdG9cbiAgICogc2V0IHVwLCBidXQgYWxsb3dzIGZvciBmaW5lci1ncmFpbmVkIHNwZWNpZmljYXRpb24gb2YgcGVybWlzc2lvbnMuXG4gICAqXG4gICAqIENhbGxpbmcgYC5pZGVudGlmeVVzZXIoKWAgb25seSBsZXRzIHlvdSBzZWN1cmVseSBpZGVudGlmeSBhIHVzZXIgKGFuZCB3aGF0XG4gICAqIGdyb3VwcyB0aGV5IGJlbG9uZyB0bykuIFdoYXQgcGVybWlzc2lvbnMgdGhpcyB1c2VyIHdpbGwgZW5kIHVwIGhhdmluZyBpc1xuICAgKiBkZXRlcm1pbmVkIGJ5IHdoYXRldmVyIHBlcm1pc3Npb25zIHlvdSBhc3NpZ24gdGhlIHVzZXIvZ3JvdXAgaW4geW91clxuICAgKiBMaXZlYmxvY2tzIGFjY291bnQsIHRocm91Z2ggdGhlIFBlcm1pc3Npb25zIEFQSTpcbiAgICogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3Mvcm9vbXMvcGVybWlzc2lvbnNcbiAgICpcbiAgICogSU1QT1JUQU5UOlxuICAgKiBBbHdheXMgdmVyaWZ5IHRoYXQgeW91IHRydXN0IHRoZSB1c2VyIG1ha2luZyB0aGUgcmVxdWVzdCBiZWZvcmUgY2FsbGluZ1xuICAgKiAuaWRlbnRpZnlVc2VyKCkhXG4gICAqXG4gICAqIEBwYXJhbSBpZGVudGl0eSBUZWxsIExpdmVibG9ja3MgdGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlLlxuICAgKiBNdXN0IHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSB1c2VyIGFjY291bnQgaW4geW91ciBzeXN0ZW0uIFRoZSB1bmlxdWVuZXNzIG9mXG4gICAqIHRoaXMgdmFsdWUgd2lsbCBkZXRlcm1pbmUgaG93IG1hbnkgTUFVcyB3aWxsIGJlIGNvdW50ZWQvYmlsbGVkLlxuICAgKlxuICAgKiBJZiB5b3UgYWxzbyB3YW50IHRvIGFzc2lnbiB3aGljaCBncm91cHMgdGhpcyB1c2VyIGJlbG9uZ3MgdG8sIHVzZSB0aGVcbiAgICogb2JqZWN0IGZvcm0gYW5kIHNwZWNpZnkgdGhlIGBncm91cElkc2AgcHJvcGVydHkuIFRob3NlIGBncm91cElkc2Agc2hvdWxkXG4gICAqIG1hdGNoIHRoZSBncm91cElkcyB5b3UgYXNzaWduZWQgcGVybWlzc2lvbnMgdG8gdmlhIHRoZSBMaXZlYmxvY2tzXG4gICAqIFBlcm1pc3Npb25zIEFQSSwgc2VlXG4gICAqIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3Jvb21zL3Blcm1pc3Npb25zI3Blcm1pc3Npb25zLWxldmVscy1ncm91cHMtYWNjZXNzZXMtZXhhbXBsZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy51c2VySW5mbyBDdXN0b20gbWV0YWRhdGEgdG8gYXR0YWNoIHRvIHRoaXMgdXNlci4gRGF0YSB5b3VcbiAgICogYWRkIGhlcmUgd2lsbCBiZSB2aXNpYmxlIHRvIGFsbCBvdGhlciBjbGllbnRzIGluIHRoZSByb29tLCB0aHJvdWdoIHRoZVxuICAgKiBgb3RoZXIuaW5mb2AgcHJvcGVydHkuXG4gICAqL1xuICAvLyBUaGVzZSBmaWVsZHMgZGVmaW5lIHRoZSBzZWN1cml0eSBpZGVudGl0eSBvZiB0aGUgdXNlci4gV2hhdGV2ZXIgeW91IHBhc3MgaW4gaGVyZSB3aWxsIGRlZmluZSB3aGljaFxuICBhc3luYyBpZGVudGlmeVVzZXIoaWRlbnRpdHksIC4uLnJlc3QpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcmVzdFswXTtcbiAgICBjb25zdCBwYXRoID0gdXJsMmAvdjIvaWRlbnRpZnktdXNlcmA7XG4gICAgY29uc3QgdXNlcklkID0gdHlwZW9mIGlkZW50aXR5ID09PSBcInN0cmluZ1wiID8gaWRlbnRpdHkgOiBpZGVudGl0eS51c2VySWQ7XG4gICAgY29uc3QgZ3JvdXBJZHMgPSB0eXBlb2YgaWRlbnRpdHkgPT09IFwic3RyaW5nXCIgPyB2b2lkIDAgOiBpZGVudGl0eS5ncm91cElkcztcbiAgICBhc3NlcnROb25FbXB0eSh1c2VySWQsIFwidXNlcklkXCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5wb3N0KHBhdGgsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBncm91cElkcyxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IG9wdGlvbnM/LnVzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogYENhbGwgdG8gJHt1cmxqb2luKFxuICAgICAgICAgIHRoaXMuX2Jhc2VVcmwsXG4gICAgICAgICAgcGF0aFxuICAgICAgICApfSBmYWlsZWQuIFNlZSBcImVycm9yXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uYCxcbiAgICAgICAgZXJyb3I6IGVyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFJvb21cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgeW91ciByb29tcy4gVGhlIHJvb21zIGFyZSByZXR1cm5lZCBzb3J0ZWQgYnkgY3JlYXRpb24gZGF0ZSwgZnJvbSBuZXdlc3QgdG8gb2xkZXN0LiBZb3UgY2FuIGZpbHRlciByb29tcyBieSBtZXRhZGF0YSwgdXNlcnMgYWNjZXNzZXMgYW5kIGdyb3VwcyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5saW1pdCAob3B0aW9uYWwpIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiByb29tcyB0byBiZSByZXR1cm5lZC4gVGhlIGxpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIGRlZmF1bHRzIHRvIDIwLlxuICAgKiBAcGFyYW0gcGFyYW1zLnN0YXJ0aW5nQWZ0ZXIgKG9wdGlvbmFsKSBBIGN1cnNvciB1c2VkIGZvciBwYWdpbmF0aW9uLiBZb3UgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiB1c2VycyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5tZXRhZGF0YSAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIG1ldGFkYXRhLiBNdWx0aXBsZSBtZXRhZGF0YSBrZXlzIGNhbiBiZSB1c2VkIHRvIGZpbHRlciByb29tcy5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cElkcyAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIGdyb3VwcyBhY2Nlc3Nlcy4gTXVsdGlwbGUgZ3JvdXBzIGNhbiBiZSB1c2VkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IChvcHRpb25hbCkgQSBxdWVyeSB0byBmaWx0ZXIgcm9vbXMgYnkuIEl0IGlzIGJhc2VkIG9uIG91ciBxdWVyeSBsYW5ndWFnZS4gWW91IGNhbiBmaWx0ZXIgYnkgbWV0YWRhdGEgYW5kIHJvb20gSUQuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiByb29tcy5cbiAgICovXG4gIGFzeW5jIGdldFJvb21zKHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IHVybDJgL3YyL3Jvb21zYDtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KHBhcmFtcy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgIHN0YXJ0aW5nQWZ0ZXI6IHBhcmFtcy5zdGFydGluZ0FmdGVyLFxuICAgICAgdXNlcklkOiBwYXJhbXMudXNlcklkLFxuICAgICAgZ3JvdXBJZHM6IHBhcmFtcy5ncm91cElkcyA/IHBhcmFtcy5ncm91cElkcy5qb2luKFwiLFwiKSA6IHZvaWQgMCxcbiAgICAgIC8vIFwiRmxhdHRlblwiIHttZXRhZGF0YToge2ZvbzogXCJiYXJcIn19IHRvIHtcIm1ldGFkYXRhLmZvb1wiOiBcImJhclwifVxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMubWV0YWRhdGEgPz8ge30pLm1hcCgoW2tleSwgdmFsXSkgPT4gW1xuICAgICAgICAgIGBtZXRhZGF0YS4ke2tleX1gLFxuICAgICAgICAgIHZhbFxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIHF1ZXJ5XG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChwYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3Qgcm9vbXMgPSBkYXRhLmRhdGEubWFwKChyb29tKSA9PiB7XG4gICAgICBjb25zdCBsYXN0Q29ubmVjdGlvbkF0ID0gcm9vbS5sYXN0Q29ubmVjdGlvbkF0ID8gbmV3IERhdGUocm9vbS5sYXN0Q29ubmVjdGlvbkF0KSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKHJvb20uY3JlYXRlZEF0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJvb20sXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgbGFzdENvbm5lY3Rpb25BdFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGRhdGE6IHJvb21zXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGVmYXVsdEFjY2Vzc2VzIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyBjcmVhdGVSb29tKHJvb21JZCwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QWNjZXNzZXMsIGdyb3Vwc0FjY2Vzc2VzLCB1c2Vyc0FjY2Vzc2VzLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmwyYC92Mi9yb29tc2AsIHtcbiAgICAgIGlkOiByb29tSWQsXG4gICAgICBkZWZhdWx0QWNjZXNzZXMsXG4gICAgICBncm91cHNBY2Nlc3NlcyxcbiAgICAgIHVzZXJzQWNjZXNzZXMsXG4gICAgICBtZXRhZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQsXG4gICAgICBjcmVhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcm9vbSB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyBUaGUgcm9vbSB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICovXG4gIGFzeW5jIGdldFJvb20ocm9vbUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgbGFzdENvbm5lY3Rpb25BdCA9IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgbGFzdENvbm5lY3Rpb25BdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgc3BlY2lmaWMgcHJvcGVydGllcyBvZiBhIHJvb20uIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgdGhlIGVudGlyZSByb29t4oCZcyBpbmZvcm1hdGlvbi5cbiAgICogU2V0dGluZyBhIHByb3BlcnR5IHRvIGBudWxsYCBtZWFucyB0byBkZWxldGUgdGhpcyBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRlZmF1bHRBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyB1cGRhdGVSb29tKHJvb21JZCwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QWNjZXNzZXMsIGdyb3Vwc0FjY2Vzc2VzLCB1c2Vyc0FjY2Vzc2VzLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH1gLCB7XG4gICAgICBkZWZhdWx0QWNjZXNzZXMsXG4gICAgICBncm91cHNBY2Nlc3NlcyxcbiAgICAgIHVzZXJzQWNjZXNzZXMsXG4gICAgICBtZXRhZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQsXG4gICAgICBjcmVhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcm9vbSB3aXRoIHRoZSBnaXZlbiBpZC4gQSBkZWxldGVkIHJvb20gaXMgbm8gbG9uZ2VyIGFjY2Vzc2libGUgZnJvbSB0aGUgQVBJIG9yIHRoZSBkYXNoYm9hcmQgYW5kIGl0IGNhbm5vdCBiZSByZXN0b3JlZC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGVsZXRlLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUm9vbShyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH1gKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdXNlcnMgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIHJlcXVlc3RlZCByb29tLiBGb3IgYmV0dGVyIHBlcmZvcm1hbmNlLCB3ZSByZWNvbW1hbmQgdG8gY2FsbCB0aGlzIGVuZHBvaW50IGV2ZXJ5IDEwIHNlY29uZHMgbWF4aW11bS4gRHVwbGljYXRlcyBjYW4gaGFwcGVuIGlmIGEgdXNlciBpcyBpbiB0aGUgcmVxdWVzdGVkIHJvb20gd2l0aCBtdWx0aXBsZSBicm93c2VyIHRhYnMgb3BlbmVkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIHVzZXJzIGZyb20uXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB1c2VycyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgcmVxdWVzdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyBnZXRBY3RpdmVVc2Vycyhyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vYWN0aXZlX3VzZXJzYCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJvYWRjYXN0cyBhbiBldmVudCB0byBhIHJvb20gd2l0aG91dCBoYXZpbmcgdG8gY29ubmVjdCB0byBpdCB2aWEgdGhlIGNsaWVudCBmcm9tIEBsaXZlYmxvY2tzL2NsaWVudC4gVGhlIGNvbm5lY3Rpb25JZCBwYXNzZWQgdG8gZXZlbnQgbGlzdGVuZXJzIGlzIC0xIHdoZW4gdXNpbmcgdGhpcyBBUEkuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGJyb2FkY2FzdCB0aGUgZXZlbnQgdG8uXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJyb2FkY2FzdC4gSXQgY2FuIGJlIGFueSBKU09OIHNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICovXG4gIGFzeW5jIGJyb2FkY2FzdEV2ZW50KHJvb21JZCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9icm9hZGNhc3RfZXZlbnRgLFxuICAgICAgbWVzc2FnZVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZURvY3VtZW50KHJvb21JZCwgZm9ybWF0ID0gXCJwbGFpbi1sc29uXCIpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vc3RvcmFnZWAsIHsgZm9ybWF0IH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHJvb23igJlzIFN0b3JhZ2UuIFRoZSByb29tIG11c3QgYWxyZWFkeSBleGlzdCBhbmQgaGF2ZSBhbiBlbXB0eSBTdG9yYWdlLlxuICAgKiBDYWxsaW5nIHRoaXMgZW5kcG9pbnQgd2lsbCBkaXNjb25uZWN0IGFsbCB1c2VycyBmcm9tIHRoZSByb29tIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGluaXRpYWxpemUgdGhlIHN0b3JhZ2UgZnJvbS5cbiAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBpbml0aWFsaXplIHRoZSBzdG9yYWdlIHdpdGguXG4gICAqIEByZXR1cm5zIFRoZSBpbml0aWFsaXplZCBzdG9yYWdlIGRvY3VtZW50LiBJdCBpcyBvZiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9uZSBwYXNzZWQgaW4uXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplU3RvcmFnZURvY3VtZW50KHJvb21JZCwgZG9jdW1lbnQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgLCBkb2N1bWVudCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIG9mIHRoZSByb29t4oCZcyBTdG9yYWdlIGRhdGEgYW5kIGRpc2Nvbm5lY3QgYWxsIHVzZXJzIGZyb20gdGhlIHJvb20gaWYgdGhlcmUgYXJlIGFueS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgZGVsZXRlIHRoZSBZanMgZG9jdW1lbnQgaW4gdGhlIHJvb20gaWYgb25lIGV4aXN0cy5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGVsZXRlIHRoZSBzdG9yYWdlIGZyb20uXG4gICAqL1xuICBhc3luYyBkZWxldGVTdG9yYWdlRG9jdW1lbnQocm9vbUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFlqc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIFlqcyBkb2N1bWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmZvcm1hdCAob3B0aW9uYWwpIElmIHRydWUsIFlUZXh0IHdpbGwgcmV0dXJuIGZvcm1hdHRpbmcuXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5IChvcHRpb25hbCkgSWYgcHJvdmlkZWQsIHJldHVybnMgb25seSBhIHNpbmdsZSBrZXnigJlzIHZhbHVlLCBlLmcuIGRvYy5nZXQoa2V5KS50b0pTT04oKS5cbiAgICogQHBhcmFtIHBhcmFtcy50eXBlIChvcHRpb25hbCkgVXNlZCB3aXRoIGtleSB0byBvdmVycmlkZSB0aGUgaW5mZXJyZWQgdHlwZSwgaS5lLiBcInltYXBcIiB3aWxsIHJldHVybiBkb2MuZ2V0KGtleSwgWS5NYXApLlxuICAgKiBAcmV0dXJucyBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIGdldFlqc0RvY3VtZW50KHJvb21JZCwgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCB7IGZvcm1hdCwga2V5LCB0eXBlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcGF0aCA9IHVybDJgdjIvcm9vbXMvJHtyb29tSWR9L3lkb2NgO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHBhdGgsIHtcbiAgICAgIGZvcm1hdHRpbmc6IGZvcm1hdCA/IFwidHJ1ZVwiIDogdm9pZCAwLFxuICAgICAga2V5LFxuICAgICAgdHlwZVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgWWpzIGJpbmFyeSB1cGRhdGUgdG8gdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC4gWW91IGNhbiB1c2UgdGhpcyBlbmRwb2ludCB0byBpbml0aWFsaXplIFlqcyBkYXRhIGZvciB0aGUgcm9vbSBvciB0byB1cGRhdGUgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gc2VuZCB0aGUgWWpzIGJpbmFyeSB1cGRhdGUgdG8uXG4gICAqIEBwYXJhbSB1cGRhdGUgVGhlIFlqcyB1cGRhdGUgdG8gc2VuZC4gVHlwaWNhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgWWpzLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKWAuIFJlYWQgdGhlIFtZanMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLnlqcy5kZXYvYXBpL2RvY3VtZW50LXVwZGF0ZXMpIHRvIGxlYXJuIGhvdyB0byBjcmVhdGUgYSBiaW5hcnkgdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmd1aWQgKG9wdGlvbmFsKSBJZiBwcm92aWRlZCwgdGhlIGJpbmFyeSB1cGRhdGUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBZanMgc3ViZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gZ3VpZC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgYmluYXJ5IHVwZGF0ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHJvb3QgWWpzIGRvY3VtZW50LlxuICAgKi9cbiAgYXN5bmMgc2VuZFlqc0JpbmFyeVVwZGF0ZShyb29tSWQsIHVwZGF0ZSwgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnB1dEJpbmFyeSh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0veWRvY2AsIHVwZGF0ZSwge1xuICAgICAgZ3VpZDogcGFyYW1zLmd1aWRcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50IGVuY29kZWQgYXMgYSBzaW5nbGUgYmluYXJ5IHVwZGF0ZS4gVGhpcyBjYW4gYmUgdXNlZCBieSBZLmFwcGx5VXBkYXRlKHJlc3BvbnNlQm9keSkgdG8gZ2V0IGEgY29weSBvZiB0aGUgZG9jdW1lbnQgaW4geW91ciBiYWNrZW5kLlxuICAgKiBTZWUgW1lqcyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MueWpzLmRldi9hcGkvZG9jdW1lbnQtdXBkYXRlcykgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd29ya2luZyB3aXRoIHVwZGF0ZXMuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgWWpzIGRvY3VtZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3VpZCAob3B0aW9uYWwpIElmIHByb3ZpZGVkLCByZXR1cm5zIHRoZSBiaW5hcnkgdXBkYXRlIG9mIHRoZSBZanMgc3ViZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gZ3VpZC4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIHRoZSBiaW5hcnkgdXBkYXRlIG9mIHRoZSByb290IFlqcyBkb2N1bWVudC5cbiAgICogQHJldHVybnMgVGhlIHJvb23igJlzIFlqcyBkb2N1bWVudCBlbmNvZGVkIGFzIGEgc2luZ2xlIGJpbmFyeSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBnZXRZanNEb2N1bWVudEFzQmluYXJ5VXBkYXRlKHJvb21JZCwgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0veWRvYy1iaW5hcnlgLCB7XG4gICAgICBndWlkOiBwYXJhbXMuZ3VpZFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXMuYXJyYXlCdWZmZXIoKTtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFNjaGVtYSBWYWxpZGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2NoZW1hIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGxhdGVyIHRvIGVuZm9yY2UgYSByb29t4oCZcyBTdG9yYWdlIGRhdGEgc3RydWN0dXJlLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgc2NoZW1hLiBNdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyB3aXRoIGxlc3MgdGhhbiA2NSBjaGFyYWN0ZXJzIGFuZCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGxldHRlcnMsIG51bWJlcnMgYW5kIGRhc2hlc1xuICAgKiBAcGFyYW0gYm9keSBUaGUgZXhhY3QgYWxsb3dlZCBzaGFwZSBvZiBkYXRhIGluIHRoZSByb29tLiBJdCBpcyBhIG11bHRpLWxpbmUgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIFtMaXZlYmxvY2tzIHNjaGVtYSBzeW50YXhdKGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3NjaGVtYS12YWxpZGF0aW9uL3N5bnRheCkuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHNjaGVtYS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShuYW1lLCBib2R5KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybDJgL3YyL3NjaGVtYXNgLCB7XG4gICAgICBuYW1lLFxuICAgICAgYm9keVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2NoZW1hIGJ5IGl0cyBpZC5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKiBAcmV0dXJucyBUaGUgc2NoZW1hIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKi9cbiAgYXN5bmMgZ2V0U2NoZW1hKHNjaGVtYUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsMmAvdjIvc2NoZW1hcy8ke3NjaGVtYUlkfWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBib2R5IGZvciB0aGUgc2NoZW1hLiBBIHNjaGVtYSBjYW4gb25seSBiZSB1cGRhdGVkIGlmIGl0IGlzIG5vdCB1c2VkIGJ5IGFueSByb29tLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEBwYXJhbSBib2R5IFRoZSBleGFjdCBhbGxvd2VkIHNoYXBlIG9mIGRhdGEgaW4gdGhlIHJvb20uIEl0IGlzIGEgbXVsdGktbGluZSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgW0xpdmVibG9ja3Mgc2NoZW1hIHN5bnRheF0oaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvcGxhdGZvcm0vc2NoZW1hLXZhbGlkYXRpb24vc3ludGF4KS5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgc2NoZW1hLiBUaGUgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqL1xuICBhc3luYyB1cGRhdGVTY2hlbWEoc2NoZW1hSWQsIGJvZHkpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnB1dCh1cmwyYC92Mi9zY2hlbWFzLyR7c2NoZW1hSWR9YCwge1xuICAgICAgYm9keVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc2NoZW1hIGJ5IGl0cyBpZC4gQSBzY2hlbWEgY2FuIG9ubHkgYmUgZGVsZXRlZCBpZiBpdCBpcyBub3QgdXNlZCBieSBhbnkgcm9vbS5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2NoZW1hKHNjaGVtYUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUodXJsMmAvdjIvc2NoZW1hcy8ke3NjaGVtYUlkfWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY2hlbWEgYXR0YWNoZWQgdG8gYSByb29tLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIHNjaGVtYSBmcm9tLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2NoZW1hQnlSb29tSWQocm9vbUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3NjaGVtYWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIHNjaGVtYSB0byBhIHJvb20sIGFuZCBpbnN0YW50bHkgZW5hYmxlcyBydW50aW1lIHNjaGVtYSB2YWxpZGF0aW9uIGZvciB0aGUgcm9vbS5cbiAgICogSWYgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIHJvb23igJlzIFN0b3JhZ2UgZG8gbm90IG1hdGNoIHRoZSBzY2hlbWEsIGF0dGFjaGluZyB3aWxsIGZhaWwgYW5kIHRoZSBlcnJvciBtZXNzYWdlIHdpbGwgZ2l2ZSBkZXRhaWxzIG9uIHdoeSB0aGUgc2NoZW1hIGZhaWxlZCB0byBhdHRhY2guXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGF0dGFjaCB0aGUgc2NoZW1hIHRvLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEByZXR1cm5zIFRoZSBzY2hlbWEgaWQgYXMgSlNPTi5cbiAgICovXG4gIGFzeW5jIGF0dGFjaFNjaGVtYVRvUm9vbShyb29tSWQsIHNjaGVtYUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9zY2hlbWFgLCB7XG4gICAgICBzY2hlbWE6IHNjaGVtYUlkXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgc2NoZW1hIGZyb20gYSByb29tLCBhbmQgZGlzYWJsZXMgcnVudGltZSBzY2hlbWEgdmFsaWRhdGlvbiBmb3IgdGhlIHJvb20uXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGRldGFjaCB0aGUgc2NoZW1hIGZyb20uXG4gICAqL1xuICBhc3luYyBkZXRhY2hTY2hlbWFGcm9tUm9vbShyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vc2NoZW1hYCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb21tZW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aGUgdGhyZWFkcyBpbiBhIHJvb20uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGdldCB0aGUgdGhyZWFkcyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IFRoZSBxdWVyeSB0byBmaWx0ZXIgdGhyZWFkcyBieS4gSXQgaXMgYmFzZWQgb24gb3VyIHF1ZXJ5IGxhbmd1YWdlIGFuZCBjYW4gZmlsdGVyIGJ5IG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgdGhyZWFkcy5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZHMocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQgfSA9IHBhcmFtcztcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KHBhcmFtcy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzYCwge1xuICAgICAgcXVlcnlcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdGhyZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQuXG4gICAqIEByZXR1cm5zIEEgdGhyZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGhyZWFkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSB0aHJlYWQncyBwYXJ0aWNpcGFudHMuXG4gICAqXG4gICAqIFBhcnRpY2lwYW50cyBhcmUgdXNlcnMgd2hvIGhhdmUgY29tbWVudGVkIG9uIHRoZSB0aHJlYWRcbiAgICogb3IgdXNlcnMgYW5kIGdyb3VwcyB0aGF0IGhhdmUgYmVlbiBtZW50aW9uZWQgaW4gYSBjb21tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZCBwYXJ0aWNpcGFudHMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGdldCB0aGUgcGFydGljaXBhbnRzIGZyb20uXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIHBhcnRpY2lwYW50IElEcy5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZFBhcnRpY2lwYW50cyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L3BhcnRpY2lwYW50c2BcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdGhyZWFkJ3MgY29tbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSBjb21tZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBnZXQgdGhlIGNvbW1lbnQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQuXG4gICAqIEByZXR1cm5zIEEgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGdldENvbW1lbnQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWBcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGNyZWF0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGNyZWF0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gaXMgc2V0IHRvIGNyZWF0ZSB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmNyZWF0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IGlzIHNldCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuYm9keSBUaGUgYm9keSBvZiB0aGUgY29tbWVudC5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNvbW1lbnQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHNgLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRzIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZWRpdCB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGVkaXQgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIGVkaXQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5ib2R5IFRoZSBib2R5IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZWRpdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgY29tbWVudCB3YXMgZWRpdGVkLlxuICAgKiBAcmV0dXJucyBUaGUgZWRpdGVkIGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBlZGl0Q29tbWVudChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGVkaXRlZEF0OiBkYXRhLmVkaXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBjb21tZW50LiBEZWxldGVzIGEgY29tbWVudC4gSWYgdGhlcmUgYXJlIG5vIHJlbWFpbmluZyBjb21tZW50cyBpbiB0aGUgdGhyZWFkLCB0aGUgdGhyZWFkIGlzIGFsc28gZGVsZXRlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZGVsZXRlIHRoZSBjb21tZW50IGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZGVsZXRlIHRoZSBjb21tZW50IGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbW1lbnRJZCBUaGUgY29tbWVudCBJRCB0byBkZWxldGUuXG4gICAqL1xuICBhc3luYyBkZWxldGVDb21tZW50KHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0aHJlYWQuIFRoZSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBjb21tZW50IGFzIGl0cyBmaXJzdCBjb21tZW50LlxuICAgKiBJZiB0aGUgdGhyZWFkIGFscmVhZHkgZXhpc3RzLCBhIGBMaXZlYmxvY2tzRXJyb3JgIHdpbGwgYmUgdGhyb3duIHdpdGggc3RhdHVzIGNvZGUgNDA5LlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBjcmVhdGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQubWV0YWRhdGEgKG9wdGlvbmFsKSBUaGUgbWV0YWRhdGEgZm9yIHRoZSB0aHJlYWQuIFN1cHBvcnRzIHVwdG8gYSBtYXhpbXVtIG9mIDEwIGVudHJpZXMuIFZhbHVlIG11c3QgYmUgYSBzdHJpbmcsIGJvb2xlYW4gb3IgbnVtYmVyXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkLmNvbW1lbnQudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdobyBjcmVhdGVkIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5jb21tZW50LmNyZWF0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IHdhcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5jb21tZW50LmJvZHkgVGhlIGJvZHkgb2YgdGhlIGNvbW1lbnQuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHRocmVhZC4gVGhlIHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbW1lbnQgYXMgaXRzIGZpcnN0IGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVUaHJlYWQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIGRhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHNgLCB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY29tbWVudDoge1xuICAgICAgICAuLi5kYXRhLmNvbW1lbnQsXG4gICAgICAgIGNyZWF0ZWRBdDogZGF0YS5jb21tZW50LmNyZWF0ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgdGhyZWFkIGFuZCBhbGwgb2YgaXRzIGNvbW1lbnRzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVRocmVhZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNYXJrIGEgdGhyZWFkIGFzIHJlc29sdmVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gbWFyayBhcyByZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gbWFya2VkIHRoZSB0aHJlYWQgYXMgcmVzb2x2ZWQuXG4gICAqIEByZXR1cm5zIFRoZSB0aHJlYWQgbWFya2VkIGFzIHJlc29sdmVkLlxuICAgKi9cbiAgYXN5bmMgbWFya1RocmVhZEFzUmVzb2x2ZWQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWFyay1hcy1yZXNvbHZlZGAsXG4gICAgICB7fVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgYSB0aHJlYWQgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgb2YgdGhlIHRocmVhZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIG1hcmsgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gbWFya2VkIHRoZSB0aHJlYWQgYXMgdW5yZXNvbHZlZC5cbiAgICogQHJldHVybnMgVGhlIHRocmVhZCBtYXJrZWQgYXMgdW5yZXNvbHZlZC5cbiAgICovXG4gIGFzeW5jIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWFyay1hcy11bnJlc29sdmVkYCxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIHNwZWNpZmllZCB0aHJlYWQgaW4gYSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byB1cGRhdGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLm1ldGFkYXRhIFRoZSBtZXRhZGF0YSBmb3IgdGhlIHRocmVhZC4gVmFsdWUgbXVzdCBiZSBhIHN0cmluZywgYm9vbGVhbiBvciBudW1iZXJcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gdXBkYXRlZCB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXBkYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHRocmVhZCBpcyBzZXQgdG8gYmUgdXBkYXRlZC5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgdGhyZWFkIG1ldGFkYXRhLlxuICAgKi9cbiAgYXN5bmMgZWRpdFRocmVhZE1ldGFkYXRhKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21ldGFkYXRhYCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnVwZGF0ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgY29tbWVudCByZWFjdGlvbiB0byBhIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGFkZCB0aGUgY29tbWVudCByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGFkZCB0aGUgY29tbWVudCByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gYWRkIHRoZSByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmVtb2ppIFRoZSAoZW1vamkpIHJlYWN0aW9uIHRvIGFkZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhlIHJlYWN0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuY3JlYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHJlYWN0aW9uIGlzIHNldCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb21tZW50IHJlYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgYWRkQ29tbWVudFJlYWN0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9L2FkZC1yZWFjdGlvbmAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGNyZWF0ZWRBdDogZGF0YS5jcmVhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWFjdGlvbiBmcm9tIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gcmVtb3ZlIHRoZSBjb21tZW50IHJlYWN0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byByZW1vdmUgdGhlIGNvbW1lbnQgcmVhY3Rpb24gZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gcmVtb3ZlIHRoZSByZWFjdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZW1vamkgVGhlIChlbW9qaSkgcmVhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5yZW1vdmVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgcmVhY3Rpb24gaXMgc2V0IHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICBhc3luYyByZW1vdmVDb21tZW50UmVhY3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtwYXJhbXMuY29tbWVudElkfS9yZW1vdmUtcmVhY3Rpb25gLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICByZW1vdmVkQXQ6IGRhdGEucmVtb3ZlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byBnZXQgdGhlIGluYm94IG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmJveE5vdGlmaWNhdGlvbklkIFRoZSBJRCBvZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGdldC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBpbmJveE5vdGlmaWNhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQoXG4gICAgICB1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YFxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShcbiAgICAgIGF3YWl0IHJlcy5qc29uKClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmJveCBub3RpZmljYXRpb25zIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IFRoZSBxdWVyeSB0byBmaWx0ZXIgaW5ib3ggbm90aWZpY2F0aW9ucyBieS4gSXQgaXMgYmFzZWQgb24gb3VyIHF1ZXJ5IGxhbmd1YWdlIGFuZCBjYW4gZmlsdGVyIGJ5IHVucmVhZC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9ucyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcXVlcnkgPSBwYXJhbXMucXVlcnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkocGFyYW1zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsMmAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnNgLCB7XG4gICAgICBxdWVyeVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGF0YS5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKi9cbiAgYXN5bmMgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb29tSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYFxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gdXBkYXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIHVwZGF0ZSB0aGUgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEgVGhlIG5ldyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgdGhlIHVzZXIuXG4gICAqL1xuICBhc3luYyB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGRhdGFcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZGVsZXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZyb20uXG4gICAqL1xuICBhc3luYyBkZWxldGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGEgcm9vbSBJRC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIGN1cnJlbnQgSUQgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMubmV3Um9vbUlkIFRoZSBuZXcgcm9vbSBJRC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJvb21JZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSb29tSWQsIG5ld1Jvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7Y3VycmVudFJvb21JZH0vdXBkYXRlLXJvb20taWRgLFxuICAgICAge1xuICAgICAgICBuZXdSb29tSWRcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCksXG4gICAgICBsYXN0Q29ubmVjdGlvbkF0OiBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBhc3luYyB0cmlnZ2VySW5ib3hOb3RpZmljYXRpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybDJgL3YyL2luYm94LW5vdGlmaWNhdGlvbnMvdHJpZ2dlcmAsIHBhcmFtcyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gaW5ib3ggbm90aWZpY2F0aW9uIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIGZvciB3aGljaCB0byBkZWxldGUgdGhlIGluYm94IG5vdGlmaWNhdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmJveE5vdGlmaWNhdGlvbklkIFRoZSBJRCBvZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBpbmJveE5vdGlmaWNhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUoXG4gICAgICB1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YFxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlci5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgZm9yIHdoaWNoIHRvIGRlbGV0ZSBhbGwgdGhlIGluYm94IG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICBhc3luYyBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vaW5ib3gtbm90aWZpY2F0aW9uc2ApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIG1lc3NhZ2UgPSBcIlwiKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJMaXZlYmxvY2tzRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxufTtcblxuLy8gc3JjL3dlYmhvb2tzLnRzXG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSBcIkBzdGFibGVsaWIvYmFzZTY0XCI7XG5pbXBvcnQgKiBhcyBzaGEyNTYgZnJvbSBcImZhc3Qtc2hhMjU2XCI7XG52YXIgX1dlYmhvb2tIYW5kbGVyID0gY2xhc3MgX1dlYmhvb2tIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Ioc2VjcmV0KSB7XG4gICAgaWYgKCFzZWNyZXQpIHRocm93IG5ldyBFcnJvcihcIlNlY3JldCBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiU2VjcmV0IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgaWYgKHNlY3JldC5zdGFydHNXaXRoKF9XZWJob29rSGFuZGxlci5zZWNyZXRQcmVmaXgpID09PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VjcmV0LCBtdXN0IHN0YXJ0IHdpdGggd2hzZWNfXCIpO1xuICAgIGNvbnN0IHNlY3JldEtleSA9IHNlY3JldC5zbGljZShfV2ViaG9va0hhbmRsZXIuc2VjcmV0UHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5zZWNyZXRCdWZmZXIgPSBCdWZmZXIuZnJvbShzZWNyZXRLZXksIFwiYmFzZTY0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIHdlYmhvb2sgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgZXZlbnRcbiAgICovXG4gIHZlcmlmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHsgaGVhZGVycywgcmF3Qm9keSB9ID0gcmVxdWVzdDtcbiAgICBjb25zdCB7IHdlYmhvb2tJZCwgdGltZXN0YW1wLCByYXdTaWduYXR1cmVzIH0gPSB0aGlzLnZlcmlmeUhlYWRlcnMoaGVhZGVycyk7XG4gICAgaWYgKHR5cGVvZiByYXdCb2R5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHJhd0JvZHkgZmllbGQsIG11c3QgYmUgYSBzdHJpbmcsIGdvdCBcIiR7dHlwZW9mIHJhd0JvZHl9XCIgaW5zdGVhZC4gSXQgaXMgbGlrZWx5IHRoYXQgeW91IG5lZWQgdG8gSlNPTi5zdHJpbmdpZnkgdGhlIGJvZHkgYmVmb3JlIHBhc3NpbmcgaXQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy52ZXJpZnlUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLnNpZ24oYCR7d2ViaG9va0lkfS4ke3RpbWVzdGFtcH0uJHtyYXdCb2R5fWApO1xuICAgIGNvbnN0IGV4cGVjdGVkU2lnbmF0dXJlcyA9IHJhd1NpZ25hdHVyZXMuc3BsaXQoXCIgXCIpLm1hcCgocmF3U2lnbmF0dXJlKSA9PiB7XG4gICAgICBjb25zdCBbLCBwYXJzZWRTaWduYXR1cmVdID0gcmF3U2lnbmF0dXJlLnNwbGl0KFwiLFwiKTtcbiAgICAgIHJldHVybiBwYXJzZWRTaWduYXR1cmU7XG4gICAgfSkuZmlsdGVyKGlzTm90VW5kZWZpbmVkKTtcbiAgICBpZiAoZXhwZWN0ZWRTaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkgPT09IGZhbHNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIG9uZSBvZiAke2V4cGVjdGVkU2lnbmF0dXJlcy5qb2luKFxuICAgICAgICAgIFwiLCBcIlxuICAgICAgICApfSwgZ290ICR7c2lnbmF0dXJlfWBcbiAgICAgICk7XG4gICAgY29uc3QgZXZlbnQgPSBKU09OLnBhcnNlKHJhd0JvZHkpO1xuICAgIHRoaXMudmVyaWZ5V2ViaG9va0V2ZW50VHlwZShldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgaGVhZGVycyBhbmQgcmV0dXJucyB0aGUgd2ViaG9va0lkLCB0aW1lc3RhbXAgYW5kIHJhd1NpZ25hdHVyZXNcbiAgICovXG4gIHZlcmlmeUhlYWRlcnMoaGVhZGVycykge1xuICAgIGNvbnN0IHVzaW5nTmF0aXZlSGVhZGVycyA9IHR5cGVvZiBIZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiICYmIGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0gdXNpbmdOYXRpdmVIZWFkZXJzID8gT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMpIDogaGVhZGVycztcbiAgICBjb25zdCBzYW5pdGl6ZWRIZWFkZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMobm9ybWFsaXplZEhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgc2FuaXRpemVkSGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBub3JtYWxpemVkSGVhZGVyc1trZXldO1xuICAgIH0pO1xuICAgIGNvbnN0IHdlYmhvb2tJZCA9IHNhbml0aXplZEhlYWRlcnNbXCJ3ZWJob29rLWlkXCJdO1xuICAgIGlmICh0eXBlb2Ygd2ViaG9va0lkICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3ZWJob29rLWlkIGhlYWRlclwiKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBzYW5pdGl6ZWRIZWFkZXJzW1wid2ViaG9vay10aW1lc3RhbXBcIl07XG4gICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgIT09IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdlYmhvb2stdGltZXN0YW1wIGhlYWRlclwiKTtcbiAgICBjb25zdCByYXdTaWduYXR1cmVzID0gc2FuaXRpemVkSGVhZGVyc1tcIndlYmhvb2stc2lnbmF0dXJlXCJdO1xuICAgIGlmICh0eXBlb2YgcmF3U2lnbmF0dXJlcyAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2ViaG9vay1zaWduYXR1cmUgaGVhZGVyXCIpO1xuICAgIHJldHVybiB7IHdlYmhvb2tJZCwgdGltZXN0YW1wLCByYXdTaWduYXR1cmVzIH07XG4gIH1cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBjb250ZW50IHdpdGggdGhlIHNlY3JldFxuICAgKiBAcGFyYW0gY29udGVudFxuICAgKiBAcmV0dXJucyBgc3RyaW5nYFxuICAgKi9cbiAgc2lnbihjb250ZW50KSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IHRvU2lnbiA9IGVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKHNoYTI1Ni5obWFjKHRoaXMuc2VjcmV0QnVmZmVyLCB0b1NpZ24pKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgdGltZXN0YW1wIGlzIG5vdCB0b28gb2xkIG9yIGluIHRoZSBmdXR1cmVcbiAgICovXG4gIHZlcmlmeVRpbWVzdGFtcCh0aW1lc3RhbXBIZWFkZXIpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KHRpbWVzdGFtcEhlYWRlciwgMTApO1xuICAgIGlmIChpc05hTih0aW1lc3RhbXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRpbWVzdGFtcFwiKTtcbiAgICB9XG4gICAgaWYgKHRpbWVzdGFtcCA8IG5vdyAtIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVzdGFtcCB0b28gb2xkXCIpO1xuICAgIH1cbiAgICBpZiAodGltZXN0YW1wID4gbm93ICsgV0VCSE9PS19UT0xFUkFOQ0VfSU5fU0VDT05EUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGltZXN0YW1wIGluIHRoZSBmdXR1cmVcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIGV2ZW50IGlzIGEga25vd24gZXZlbnQgdHlwZVxuICAgKiBvciB0aHJvd3MgYW5kIHByb21wdHMgdGhlIHVzZXIgdG8gdXBncmFkZSB0byBhIGhpZ2hlciB2ZXJzaW9uIG9mIEBsaXZlYmxvY2tzL25vZGVcbiAgICovXG4gIHZlcmlmeVdlYmhvb2tFdmVudFR5cGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSAmJiBbXG4gICAgICBcInN0b3JhZ2VVcGRhdGVkXCIsXG4gICAgICBcInVzZXJFbnRlcmVkXCIsXG4gICAgICBcInVzZXJMZWZ0XCIsXG4gICAgICBcInJvb21DcmVhdGVkXCIsXG4gICAgICBcInJvb21EZWxldGVkXCIsXG4gICAgICBcImNvbW1lbnRDcmVhdGVkXCIsXG4gICAgICBcImNvbW1lbnRFZGl0ZWRcIixcbiAgICAgIFwiY29tbWVudERlbGV0ZWRcIixcbiAgICAgIFwiY29tbWVudFJlYWN0aW9uQWRkZWRcIixcbiAgICAgIFwiY29tbWVudFJlYWN0aW9uUmVtb3ZlZFwiLFxuICAgICAgXCJ0aHJlYWRNZXRhZGF0YVVwZGF0ZWRcIixcbiAgICAgIFwidGhyZWFkQ3JlYXRlZFwiLFxuICAgICAgXCJ0aHJlYWREZWxldGVkXCIsXG4gICAgICBcInlkb2NVcGRhdGVkXCIsXG4gICAgICBcIm5vdGlmaWNhdGlvblwiLFxuICAgICAgXCJ0aHJlYWRNYXJrZWRBc1Jlc29sdmVkXCIsXG4gICAgICBcInRocmVhZE1hcmtlZEFzVW5yZXNvbHZlZFwiXG4gICAgXS5pbmNsdWRlcyhldmVudC50eXBlKSkge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibm90aWZpY2F0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gZXZlbnQ7XG4gICAgICAgIGlmIChub3RpZmljYXRpb24uZGF0YS5raW5kID09PSBcInRocmVhZFwiIHx8IG5vdGlmaWNhdGlvbi5kYXRhLmtpbmQgPT09IFwidGV4dE1lbnRpb25cIiB8fCBub3RpZmljYXRpb24uZGF0YS5raW5kLnN0YXJ0c1dpdGgoXCIkXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBVbmtub3duIG5vdGlmaWNhdGlvbiBraW5kOiAke25vdGlmaWNhdGlvbi5kYXRhLmtpbmR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmtub3duIGV2ZW50IHR5cGUsIHBsZWFzZSB1cGdyYWRlIHRvIGEgaGlnaGVyIHZlcnNpb24gb2YgQGxpdmVibG9ja3Mvbm9kZVwiXG4gICAgKTtcbiAgfVxufTtcbl9XZWJob29rSGFuZGxlci5zZWNyZXRQcmVmaXggPSBcIndoc2VjX1wiO1xudmFyIFdlYmhvb2tIYW5kbGVyID0gX1dlYmhvb2tIYW5kbGVyO1xudmFyIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMgPSA1ICogNjA7XG52YXIgaXNOb3RVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlICE9PSB2b2lkIDA7XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHtcbiAgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keVxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbmV4cG9ydCB7XG4gIExpdmVibG9ja3MsXG4gIExpdmVibG9ja3NFcnJvcixcbiAgV2ViaG9va0hhbmRsZXIsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/node/dist/index.mjs\n");

/***/ })

};
;